// This file was autogenerated by some hot garbage in the `uniffi-bindgen-react-native` crate.
// Trust me, you don't want to mess with it!
import nativeModule, {
  type UniffiRustFutureContinuationCallback,
  type UniffiForeignFuture,
  type UniffiForeignFutureStructU8,
  type UniffiForeignFutureCompleteU8,
  type UniffiForeignFutureStructI8,
  type UniffiForeignFutureCompleteI8,
  type UniffiForeignFutureStructU16,
  type UniffiForeignFutureCompleteU16,
  type UniffiForeignFutureStructI16,
  type UniffiForeignFutureCompleteI16,
  type UniffiForeignFutureStructU32,
  type UniffiForeignFutureCompleteU32,
  type UniffiForeignFutureStructI32,
  type UniffiForeignFutureCompleteI32,
  type UniffiForeignFutureStructU64,
  type UniffiForeignFutureCompleteU64,
  type UniffiForeignFutureStructI64,
  type UniffiForeignFutureCompleteI64,
  type UniffiForeignFutureStructF32,
  type UniffiForeignFutureCompleteF32,
  type UniffiForeignFutureStructF64,
  type UniffiForeignFutureCompleteF64,
  type UniffiForeignFutureStructPointer,
  type UniffiForeignFutureCompletePointer,
  type UniffiForeignFutureStructRustBuffer,
  type UniffiForeignFutureCompleteRustBuffer,
  type UniffiForeignFutureStructVoid,
  type UniffiForeignFutureCompleteVoid,
  type UniffiVTableCallbackInterfaceFfiAuthCallback,
  type UniffiVTableCallbackInterfaceFfiConsentCallback,
  type UniffiVTableCallbackInterfaceFfiConversationCallback,
  type UniffiVTableCallbackInterfaceFfiInboxOwner,
  type UniffiVTableCallbackInterfaceFfiMessageCallback,
  type UniffiVTableCallbackInterfaceFfiMessageDeletionCallback,
  type UniffiVTableCallbackInterfaceFfiPreferenceCallback,
} from './xmtpv3-ffi';
import {
  type FfiConverter,
  type UniffiByteArray,
  type UniffiHandle,
  type UniffiObjectFactory,
  type UniffiReferenceHolder,
  type UniffiRustArcPtr,
  type UniffiRustCallStatus,
  type UnsafeMutableRawPointer,
  AbstractFfiConverterByteArray,
  FfiConverterArray,
  FfiConverterArrayBuffer,
  FfiConverterBool,
  FfiConverterFloat64,
  FfiConverterInt32,
  FfiConverterInt64,
  FfiConverterMap,
  FfiConverterObject,
  FfiConverterObjectWithCallbacks,
  FfiConverterOptional,
  FfiConverterUInt16,
  FfiConverterUInt32,
  FfiConverterUInt64,
  RustBuffer,
  UniffiAbstractObject,
  UniffiEnum,
  UniffiError,
  UniffiInternalError,
  UniffiResult,
  UniffiRustCaller,
  destructorGuardSymbol,
  pointerLiteralSymbol,
  uniffiCreateFfiConverterString,
  uniffiCreateRecord,
  uniffiRustCallAsync,
  uniffiTraitInterfaceCall,
  uniffiTraitInterfaceCallAsyncWithError,
  uniffiTraitInterfaceCallWithError,
  uniffiTypeNameSymbol,
  variantOrdinalSymbol,
} from 'uniffi-bindgen-react-native';

// Get converters from the other files, if any.
const uniffiCaller = new UniffiRustCaller(() => ({ code: 0 }));

const uniffiIsDebug =
  // @ts-ignore -- The process global might not be defined
  typeof process !== 'object' ||
  // @ts-ignore -- The process global might not be defined
  process?.env?.NODE_ENV !== 'production' ||
  false;
// Public interface members begin here.

/**
 * * Static apply a signature request
 */
export async function applySignatureRequest(
  api: XmtpApiClientInterface,
  signatureRequest: FfiSignatureRequestInterface,
  asyncOpts_?: { signal: AbortSignal }
): Promise<void> /*throws*/ {
  const __stack = uniffiIsDebug ? new Error().stack : undefined;
  try {
    return await uniffiRustCallAsync(
      /*rustCaller:*/ uniffiCaller,
      /*rustFutureFunc:*/ () => {
        return nativeModule().ubrn_uniffi_xmtpv3_fn_func_apply_signature_request(
          FfiConverterTypeXmtpApiClient.lower(api),
          FfiConverterTypeFfiSignatureRequest.lower(signatureRequest)
        );
      },
      /*pollFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_poll_void,
      /*cancelFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_cancel_void,
      /*completeFunc:*/ nativeModule()
        .ubrn_ffi_xmtpv3_rust_future_complete_void,
      /*freeFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_free_void,
      /*liftFunc:*/ (_v) => {},
      /*liftString:*/ FfiConverterString.lift,
      /*asyncOpts:*/ asyncOpts_,
      /*errorHandler:*/ FfiConverterTypeGenericError.lift.bind(
        FfiConverterTypeGenericError
      )
    );
  } catch (__error: any) {
    if (uniffiIsDebug && __error instanceof Error) {
      __error.stack = __stack;
    }
    throw __error;
  }
}
/**
 * connect to the XMTP backend
 * specifying `gateway_host` enables the D14n backend
 * and assumes `host` is set to the correct
 * d14n backend url.
 */
export async function connectToBackend(
  v3Host: string,
  gatewayHost: string | undefined,
  isSecure: boolean,
  clientMode: FfiClientMode | undefined,
  appVersion: string | undefined,
  authCallback: FfiAuthCallback | undefined,
  authHandle: FfiAuthHandleInterface | undefined,
  asyncOpts_?: { signal: AbortSignal }
): Promise<XmtpApiClientInterface> /*throws*/ {
  const __stack = uniffiIsDebug ? new Error().stack : undefined;
  try {
    return await uniffiRustCallAsync(
      /*rustCaller:*/ uniffiCaller,
      /*rustFutureFunc:*/ () => {
        return nativeModule().ubrn_uniffi_xmtpv3_fn_func_connect_to_backend(
          FfiConverterString.lower(v3Host),
          FfiConverterOptionalString.lower(gatewayHost),
          FfiConverterBool.lower(isSecure),
          FfiConverterOptionalTypeFfiClientMode.lower(clientMode),
          FfiConverterOptionalString.lower(appVersion),
          FfiConverterOptionalTypeFfiAuthCallback.lower(authCallback),
          FfiConverterOptionalTypeFfiAuthHandle.lower(authHandle)
        );
      },
      /*pollFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_poll_pointer,
      /*cancelFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_cancel_pointer,
      /*completeFunc:*/ nativeModule()
        .ubrn_ffi_xmtpv3_rust_future_complete_pointer,
      /*freeFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_free_pointer,
      /*liftFunc:*/ FfiConverterTypeXmtpApiClient.lift.bind(
        FfiConverterTypeXmtpApiClient
      ),
      /*liftString:*/ FfiConverterString.lift,
      /*asyncOpts:*/ asyncOpts_,
      /*errorHandler:*/ FfiConverterTypeGenericError.lift.bind(
        FfiConverterTypeGenericError
      )
    );
  } catch (__error: any) {
    if (uniffiIsDebug && __error instanceof Error) {
      __error.stack = __stack;
    }
    throw __error;
  }
}
/**
 * It returns a new client of the specified `inbox_id`.
 * Note that the `inbox_id` must be either brand new or already associated with the `account_identifier`.
 * i.e. `inbox_id` cannot be associated with another account address.
 *
 * Prior to calling this function, it's suggested to form `inbox_id`, `account_identifier`, and `nonce` like below.
 *
 * ```text
 * inbox_id = get_inbox_id_for_address(account_identifier)
 * nonce = 0
 *
 * // if inbox_id is not associated, we will create new one.
 * if !inbox_id {
 * if !legacy_key { nonce = random_u64() }
 * inbox_id = generate_inbox_id(account_identifier, nonce)
 * } // Otherwise, we will just use the inbox and ignore the nonce.
 * db_path = $inbox_id-$env
 *
 * xmtp.create_client(account_identifier, nonce, inbox_id, Option<legacy_signed_private_key_proto>)
 * ```
 */
export async function createClient(
  api: XmtpApiClientInterface,
  syncApi: XmtpApiClientInterface,
  db: string | undefined,
  encryptionKey: ArrayBuffer | undefined,
  inboxId: string,
  accountIdentifier: FfiIdentifier,
  nonce: /*u64*/ bigint,
  legacySignedPrivateKeyProto: ArrayBuffer | undefined,
  deviceSyncServerUrl: string | undefined,
  deviceSyncMode: FfiSyncWorkerMode | undefined,
  allowOffline: boolean | undefined,
  forkRecoveryOpts: FfiForkRecoveryOpts | undefined,
  asyncOpts_?: { signal: AbortSignal }
): Promise<FfiXmtpClientInterface> /*throws*/ {
  const __stack = uniffiIsDebug ? new Error().stack : undefined;
  try {
    return await uniffiRustCallAsync(
      /*rustCaller:*/ uniffiCaller,
      /*rustFutureFunc:*/ () => {
        return nativeModule().ubrn_uniffi_xmtpv3_fn_func_create_client(
          FfiConverterTypeXmtpApiClient.lower(api),
          FfiConverterTypeXmtpApiClient.lower(syncApi),
          FfiConverterOptionalString.lower(db),
          FfiConverterOptionalArrayBuffer.lower(encryptionKey),
          FfiConverterString.lower(inboxId),
          FfiConverterTypeFfiIdentifier.lower(accountIdentifier),
          FfiConverterUInt64.lower(nonce),
          FfiConverterOptionalArrayBuffer.lower(legacySignedPrivateKeyProto),
          FfiConverterOptionalString.lower(deviceSyncServerUrl),
          FfiConverterOptionalTypeFfiSyncWorkerMode.lower(deviceSyncMode),
          FfiConverterOptionalBool.lower(allowOffline),
          FfiConverterOptionalTypeFfiForkRecoveryOpts.lower(forkRecoveryOpts)
        );
      },
      /*pollFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_poll_pointer,
      /*cancelFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_cancel_pointer,
      /*completeFunc:*/ nativeModule()
        .ubrn_ffi_xmtpv3_rust_future_complete_pointer,
      /*freeFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_free_pointer,
      /*liftFunc:*/ FfiConverterTypeFfiXmtpClient.lift.bind(
        FfiConverterTypeFfiXmtpClient
      ),
      /*liftString:*/ FfiConverterString.lift,
      /*asyncOpts:*/ asyncOpts_,
      /*errorHandler:*/ FfiConverterTypeGenericError.lift.bind(
        FfiConverterTypeGenericError
      )
    );
  } catch (__error: any) {
    if (uniffiIsDebug && __error instanceof Error) {
      __error.stack = __stack;
    }
    throw __error;
  }
}
export function decodeActions(bytes: ArrayBuffer): FfiActions /*throws*/ {
  return FfiConverterTypeFfiActions.lift(
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeGenericError.lift.bind(
        FfiConverterTypeGenericError
      ),
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_xmtpv3_fn_func_decode_actions(
          FfiConverterArrayBuffer.lower(bytes),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
export function decodeAttachment(bytes: ArrayBuffer): FfiAttachment /*throws*/ {
  return FfiConverterTypeFfiAttachment.lift(
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeGenericError.lift.bind(
        FfiConverterTypeGenericError
      ),
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_xmtpv3_fn_func_decode_attachment(
          FfiConverterArrayBuffer.lower(bytes),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
export function decodeGroupUpdated(
  bytes: ArrayBuffer
): FfiGroupUpdated /*throws*/ {
  return FfiConverterTypeFfiGroupUpdated.lift(
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeGenericError.lift.bind(
        FfiConverterTypeGenericError
      ),
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_xmtpv3_fn_func_decode_group_updated(
          FfiConverterArrayBuffer.lower(bytes),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
export function decodeIntent(bytes: ArrayBuffer): FfiIntent /*throws*/ {
  return FfiConverterTypeFfiIntent.lift(
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeGenericError.lift.bind(
        FfiConverterTypeGenericError
      ),
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_xmtpv3_fn_func_decode_intent(
          FfiConverterArrayBuffer.lower(bytes),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
export function decodeMultiRemoteAttachment(
  bytes: ArrayBuffer
): FfiMultiRemoteAttachment /*throws*/ {
  return FfiConverterTypeFfiMultiRemoteAttachment.lift(
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeGenericError.lift.bind(
        FfiConverterTypeGenericError
      ),
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_xmtpv3_fn_func_decode_multi_remote_attachment(
          FfiConverterArrayBuffer.lower(bytes),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
export function decodeReaction(
  bytes: ArrayBuffer
): FfiReactionPayload /*throws*/ {
  return FfiConverterTypeFfiReactionPayload.lift(
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeGenericError.lift.bind(
        FfiConverterTypeGenericError
      ),
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_xmtpv3_fn_func_decode_reaction(
          FfiConverterArrayBuffer.lower(bytes),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
export function decodeReadReceipt(
  bytes: ArrayBuffer
): FfiReadReceipt /*throws*/ {
  return FfiConverterTypeFfiReadReceipt.lift(
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeGenericError.lift.bind(
        FfiConverterTypeGenericError
      ),
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_xmtpv3_fn_func_decode_read_receipt(
          FfiConverterArrayBuffer.lower(bytes),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
export function decodeRemoteAttachment(
  bytes: ArrayBuffer
): FfiRemoteAttachment /*throws*/ {
  return FfiConverterTypeFfiRemoteAttachment.lift(
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeGenericError.lift.bind(
        FfiConverterTypeGenericError
      ),
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_xmtpv3_fn_func_decode_remote_attachment(
          FfiConverterArrayBuffer.lower(bytes),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
export function decodeReply(bytes: ArrayBuffer): FfiReply /*throws*/ {
  return FfiConverterTypeFfiReply.lift(
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeGenericError.lift.bind(
        FfiConverterTypeGenericError
      ),
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_xmtpv3_fn_func_decode_reply(
          FfiConverterArrayBuffer.lower(bytes),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
export function decodeText(bytes: ArrayBuffer): string /*throws*/ {
  return FfiConverterString.lift(
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeGenericError.lift.bind(
        FfiConverterTypeGenericError
      ),
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_xmtpv3_fn_func_decode_text(
          FfiConverterArrayBuffer.lower(bytes),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
export function decodeTransactionReference(
  bytes: ArrayBuffer
): FfiTransactionReference /*throws*/ {
  return FfiConverterTypeFfiTransactionReference.lift(
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeGenericError.lift.bind(
        FfiConverterTypeGenericError
      ),
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_xmtpv3_fn_func_decode_transaction_reference(
          FfiConverterArrayBuffer.lower(bytes),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
export function decodeWalletSendCalls(
  bytes: ArrayBuffer
): FfiWalletSendCalls /*throws*/ {
  return FfiConverterTypeFfiWalletSendCalls.lift(
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeGenericError.lift.bind(
        FfiConverterTypeGenericError
      ),
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_xmtpv3_fn_func_decode_wallet_send_calls(
          FfiConverterArrayBuffer.lower(bytes),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
export function encodeActions(actions: FfiActions): ArrayBuffer /*throws*/ {
  return FfiConverterArrayBuffer.lift(
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeGenericError.lift.bind(
        FfiConverterTypeGenericError
      ),
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_xmtpv3_fn_func_encode_actions(
          FfiConverterTypeFfiActions.lower(actions),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
export function encodeAttachment(
  attachment: FfiAttachment
): ArrayBuffer /*throws*/ {
  return FfiConverterArrayBuffer.lift(
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeGenericError.lift.bind(
        FfiConverterTypeGenericError
      ),
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_xmtpv3_fn_func_encode_attachment(
          FfiConverterTypeFfiAttachment.lower(attachment),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
export function encodeIntent(intent: FfiIntent): ArrayBuffer /*throws*/ {
  return FfiConverterArrayBuffer.lift(
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeGenericError.lift.bind(
        FfiConverterTypeGenericError
      ),
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_xmtpv3_fn_func_encode_intent(
          FfiConverterTypeFfiIntent.lower(intent),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
export function encodeMultiRemoteAttachment(
  ffiMultiRemoteAttachment: FfiMultiRemoteAttachment
): ArrayBuffer /*throws*/ {
  return FfiConverterArrayBuffer.lift(
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeGenericError.lift.bind(
        FfiConverterTypeGenericError
      ),
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_xmtpv3_fn_func_encode_multi_remote_attachment(
          FfiConverterTypeFfiMultiRemoteAttachment.lower(
            ffiMultiRemoteAttachment
          ),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
export function encodeReaction(
  reaction: FfiReactionPayload
): ArrayBuffer /*throws*/ {
  return FfiConverterArrayBuffer.lift(
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeGenericError.lift.bind(
        FfiConverterTypeGenericError
      ),
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_xmtpv3_fn_func_encode_reaction(
          FfiConverterTypeFfiReactionPayload.lower(reaction),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
export function encodeReadReceipt(
  readReceipt: FfiReadReceipt
): ArrayBuffer /*throws*/ {
  return FfiConverterArrayBuffer.lift(
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeGenericError.lift.bind(
        FfiConverterTypeGenericError
      ),
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_xmtpv3_fn_func_encode_read_receipt(
          FfiConverterTypeFfiReadReceipt.lower(readReceipt),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
export function encodeRemoteAttachment(
  remoteAttachment: FfiRemoteAttachment
): ArrayBuffer /*throws*/ {
  return FfiConverterArrayBuffer.lift(
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeGenericError.lift.bind(
        FfiConverterTypeGenericError
      ),
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_xmtpv3_fn_func_encode_remote_attachment(
          FfiConverterTypeFfiRemoteAttachment.lower(remoteAttachment),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
export function encodeReply(reply: FfiReply): ArrayBuffer /*throws*/ {
  return FfiConverterArrayBuffer.lift(
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeGenericError.lift.bind(
        FfiConverterTypeGenericError
      ),
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_xmtpv3_fn_func_encode_reply(
          FfiConverterTypeFfiReply.lower(reply),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
export function encodeText(text: string): ArrayBuffer /*throws*/ {
  return FfiConverterArrayBuffer.lift(
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeGenericError.lift.bind(
        FfiConverterTypeGenericError
      ),
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_xmtpv3_fn_func_encode_text(
          FfiConverterString.lower(text),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
export function encodeTransactionReference(
  reference: FfiTransactionReference
): ArrayBuffer /*throws*/ {
  return FfiConverterArrayBuffer.lift(
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeGenericError.lift.bind(
        FfiConverterTypeGenericError
      ),
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_xmtpv3_fn_func_encode_transaction_reference(
          FfiConverterTypeFfiTransactionReference.lower(reference),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
export function encodeWalletSendCalls(
  walletSendCalls: FfiWalletSendCalls
): ArrayBuffer /*throws*/ {
  return FfiConverterArrayBuffer.lift(
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeGenericError.lift.bind(
        FfiConverterTypeGenericError
      ),
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_xmtpv3_fn_func_encode_wallet_send_calls(
          FfiConverterTypeFfiWalletSendCalls.lower(walletSendCalls),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
/**
 * turns on logging to a file on-disk in the directory specified.
 * files will be prefixed with 'libxmtp-v{version}.{commit}.{process_type}.{pid}.log' and suffixed with the timestamp,
 * i.e "libxmtp-v1.6.0.abc123.main.12345.log.2025-04-02"
 * A maximum of 'max_files' log files are kept.
 */
export function enterDebugWriter(
  directory: string,
  logLevel: FfiLogLevel,
  rotation: FfiLogRotation,
  maxFiles: /*u32*/ number,
  processType: FfiProcessType
): void /*throws*/ {
  uniffiCaller.rustCallWithError(
    /*liftError:*/ FfiConverterTypeGenericError.lift.bind(
      FfiConverterTypeGenericError
    ),
    /*caller:*/ (callStatus) => {
      nativeModule().ubrn_uniffi_xmtpv3_fn_func_enter_debug_writer(
        FfiConverterString.lower(directory),
        FfiConverterTypeFfiLogLevel.lower(logLevel),
        FfiConverterTypeFfiLogRotation.lower(rotation),
        FfiConverterUInt32.lower(maxFiles),
        FfiConverterTypeFfiProcessType.lower(processType),
        callStatus
      );
    },
    /*liftString:*/ FfiConverterString.lift
  );
}
/**
 * turns on logging to a file on-disk with a specified log level.
 * files will be prefixed with 'libxmtp-v{version}.{commit}.{process_type}.{pid}.log' and suffixed with the timestamp,
 * i.e "libxmtp-v1.6.0.abc123.notif.67890.log.2025-04-02"
 * A maximum of 'max_files' log files are kept.
 */
export function enterDebugWriterWithLevel(
  directory: string,
  rotation: FfiLogRotation,
  maxFiles: /*u32*/ number,
  logLevel: FfiLogLevel,
  processType: FfiProcessType
): void /*throws*/ {
  uniffiCaller.rustCallWithError(
    /*liftError:*/ FfiConverterTypeGenericError.lift.bind(
      FfiConverterTypeGenericError
    ),
    /*caller:*/ (callStatus) => {
      nativeModule().ubrn_uniffi_xmtpv3_fn_func_enter_debug_writer_with_level(
        FfiConverterString.lower(directory),
        FfiConverterTypeFfiLogRotation.lower(rotation),
        FfiConverterUInt32.lower(maxFiles),
        FfiConverterTypeFfiLogLevel.lower(logLevel),
        FfiConverterTypeFfiProcessType.lower(processType),
        callStatus
      );
    },
    /*liftString:*/ FfiConverterString.lift
  );
}
/**
 * 3) Ethereum address from public key (accepts 65-byte 0x04||XY or 64-byte XY).
 */
export function ethereumAddressFromPubkey(
  pubkey: ArrayBuffer
): string /*throws*/ {
  return FfiConverterString.lift(
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeFfiCryptoError.lift.bind(
        FfiConverterTypeFfiCryptoError
      ),
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_xmtpv3_fn_func_ethereum_address_from_pubkey(
          FfiConverterArrayBuffer.lower(pubkey),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
/**
 * 1) Ethereum compatible public key from 32-byte private key.
 * Returns **65-byte uncompressed** (0x04 || X || Y)
 * Private key is automatically zeroized after use for security
 */
export function ethereumGeneratePublicKey(
  privateKey32: ArrayBuffer
): ArrayBuffer /*throws*/ {
  return FfiConverterArrayBuffer.lift(
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeFfiCryptoError.lift.bind(
        FfiConverterTypeFfiCryptoError
      ),
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_xmtpv3_fn_func_ethereum_generate_public_key(
          FfiConverterArrayBuffer.lower(privateKey32),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
/**
 * 4) EIP-191 personal message hash: keccak256("\x19Ethereum Signed Message:\n{len}" || message)
 */
export function ethereumHashPersonal(message: string): ArrayBuffer /*throws*/ {
  return FfiConverterArrayBuffer.lift(
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeFfiCryptoError.lift.bind(
        FfiConverterTypeFfiCryptoError
      ),
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_xmtpv3_fn_func_ethereum_hash_personal(
          FfiConverterString.lower(message),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
/**
 * 2) Ethereum recoverable signature (FFI).
 * Returns 65 bytes `r || s || v`, with **v ∈ {27,28}**
 * (legacy/Electrum encoding where **v = 27 + parity**, parity ∈ {0,1}).
 * - If `hashing == true`: signs per **EIP-191**
 * ("Ethereum Signed Message:\n{len(msg)}" || msg, then keccak256).
 * - If `hashing == false`: `msg` must be a **32-byte** prehash (e.g., keccak256/EIP-712 digest).
 * - Private key is automatically zeroized after signing for security
 */
export function ethereumSignRecoverable(
  msg: ArrayBuffer,
  privateKey32: ArrayBuffer,
  hashing: boolean
): ArrayBuffer /*throws*/ {
  return FfiConverterArrayBuffer.lift(
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeFfiCryptoError.lift.bind(
        FfiConverterTypeFfiCryptoError
      ),
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_xmtpv3_fn_func_ethereum_sign_recoverable(
          FfiConverterArrayBuffer.lower(msg),
          FfiConverterArrayBuffer.lower(privateKey32),
          FfiConverterBool.lower(hashing),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
/**
 * Flush loglines from libxmtp log writer to the file, ensuring logs are written.
 * This should be called before the program exits, to ensure all the logs in memory have been
 * written. this ends the writer thread.
 */
export function exitDebugWriter(): void /*throws*/ {
  uniffiCaller.rustCallWithError(
    /*liftError:*/ FfiConverterTypeGenericError.lift.bind(
      FfiConverterTypeGenericError
    ),
    /*caller:*/ (callStatus) => {
      nativeModule().ubrn_uniffi_xmtpv3_fn_func_exit_debug_writer(callStatus);
    },
    /*liftString:*/ FfiConverterString.lift
  );
}
export function generateInboxId(
  accountIdentifier: FfiIdentifier,
  nonce: /*u64*/ bigint
): string /*throws*/ {
  return FfiConverterString.lift(
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeGenericError.lift.bind(
        FfiConverterTypeGenericError
      ),
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_xmtpv3_fn_func_generate_inbox_id(
          FfiConverterTypeFfiIdentifier.lower(accountIdentifier),
          FfiConverterUInt64.lower(nonce),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
export async function getInboxIdForIdentifier(
  api: XmtpApiClientInterface,
  accountIdentifier: FfiIdentifier,
  asyncOpts_?: { signal: AbortSignal }
): Promise<string | undefined> /*throws*/ {
  const __stack = uniffiIsDebug ? new Error().stack : undefined;
  try {
    return await uniffiRustCallAsync(
      /*rustCaller:*/ uniffiCaller,
      /*rustFutureFunc:*/ () => {
        return nativeModule().ubrn_uniffi_xmtpv3_fn_func_get_inbox_id_for_identifier(
          FfiConverterTypeXmtpApiClient.lower(api),
          FfiConverterTypeFfiIdentifier.lower(accountIdentifier)
        );
      },
      /*pollFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_poll_rust_buffer,
      /*cancelFunc:*/ nativeModule()
        .ubrn_ffi_xmtpv3_rust_future_cancel_rust_buffer,
      /*completeFunc:*/ nativeModule()
        .ubrn_ffi_xmtpv3_rust_future_complete_rust_buffer,
      /*freeFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_free_rust_buffer,
      /*liftFunc:*/ FfiConverterOptionalString.lift.bind(
        FfiConverterOptionalString
      ),
      /*liftString:*/ FfiConverterString.lift,
      /*asyncOpts:*/ asyncOpts_,
      /*errorHandler:*/ FfiConverterTypeGenericError.lift.bind(
        FfiConverterTypeGenericError
      )
    );
  } catch (__error: any) {
    if (uniffiIsDebug && __error instanceof Error) {
      __error.stack = __stack;
    }
    throw __error;
  }
}
export function getVersionInfo(): string {
  return FfiConverterString.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_xmtpv3_fn_func_get_version_info(
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
/**
 * * Static Get the inbox state for each `inbox_id`.
 */
export async function inboxStateFromInboxIds(
  api: XmtpApiClientInterface,
  inboxIds: Array<string>,
  asyncOpts_?: { signal: AbortSignal }
): Promise<Array<FfiInboxState>> /*throws*/ {
  const __stack = uniffiIsDebug ? new Error().stack : undefined;
  try {
    return await uniffiRustCallAsync(
      /*rustCaller:*/ uniffiCaller,
      /*rustFutureFunc:*/ () => {
        return nativeModule().ubrn_uniffi_xmtpv3_fn_func_inbox_state_from_inbox_ids(
          FfiConverterTypeXmtpApiClient.lower(api),
          FfiConverterArrayString.lower(inboxIds)
        );
      },
      /*pollFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_poll_rust_buffer,
      /*cancelFunc:*/ nativeModule()
        .ubrn_ffi_xmtpv3_rust_future_cancel_rust_buffer,
      /*completeFunc:*/ nativeModule()
        .ubrn_ffi_xmtpv3_rust_future_complete_rust_buffer,
      /*freeFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_free_rust_buffer,
      /*liftFunc:*/ FfiConverterArrayTypeFfiInboxState.lift.bind(
        FfiConverterArrayTypeFfiInboxState
      ),
      /*liftString:*/ FfiConverterString.lift,
      /*asyncOpts:*/ asyncOpts_,
      /*errorHandler:*/ FfiConverterTypeGenericError.lift.bind(
        FfiConverterTypeGenericError
      )
    );
  } catch (__error: any) {
    if (uniffiIsDebug && __error instanceof Error) {
      __error.stack = __stack;
    }
    throw __error;
  }
}
export async function isConnected(
  api: XmtpApiClientInterface,
  asyncOpts_?: { signal: AbortSignal }
): Promise<boolean> {
  const __stack = uniffiIsDebug ? new Error().stack : undefined;
  try {
    return await uniffiRustCallAsync(
      /*rustCaller:*/ uniffiCaller,
      /*rustFutureFunc:*/ () => {
        return nativeModule().ubrn_uniffi_xmtpv3_fn_func_is_connected(
          FfiConverterTypeXmtpApiClient.lower(api)
        );
      },
      /*pollFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_poll_i8,
      /*cancelFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_cancel_i8,
      /*completeFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_complete_i8,
      /*freeFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_free_i8,
      /*liftFunc:*/ FfiConverterBool.lift.bind(FfiConverterBool),
      /*liftString:*/ FfiConverterString.lift,
      /*asyncOpts:*/ asyncOpts_
    );
  } catch (__error: any) {
    if (uniffiIsDebug && __error instanceof Error) {
      __error.stack = __stack;
    }
    throw __error;
  }
}
/**
 * * Static revoke a list of installations
 */
export function revokeInstallations(
  api: XmtpApiClientInterface,
  recoveryIdentifier: FfiIdentifier,
  inboxId: string,
  installationIds: Array<ArrayBuffer>
): FfiSignatureRequestInterface /*throws*/ {
  return FfiConverterTypeFfiSignatureRequest.lift(
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeGenericError.lift.bind(
        FfiConverterTypeGenericError
      ),
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_xmtpv3_fn_func_revoke_installations(
          FfiConverterTypeXmtpApiClient.lower(api),
          FfiConverterTypeFfiIdentifier.lower(recoveryIdentifier),
          FfiConverterString.lower(inboxId),
          FfiConverterArrayArrayBuffer.lower(installationIds),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}

export type FfiAction = {
  id: string;
  label: string;
  imageUrl: string | undefined;
  style: FfiActionStyle | undefined;
  expiresAtNs: /*i64*/ bigint | undefined;
};

/**
 * Generated factory for {@link FfiAction} record objects.
 */
export const FfiAction = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<FfiAction, ReturnType<typeof defaults>>(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link FfiAction}, with defaults specified
     * in Rust, in the {@link xmtpv3} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link FfiAction}, with defaults specified
     * in Rust, in the {@link xmtpv3} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link xmtpv3} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<FfiAction>,
  });
})();

const FfiConverterTypeFfiAction = (() => {
  type TypeName = FfiAction;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        id: FfiConverterString.read(from),
        label: FfiConverterString.read(from),
        imageUrl: FfiConverterOptionalString.read(from),
        style: FfiConverterOptionalTypeFfiActionStyle.read(from),
        expiresAtNs: FfiConverterOptionalInt64.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.id, into);
      FfiConverterString.write(value.label, into);
      FfiConverterOptionalString.write(value.imageUrl, into);
      FfiConverterOptionalTypeFfiActionStyle.write(value.style, into);
      FfiConverterOptionalInt64.write(value.expiresAtNs, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.id) +
        FfiConverterString.allocationSize(value.label) +
        FfiConverterOptionalString.allocationSize(value.imageUrl) +
        FfiConverterOptionalTypeFfiActionStyle.allocationSize(value.style) +
        FfiConverterOptionalInt64.allocationSize(value.expiresAtNs)
      );
    }
  }
  return new FFIConverter();
})();

export type FfiActions = {
  id: string;
  description: string;
  actions: Array<FfiAction>;
  expiresAtNs: /*i64*/ bigint | undefined;
};

/**
 * Generated factory for {@link FfiActions} record objects.
 */
export const FfiActions = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<FfiActions, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link FfiActions}, with defaults specified
     * in Rust, in the {@link xmtpv3} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link FfiActions}, with defaults specified
     * in Rust, in the {@link xmtpv3} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link xmtpv3} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<FfiActions>,
  });
})();

const FfiConverterTypeFfiActions = (() => {
  type TypeName = FfiActions;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        id: FfiConverterString.read(from),
        description: FfiConverterString.read(from),
        actions: FfiConverterArrayTypeFfiAction.read(from),
        expiresAtNs: FfiConverterOptionalInt64.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.id, into);
      FfiConverterString.write(value.description, into);
      FfiConverterArrayTypeFfiAction.write(value.actions, into);
      FfiConverterOptionalInt64.write(value.expiresAtNs, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.id) +
        FfiConverterString.allocationSize(value.description) +
        FfiConverterArrayTypeFfiAction.allocationSize(value.actions) +
        FfiConverterOptionalInt64.allocationSize(value.expiresAtNs)
      );
    }
  }
  return new FFIConverter();
})();

export type FfiApiStats = {
  uploadKeyPackage: /*u64*/ bigint;
  fetchKeyPackage: /*u64*/ bigint;
  sendGroupMessages: /*u64*/ bigint;
  sendWelcomeMessages: /*u64*/ bigint;
  queryGroupMessages: /*u64*/ bigint;
  queryWelcomeMessages: /*u64*/ bigint;
  subscribeMessages: /*u64*/ bigint;
  subscribeWelcomes: /*u64*/ bigint;
};

/**
 * Generated factory for {@link FfiApiStats} record objects.
 */
export const FfiApiStats = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<FfiApiStats, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link FfiApiStats}, with defaults specified
     * in Rust, in the {@link xmtpv3} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link FfiApiStats}, with defaults specified
     * in Rust, in the {@link xmtpv3} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link xmtpv3} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<FfiApiStats>,
  });
})();

const FfiConverterTypeFfiApiStats = (() => {
  type TypeName = FfiApiStats;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        uploadKeyPackage: FfiConverterUInt64.read(from),
        fetchKeyPackage: FfiConverterUInt64.read(from),
        sendGroupMessages: FfiConverterUInt64.read(from),
        sendWelcomeMessages: FfiConverterUInt64.read(from),
        queryGroupMessages: FfiConverterUInt64.read(from),
        queryWelcomeMessages: FfiConverterUInt64.read(from),
        subscribeMessages: FfiConverterUInt64.read(from),
        subscribeWelcomes: FfiConverterUInt64.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterUInt64.write(value.uploadKeyPackage, into);
      FfiConverterUInt64.write(value.fetchKeyPackage, into);
      FfiConverterUInt64.write(value.sendGroupMessages, into);
      FfiConverterUInt64.write(value.sendWelcomeMessages, into);
      FfiConverterUInt64.write(value.queryGroupMessages, into);
      FfiConverterUInt64.write(value.queryWelcomeMessages, into);
      FfiConverterUInt64.write(value.subscribeMessages, into);
      FfiConverterUInt64.write(value.subscribeWelcomes, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterUInt64.allocationSize(value.uploadKeyPackage) +
        FfiConverterUInt64.allocationSize(value.fetchKeyPackage) +
        FfiConverterUInt64.allocationSize(value.sendGroupMessages) +
        FfiConverterUInt64.allocationSize(value.sendWelcomeMessages) +
        FfiConverterUInt64.allocationSize(value.queryGroupMessages) +
        FfiConverterUInt64.allocationSize(value.queryWelcomeMessages) +
        FfiConverterUInt64.allocationSize(value.subscribeMessages) +
        FfiConverterUInt64.allocationSize(value.subscribeWelcomes)
      );
    }
  }
  return new FFIConverter();
})();

export type FfiArchiveOptions = {
  startNs: /*i64*/ bigint | undefined;
  endNs: /*i64*/ bigint | undefined;
  elements: Array<FfiBackupElementSelection>;
  excludeDisappearingMessages: boolean;
};

/**
 * Generated factory for {@link FfiArchiveOptions} record objects.
 */
export const FfiArchiveOptions = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<FfiArchiveOptions, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link FfiArchiveOptions}, with defaults specified
     * in Rust, in the {@link xmtpv3} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link FfiArchiveOptions}, with defaults specified
     * in Rust, in the {@link xmtpv3} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link xmtpv3} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<FfiArchiveOptions>,
  });
})();

const FfiConverterTypeFfiArchiveOptions = (() => {
  type TypeName = FfiArchiveOptions;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        startNs: FfiConverterOptionalInt64.read(from),
        endNs: FfiConverterOptionalInt64.read(from),
        elements: FfiConverterArrayTypeFfiBackupElementSelection.read(from),
        excludeDisappearingMessages: FfiConverterBool.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterOptionalInt64.write(value.startNs, into);
      FfiConverterOptionalInt64.write(value.endNs, into);
      FfiConverterArrayTypeFfiBackupElementSelection.write(
        value.elements,
        into
      );
      FfiConverterBool.write(value.excludeDisappearingMessages, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterOptionalInt64.allocationSize(value.startNs) +
        FfiConverterOptionalInt64.allocationSize(value.endNs) +
        FfiConverterArrayTypeFfiBackupElementSelection.allocationSize(
          value.elements
        ) +
        FfiConverterBool.allocationSize(value.excludeDisappearingMessages)
      );
    }
  }
  return new FFIConverter();
})();

export type FfiAttachment = {
  filename: string | undefined;
  mimeType: string;
  content: ArrayBuffer;
};

/**
 * Generated factory for {@link FfiAttachment} record objects.
 */
export const FfiAttachment = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<FfiAttachment, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link FfiAttachment}, with defaults specified
     * in Rust, in the {@link xmtpv3} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link FfiAttachment}, with defaults specified
     * in Rust, in the {@link xmtpv3} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link xmtpv3} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<FfiAttachment>,
  });
})();

const FfiConverterTypeFfiAttachment = (() => {
  type TypeName = FfiAttachment;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        filename: FfiConverterOptionalString.read(from),
        mimeType: FfiConverterString.read(from),
        content: FfiConverterArrayBuffer.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterOptionalString.write(value.filename, into);
      FfiConverterString.write(value.mimeType, into);
      FfiConverterArrayBuffer.write(value.content, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterOptionalString.allocationSize(value.filename) +
        FfiConverterString.allocationSize(value.mimeType) +
        FfiConverterArrayBuffer.allocationSize(value.content)
      );
    }
  }
  return new FFIConverter();
})();

export type FfiBackupMetadata = {
  backupVersion: /*u16*/ number;
  elements: Array<FfiBackupElementSelection>;
  exportedAtNs: /*i64*/ bigint;
  startNs: /*i64*/ bigint | undefined;
  endNs: /*i64*/ bigint | undefined;
};

/**
 * Generated factory for {@link FfiBackupMetadata} record objects.
 */
export const FfiBackupMetadata = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<FfiBackupMetadata, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link FfiBackupMetadata}, with defaults specified
     * in Rust, in the {@link xmtpv3} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link FfiBackupMetadata}, with defaults specified
     * in Rust, in the {@link xmtpv3} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link xmtpv3} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<FfiBackupMetadata>,
  });
})();

const FfiConverterTypeFfiBackupMetadata = (() => {
  type TypeName = FfiBackupMetadata;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        backupVersion: FfiConverterUInt16.read(from),
        elements: FfiConverterArrayTypeFfiBackupElementSelection.read(from),
        exportedAtNs: FfiConverterInt64.read(from),
        startNs: FfiConverterOptionalInt64.read(from),
        endNs: FfiConverterOptionalInt64.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterUInt16.write(value.backupVersion, into);
      FfiConverterArrayTypeFfiBackupElementSelection.write(
        value.elements,
        into
      );
      FfiConverterInt64.write(value.exportedAtNs, into);
      FfiConverterOptionalInt64.write(value.startNs, into);
      FfiConverterOptionalInt64.write(value.endNs, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterUInt16.allocationSize(value.backupVersion) +
        FfiConverterArrayTypeFfiBackupElementSelection.allocationSize(
          value.elements
        ) +
        FfiConverterInt64.allocationSize(value.exportedAtNs) +
        FfiConverterOptionalInt64.allocationSize(value.startNs) +
        FfiConverterOptionalInt64.allocationSize(value.endNs)
      );
    }
  }
  return new FFIConverter();
})();

export type FfiConsent = {
  entityType: FfiConsentEntityType;
  state: FfiConsentState;
  entity: string;
};

/**
 * Generated factory for {@link FfiConsent} record objects.
 */
export const FfiConsent = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<FfiConsent, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link FfiConsent}, with defaults specified
     * in Rust, in the {@link xmtpv3} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link FfiConsent}, with defaults specified
     * in Rust, in the {@link xmtpv3} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link xmtpv3} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<FfiConsent>,
  });
})();

const FfiConverterTypeFfiConsent = (() => {
  type TypeName = FfiConsent;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        entityType: FfiConverterTypeFfiConsentEntityType.read(from),
        state: FfiConverterTypeFfiConsentState.read(from),
        entity: FfiConverterString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterTypeFfiConsentEntityType.write(value.entityType, into);
      FfiConverterTypeFfiConsentState.write(value.state, into);
      FfiConverterString.write(value.entity, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterTypeFfiConsentEntityType.allocationSize(value.entityType) +
        FfiConverterTypeFfiConsentState.allocationSize(value.state) +
        FfiConverterString.allocationSize(value.entity)
      );
    }
  }
  return new FFIConverter();
})();

export type FfiContentTypeId = {
  authorityId: string;
  typeId: string;
  versionMajor: /*u32*/ number;
  versionMinor: /*u32*/ number;
};

/**
 * Generated factory for {@link FfiContentTypeId} record objects.
 */
export const FfiContentTypeId = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<FfiContentTypeId, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link FfiContentTypeId}, with defaults specified
     * in Rust, in the {@link xmtpv3} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link FfiContentTypeId}, with defaults specified
     * in Rust, in the {@link xmtpv3} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link xmtpv3} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<FfiContentTypeId>,
  });
})();

const FfiConverterTypeFfiContentTypeId = (() => {
  type TypeName = FfiContentTypeId;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        authorityId: FfiConverterString.read(from),
        typeId: FfiConverterString.read(from),
        versionMajor: FfiConverterUInt32.read(from),
        versionMinor: FfiConverterUInt32.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.authorityId, into);
      FfiConverterString.write(value.typeId, into);
      FfiConverterUInt32.write(value.versionMajor, into);
      FfiConverterUInt32.write(value.versionMinor, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.authorityId) +
        FfiConverterString.allocationSize(value.typeId) +
        FfiConverterUInt32.allocationSize(value.versionMajor) +
        FfiConverterUInt32.allocationSize(value.versionMinor)
      );
    }
  }
  return new FFIConverter();
})();

export type FfiConversationDebugInfo = {
  epoch: /*u64*/ bigint;
  maybeForked: boolean;
  forkDetails: string;
  isCommitLogForked: boolean | undefined;
  localCommitLog: string;
  remoteCommitLog: string;
  cursor: Array<FfiCursor>;
};

/**
 * Generated factory for {@link FfiConversationDebugInfo} record objects.
 */
export const FfiConversationDebugInfo = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      FfiConversationDebugInfo,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link FfiConversationDebugInfo}, with defaults specified
     * in Rust, in the {@link xmtpv3} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link FfiConversationDebugInfo}, with defaults specified
     * in Rust, in the {@link xmtpv3} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link xmtpv3} crate.
     */
    defaults: () =>
      Object.freeze(defaults()) as Partial<FfiConversationDebugInfo>,
  });
})();

const FfiConverterTypeFfiConversationDebugInfo = (() => {
  type TypeName = FfiConversationDebugInfo;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        epoch: FfiConverterUInt64.read(from),
        maybeForked: FfiConverterBool.read(from),
        forkDetails: FfiConverterString.read(from),
        isCommitLogForked: FfiConverterOptionalBool.read(from),
        localCommitLog: FfiConverterString.read(from),
        remoteCommitLog: FfiConverterString.read(from),
        cursor: FfiConverterArrayTypeFfiCursor.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterUInt64.write(value.epoch, into);
      FfiConverterBool.write(value.maybeForked, into);
      FfiConverterString.write(value.forkDetails, into);
      FfiConverterOptionalBool.write(value.isCommitLogForked, into);
      FfiConverterString.write(value.localCommitLog, into);
      FfiConverterString.write(value.remoteCommitLog, into);
      FfiConverterArrayTypeFfiCursor.write(value.cursor, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterUInt64.allocationSize(value.epoch) +
        FfiConverterBool.allocationSize(value.maybeForked) +
        FfiConverterString.allocationSize(value.forkDetails) +
        FfiConverterOptionalBool.allocationSize(value.isCommitLogForked) +
        FfiConverterString.allocationSize(value.localCommitLog) +
        FfiConverterString.allocationSize(value.remoteCommitLog) +
        FfiConverterArrayTypeFfiCursor.allocationSize(value.cursor)
      );
    }
  }
  return new FFIConverter();
})();

export type FfiConversationMember = {
  inboxId: string;
  accountIdentifiers: Array<FfiIdentifier>;
  installationIds: Array<ArrayBuffer>;
  permissionLevel: FfiPermissionLevel;
  consentState: FfiConsentState;
};

/**
 * Generated factory for {@link FfiConversationMember} record objects.
 */
export const FfiConversationMember = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      FfiConversationMember,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link FfiConversationMember}, with defaults specified
     * in Rust, in the {@link xmtpv3} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link FfiConversationMember}, with defaults specified
     * in Rust, in the {@link xmtpv3} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link xmtpv3} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<FfiConversationMember>,
  });
})();

const FfiConverterTypeFfiConversationMember = (() => {
  type TypeName = FfiConversationMember;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        inboxId: FfiConverterString.read(from),
        accountIdentifiers: FfiConverterArrayTypeFfiIdentifier.read(from),
        installationIds: FfiConverterArrayArrayBuffer.read(from),
        permissionLevel: FfiConverterTypeFfiPermissionLevel.read(from),
        consentState: FfiConverterTypeFfiConsentState.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.inboxId, into);
      FfiConverterArrayTypeFfiIdentifier.write(value.accountIdentifiers, into);
      FfiConverterArrayArrayBuffer.write(value.installationIds, into);
      FfiConverterTypeFfiPermissionLevel.write(value.permissionLevel, into);
      FfiConverterTypeFfiConsentState.write(value.consentState, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.inboxId) +
        FfiConverterArrayTypeFfiIdentifier.allocationSize(
          value.accountIdentifiers
        ) +
        FfiConverterArrayArrayBuffer.allocationSize(value.installationIds) +
        FfiConverterTypeFfiPermissionLevel.allocationSize(
          value.permissionLevel
        ) +
        FfiConverterTypeFfiConsentState.allocationSize(value.consentState)
      );
    }
  }
  return new FFIConverter();
})();

export type FfiCreateDmOptions = {
  messageDisappearingSettings: FfiMessageDisappearingSettings | undefined;
};

/**
 * Generated factory for {@link FfiCreateDmOptions} record objects.
 */
export const FfiCreateDmOptions = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<FfiCreateDmOptions, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link FfiCreateDmOptions}, with defaults specified
     * in Rust, in the {@link xmtpv3} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link FfiCreateDmOptions}, with defaults specified
     * in Rust, in the {@link xmtpv3} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link xmtpv3} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<FfiCreateDmOptions>,
  });
})();

const FfiConverterTypeFfiCreateDMOptions = (() => {
  type TypeName = FfiCreateDmOptions;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        messageDisappearingSettings:
          FfiConverterOptionalTypeFfiMessageDisappearingSettings.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterOptionalTypeFfiMessageDisappearingSettings.write(
        value.messageDisappearingSettings,
        into
      );
    }
    allocationSize(value: TypeName): number {
      return FfiConverterOptionalTypeFfiMessageDisappearingSettings.allocationSize(
        value.messageDisappearingSettings
      );
    }
  }
  return new FFIConverter();
})();

export type FfiCreateGroupOptions = {
  permissions: FfiGroupPermissionsOptions | undefined;
  groupName: string | undefined;
  groupImageUrlSquare: string | undefined;
  groupDescription: string | undefined;
  customPermissionPolicySet: FfiPermissionPolicySet | undefined;
  messageDisappearingSettings: FfiMessageDisappearingSettings | undefined;
  appData: string | undefined;
};

/**
 * Generated factory for {@link FfiCreateGroupOptions} record objects.
 */
export const FfiCreateGroupOptions = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      FfiCreateGroupOptions,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link FfiCreateGroupOptions}, with defaults specified
     * in Rust, in the {@link xmtpv3} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link FfiCreateGroupOptions}, with defaults specified
     * in Rust, in the {@link xmtpv3} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link xmtpv3} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<FfiCreateGroupOptions>,
  });
})();

const FfiConverterTypeFfiCreateGroupOptions = (() => {
  type TypeName = FfiCreateGroupOptions;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        permissions:
          FfiConverterOptionalTypeFfiGroupPermissionsOptions.read(from),
        groupName: FfiConverterOptionalString.read(from),
        groupImageUrlSquare: FfiConverterOptionalString.read(from),
        groupDescription: FfiConverterOptionalString.read(from),
        customPermissionPolicySet:
          FfiConverterOptionalTypeFfiPermissionPolicySet.read(from),
        messageDisappearingSettings:
          FfiConverterOptionalTypeFfiMessageDisappearingSettings.read(from),
        appData: FfiConverterOptionalString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterOptionalTypeFfiGroupPermissionsOptions.write(
        value.permissions,
        into
      );
      FfiConverterOptionalString.write(value.groupName, into);
      FfiConverterOptionalString.write(value.groupImageUrlSquare, into);
      FfiConverterOptionalString.write(value.groupDescription, into);
      FfiConverterOptionalTypeFfiPermissionPolicySet.write(
        value.customPermissionPolicySet,
        into
      );
      FfiConverterOptionalTypeFfiMessageDisappearingSettings.write(
        value.messageDisappearingSettings,
        into
      );
      FfiConverterOptionalString.write(value.appData, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterOptionalTypeFfiGroupPermissionsOptions.allocationSize(
          value.permissions
        ) +
        FfiConverterOptionalString.allocationSize(value.groupName) +
        FfiConverterOptionalString.allocationSize(value.groupImageUrlSquare) +
        FfiConverterOptionalString.allocationSize(value.groupDescription) +
        FfiConverterOptionalTypeFfiPermissionPolicySet.allocationSize(
          value.customPermissionPolicySet
        ) +
        FfiConverterOptionalTypeFfiMessageDisappearingSettings.allocationSize(
          value.messageDisappearingSettings
        ) +
        FfiConverterOptionalString.allocationSize(value.appData)
      );
    }
  }
  return new FFIConverter();
})();

export type FfiCredential = {
  name: string | undefined;
  value: string;
  expiresAtSeconds: /*i64*/ bigint;
};

/**
 * Generated factory for {@link FfiCredential} record objects.
 */
export const FfiCredential = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<FfiCredential, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link FfiCredential}, with defaults specified
     * in Rust, in the {@link xmtpv3} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link FfiCredential}, with defaults specified
     * in Rust, in the {@link xmtpv3} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link xmtpv3} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<FfiCredential>,
  });
})();

const FfiConverterTypeFfiCredential = (() => {
  type TypeName = FfiCredential;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        name: FfiConverterOptionalString.read(from),
        value: FfiConverterString.read(from),
        expiresAtSeconds: FfiConverterInt64.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterOptionalString.write(value.name, into);
      FfiConverterString.write(value.value, into);
      FfiConverterInt64.write(value.expiresAtSeconds, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterOptionalString.allocationSize(value.name) +
        FfiConverterString.allocationSize(value.value) +
        FfiConverterInt64.allocationSize(value.expiresAtSeconds)
      );
    }
  }
  return new FFIConverter();
})();

export type FfiCursor = {
  originatorId: /*u32*/ number;
  sequenceId: /*u64*/ bigint;
};

/**
 * Generated factory for {@link FfiCursor} record objects.
 */
export const FfiCursor = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<FfiCursor, ReturnType<typeof defaults>>(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link FfiCursor}, with defaults specified
     * in Rust, in the {@link xmtpv3} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link FfiCursor}, with defaults specified
     * in Rust, in the {@link xmtpv3} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link xmtpv3} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<FfiCursor>,
  });
})();

const FfiConverterTypeFfiCursor = (() => {
  type TypeName = FfiCursor;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        originatorId: FfiConverterUInt32.read(from),
        sequenceId: FfiConverterUInt64.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterUInt32.write(value.originatorId, into);
      FfiConverterUInt64.write(value.sequenceId, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterUInt32.allocationSize(value.originatorId) +
        FfiConverterUInt64.allocationSize(value.sequenceId)
      );
    }
  }
  return new FFIConverter();
})();

export type FfiDecodedMessageMetadata = {
  id: ArrayBuffer;
  sentAtNs: /*i64*/ bigint;
  kind: FfiGroupMessageKind;
  senderInstallationId: ArrayBuffer;
  senderInboxId: string;
  contentType: FfiContentTypeId;
  conversationId: ArrayBuffer;
  insertedAtNs: /*i64*/ bigint;
};

/**
 * Generated factory for {@link FfiDecodedMessageMetadata} record objects.
 */
export const FfiDecodedMessageMetadata = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      FfiDecodedMessageMetadata,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link FfiDecodedMessageMetadata}, with defaults specified
     * in Rust, in the {@link xmtpv3} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link FfiDecodedMessageMetadata}, with defaults specified
     * in Rust, in the {@link xmtpv3} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link xmtpv3} crate.
     */
    defaults: () =>
      Object.freeze(defaults()) as Partial<FfiDecodedMessageMetadata>,
  });
})();

const FfiConverterTypeFfiDecodedMessageMetadata = (() => {
  type TypeName = FfiDecodedMessageMetadata;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        id: FfiConverterArrayBuffer.read(from),
        sentAtNs: FfiConverterInt64.read(from),
        kind: FfiConverterTypeFfiGroupMessageKind.read(from),
        senderInstallationId: FfiConverterArrayBuffer.read(from),
        senderInboxId: FfiConverterString.read(from),
        contentType: FfiConverterTypeFfiContentTypeId.read(from),
        conversationId: FfiConverterArrayBuffer.read(from),
        insertedAtNs: FfiConverterInt64.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterArrayBuffer.write(value.id, into);
      FfiConverterInt64.write(value.sentAtNs, into);
      FfiConverterTypeFfiGroupMessageKind.write(value.kind, into);
      FfiConverterArrayBuffer.write(value.senderInstallationId, into);
      FfiConverterString.write(value.senderInboxId, into);
      FfiConverterTypeFfiContentTypeId.write(value.contentType, into);
      FfiConverterArrayBuffer.write(value.conversationId, into);
      FfiConverterInt64.write(value.insertedAtNs, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterArrayBuffer.allocationSize(value.id) +
        FfiConverterInt64.allocationSize(value.sentAtNs) +
        FfiConverterTypeFfiGroupMessageKind.allocationSize(value.kind) +
        FfiConverterArrayBuffer.allocationSize(value.senderInstallationId) +
        FfiConverterString.allocationSize(value.senderInboxId) +
        FfiConverterTypeFfiContentTypeId.allocationSize(value.contentType) +
        FfiConverterArrayBuffer.allocationSize(value.conversationId) +
        FfiConverterInt64.allocationSize(value.insertedAtNs)
      );
    }
  }
  return new FFIConverter();
})();

export type FfiEncodedContent = {
  typeId: FfiContentTypeId | undefined;
  parameters: Map<string, string>;
  fallback: string | undefined;
  compression: /*i32*/ number | undefined;
  content: ArrayBuffer;
};

/**
 * Generated factory for {@link FfiEncodedContent} record objects.
 */
export const FfiEncodedContent = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<FfiEncodedContent, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link FfiEncodedContent}, with defaults specified
     * in Rust, in the {@link xmtpv3} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link FfiEncodedContent}, with defaults specified
     * in Rust, in the {@link xmtpv3} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link xmtpv3} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<FfiEncodedContent>,
  });
})();

const FfiConverterTypeFfiEncodedContent = (() => {
  type TypeName = FfiEncodedContent;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        typeId: FfiConverterOptionalTypeFfiContentTypeId.read(from),
        parameters: FfiConverterMapStringString.read(from),
        fallback: FfiConverterOptionalString.read(from),
        compression: FfiConverterOptionalInt32.read(from),
        content: FfiConverterArrayBuffer.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterOptionalTypeFfiContentTypeId.write(value.typeId, into);
      FfiConverterMapStringString.write(value.parameters, into);
      FfiConverterOptionalString.write(value.fallback, into);
      FfiConverterOptionalInt32.write(value.compression, into);
      FfiConverterArrayBuffer.write(value.content, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterOptionalTypeFfiContentTypeId.allocationSize(value.typeId) +
        FfiConverterMapStringString.allocationSize(value.parameters) +
        FfiConverterOptionalString.allocationSize(value.fallback) +
        FfiConverterOptionalInt32.allocationSize(value.compression) +
        FfiConverterArrayBuffer.allocationSize(value.content)
      );
    }
  }
  return new FFIConverter();
})();

export type FfiEnrichedReply = {
  inReplyTo: FfiDecodedMessageInterface | undefined;
  content: FfiDecodedMessageBody | undefined;
  referenceId: string;
};

/**
 * Generated factory for {@link FfiEnrichedReply} record objects.
 */
export const FfiEnrichedReply = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<FfiEnrichedReply, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link FfiEnrichedReply}, with defaults specified
     * in Rust, in the {@link xmtpv3} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link FfiEnrichedReply}, with defaults specified
     * in Rust, in the {@link xmtpv3} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link xmtpv3} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<FfiEnrichedReply>,
  });
})();

const FfiConverterTypeFfiEnrichedReply = (() => {
  type TypeName = FfiEnrichedReply;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        inReplyTo: FfiConverterOptionalTypeFfiDecodedMessage.read(from),
        content: FfiConverterOptionalTypeFfiDecodedMessageBody.read(from),
        referenceId: FfiConverterString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterOptionalTypeFfiDecodedMessage.write(value.inReplyTo, into);
      FfiConverterOptionalTypeFfiDecodedMessageBody.write(value.content, into);
      FfiConverterString.write(value.referenceId, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterOptionalTypeFfiDecodedMessage.allocationSize(
          value.inReplyTo
        ) +
        FfiConverterOptionalTypeFfiDecodedMessageBody.allocationSize(
          value.content
        ) +
        FfiConverterString.allocationSize(value.referenceId)
      );
    }
  }
  return new FFIConverter();
})();

export type FfiForkRecoveryOpts = {
  enableRecoveryRequests: FfiForkRecoveryPolicy;
  groupsToRequestRecovery: Array<string>;
  disableRecoveryResponses: boolean | undefined;
  workerIntervalNs: /*u64*/ bigint | undefined;
};

/**
 * Generated factory for {@link FfiForkRecoveryOpts} record objects.
 */
export const FfiForkRecoveryOpts = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<FfiForkRecoveryOpts, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link FfiForkRecoveryOpts}, with defaults specified
     * in Rust, in the {@link xmtpv3} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link FfiForkRecoveryOpts}, with defaults specified
     * in Rust, in the {@link xmtpv3} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link xmtpv3} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<FfiForkRecoveryOpts>,
  });
})();

const FfiConverterTypeFfiForkRecoveryOpts = (() => {
  type TypeName = FfiForkRecoveryOpts;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        enableRecoveryRequests:
          FfiConverterTypeFfiForkRecoveryPolicy.read(from),
        groupsToRequestRecovery: FfiConverterArrayString.read(from),
        disableRecoveryResponses: FfiConverterOptionalBool.read(from),
        workerIntervalNs: FfiConverterOptionalUInt64.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterTypeFfiForkRecoveryPolicy.write(
        value.enableRecoveryRequests,
        into
      );
      FfiConverterArrayString.write(value.groupsToRequestRecovery, into);
      FfiConverterOptionalBool.write(value.disableRecoveryResponses, into);
      FfiConverterOptionalUInt64.write(value.workerIntervalNs, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterTypeFfiForkRecoveryPolicy.allocationSize(
          value.enableRecoveryRequests
        ) +
        FfiConverterArrayString.allocationSize(value.groupsToRequestRecovery) +
        FfiConverterOptionalBool.allocationSize(
          value.disableRecoveryResponses
        ) +
        FfiConverterOptionalUInt64.allocationSize(value.workerIntervalNs)
      );
    }
  }
  return new FFIConverter();
})();

export type FfiGroupSyncSummary = {
  numEligible: /*u64*/ bigint;
  numSynced: /*u64*/ bigint;
};

/**
 * Generated factory for {@link FfiGroupSyncSummary} record objects.
 */
export const FfiGroupSyncSummary = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<FfiGroupSyncSummary, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link FfiGroupSyncSummary}, with defaults specified
     * in Rust, in the {@link xmtpv3} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link FfiGroupSyncSummary}, with defaults specified
     * in Rust, in the {@link xmtpv3} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link xmtpv3} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<FfiGroupSyncSummary>,
  });
})();

const FfiConverterTypeFfiGroupSyncSummary = (() => {
  type TypeName = FfiGroupSyncSummary;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        numEligible: FfiConverterUInt64.read(from),
        numSynced: FfiConverterUInt64.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterUInt64.write(value.numEligible, into);
      FfiConverterUInt64.write(value.numSynced, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterUInt64.allocationSize(value.numEligible) +
        FfiConverterUInt64.allocationSize(value.numSynced)
      );
    }
  }
  return new FFIConverter();
})();

export type FfiGroupUpdated = {
  initiatedByInboxId: string;
  addedInboxes: Array<FfiInbox>;
  removedInboxes: Array<FfiInbox>;
  leftInboxes: Array<FfiInbox>;
  metadataFieldChanges: Array<FfiMetadataFieldChange>;
  addedAdminInboxes: Array<FfiInbox>;
  removedAdminInboxes: Array<FfiInbox>;
  addedSuperAdminInboxes: Array<FfiInbox>;
  removedSuperAdminInboxes: Array<FfiInbox>;
};

/**
 * Generated factory for {@link FfiGroupUpdated} record objects.
 */
export const FfiGroupUpdated = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<FfiGroupUpdated, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link FfiGroupUpdated}, with defaults specified
     * in Rust, in the {@link xmtpv3} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link FfiGroupUpdated}, with defaults specified
     * in Rust, in the {@link xmtpv3} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link xmtpv3} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<FfiGroupUpdated>,
  });
})();

const FfiConverterTypeFfiGroupUpdated = (() => {
  type TypeName = FfiGroupUpdated;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        initiatedByInboxId: FfiConverterString.read(from),
        addedInboxes: FfiConverterArrayTypeFfiInbox.read(from),
        removedInboxes: FfiConverterArrayTypeFfiInbox.read(from),
        leftInboxes: FfiConverterArrayTypeFfiInbox.read(from),
        metadataFieldChanges:
          FfiConverterArrayTypeFfiMetadataFieldChange.read(from),
        addedAdminInboxes: FfiConverterArrayTypeFfiInbox.read(from),
        removedAdminInboxes: FfiConverterArrayTypeFfiInbox.read(from),
        addedSuperAdminInboxes: FfiConverterArrayTypeFfiInbox.read(from),
        removedSuperAdminInboxes: FfiConverterArrayTypeFfiInbox.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.initiatedByInboxId, into);
      FfiConverterArrayTypeFfiInbox.write(value.addedInboxes, into);
      FfiConverterArrayTypeFfiInbox.write(value.removedInboxes, into);
      FfiConverterArrayTypeFfiInbox.write(value.leftInboxes, into);
      FfiConverterArrayTypeFfiMetadataFieldChange.write(
        value.metadataFieldChanges,
        into
      );
      FfiConverterArrayTypeFfiInbox.write(value.addedAdminInboxes, into);
      FfiConverterArrayTypeFfiInbox.write(value.removedAdminInboxes, into);
      FfiConverterArrayTypeFfiInbox.write(value.addedSuperAdminInboxes, into);
      FfiConverterArrayTypeFfiInbox.write(value.removedSuperAdminInboxes, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.initiatedByInboxId) +
        FfiConverterArrayTypeFfiInbox.allocationSize(value.addedInboxes) +
        FfiConverterArrayTypeFfiInbox.allocationSize(value.removedInboxes) +
        FfiConverterArrayTypeFfiInbox.allocationSize(value.leftInboxes) +
        FfiConverterArrayTypeFfiMetadataFieldChange.allocationSize(
          value.metadataFieldChanges
        ) +
        FfiConverterArrayTypeFfiInbox.allocationSize(value.addedAdminInboxes) +
        FfiConverterArrayTypeFfiInbox.allocationSize(
          value.removedAdminInboxes
        ) +
        FfiConverterArrayTypeFfiInbox.allocationSize(
          value.addedSuperAdminInboxes
        ) +
        FfiConverterArrayTypeFfiInbox.allocationSize(
          value.removedSuperAdminInboxes
        )
      );
    }
  }
  return new FFIConverter();
})();

export type FfiHmacKey = {
  key: ArrayBuffer;
  epoch: /*i64*/ bigint;
};

/**
 * Generated factory for {@link FfiHmacKey} record objects.
 */
export const FfiHmacKey = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<FfiHmacKey, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link FfiHmacKey}, with defaults specified
     * in Rust, in the {@link xmtpv3} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link FfiHmacKey}, with defaults specified
     * in Rust, in the {@link xmtpv3} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link xmtpv3} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<FfiHmacKey>,
  });
})();

const FfiConverterTypeFfiHmacKey = (() => {
  type TypeName = FfiHmacKey;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        key: FfiConverterArrayBuffer.read(from),
        epoch: FfiConverterInt64.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterArrayBuffer.write(value.key, into);
      FfiConverterInt64.write(value.epoch, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterArrayBuffer.allocationSize(value.key) +
        FfiConverterInt64.allocationSize(value.epoch)
      );
    }
  }
  return new FFIConverter();
})();

export type FfiIdentifier = {
  identifier: string;
  identifierKind: FfiIdentifierKind;
};

/**
 * Generated factory for {@link FfiIdentifier} record objects.
 */
export const FfiIdentifier = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<FfiIdentifier, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link FfiIdentifier}, with defaults specified
     * in Rust, in the {@link xmtpv3} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link FfiIdentifier}, with defaults specified
     * in Rust, in the {@link xmtpv3} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link xmtpv3} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<FfiIdentifier>,
  });
})();

const FfiConverterTypeFfiIdentifier = (() => {
  type TypeName = FfiIdentifier;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        identifier: FfiConverterString.read(from),
        identifierKind: FfiConverterTypeFfiIdentifierKind.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.identifier, into);
      FfiConverterTypeFfiIdentifierKind.write(value.identifierKind, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.identifier) +
        FfiConverterTypeFfiIdentifierKind.allocationSize(value.identifierKind)
      );
    }
  }
  return new FFIConverter();
})();

export type FfiIdentityStats = {
  publishIdentityUpdate: /*u64*/ bigint;
  getIdentityUpdatesV2: /*u64*/ bigint;
  getInboxIds: /*u64*/ bigint;
  verifySmartContractWalletSignature: /*u64*/ bigint;
};

/**
 * Generated factory for {@link FfiIdentityStats} record objects.
 */
export const FfiIdentityStats = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<FfiIdentityStats, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link FfiIdentityStats}, with defaults specified
     * in Rust, in the {@link xmtpv3} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link FfiIdentityStats}, with defaults specified
     * in Rust, in the {@link xmtpv3} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link xmtpv3} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<FfiIdentityStats>,
  });
})();

const FfiConverterTypeFfiIdentityStats = (() => {
  type TypeName = FfiIdentityStats;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        publishIdentityUpdate: FfiConverterUInt64.read(from),
        getIdentityUpdatesV2: FfiConverterUInt64.read(from),
        getInboxIds: FfiConverterUInt64.read(from),
        verifySmartContractWalletSignature: FfiConverterUInt64.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterUInt64.write(value.publishIdentityUpdate, into);
      FfiConverterUInt64.write(value.getIdentityUpdatesV2, into);
      FfiConverterUInt64.write(value.getInboxIds, into);
      FfiConverterUInt64.write(value.verifySmartContractWalletSignature, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterUInt64.allocationSize(value.publishIdentityUpdate) +
        FfiConverterUInt64.allocationSize(value.getIdentityUpdatesV2) +
        FfiConverterUInt64.allocationSize(value.getInboxIds) +
        FfiConverterUInt64.allocationSize(
          value.verifySmartContractWalletSignature
        )
      );
    }
  }
  return new FFIConverter();
})();

export type FfiInbox = {
  inboxId: string;
};

/**
 * Generated factory for {@link FfiInbox} record objects.
 */
export const FfiInbox = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<FfiInbox, ReturnType<typeof defaults>>(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link FfiInbox}, with defaults specified
     * in Rust, in the {@link xmtpv3} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link FfiInbox}, with defaults specified
     * in Rust, in the {@link xmtpv3} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link xmtpv3} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<FfiInbox>,
  });
})();

const FfiConverterTypeFfiInbox = (() => {
  type TypeName = FfiInbox;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        inboxId: FfiConverterString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.inboxId, into);
    }
    allocationSize(value: TypeName): number {
      return FfiConverterString.allocationSize(value.inboxId);
    }
  }
  return new FFIConverter();
})();

export type FfiInboxState = {
  inboxId: string;
  recoveryIdentity: FfiIdentifier;
  installations: Array<FfiInstallation>;
  accountIdentities: Array<FfiIdentifier>;
  creationSignatureKind: FfiSignatureKind | undefined;
};

/**
 * Generated factory for {@link FfiInboxState} record objects.
 */
export const FfiInboxState = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<FfiInboxState, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link FfiInboxState}, with defaults specified
     * in Rust, in the {@link xmtpv3} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link FfiInboxState}, with defaults specified
     * in Rust, in the {@link xmtpv3} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link xmtpv3} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<FfiInboxState>,
  });
})();

const FfiConverterTypeFfiInboxState = (() => {
  type TypeName = FfiInboxState;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        inboxId: FfiConverterString.read(from),
        recoveryIdentity: FfiConverterTypeFfiIdentifier.read(from),
        installations: FfiConverterArrayTypeFfiInstallation.read(from),
        accountIdentities: FfiConverterArrayTypeFfiIdentifier.read(from),
        creationSignatureKind:
          FfiConverterOptionalTypeFfiSignatureKind.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.inboxId, into);
      FfiConverterTypeFfiIdentifier.write(value.recoveryIdentity, into);
      FfiConverterArrayTypeFfiInstallation.write(value.installations, into);
      FfiConverterArrayTypeFfiIdentifier.write(value.accountIdentities, into);
      FfiConverterOptionalTypeFfiSignatureKind.write(
        value.creationSignatureKind,
        into
      );
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.inboxId) +
        FfiConverterTypeFfiIdentifier.allocationSize(value.recoveryIdentity) +
        FfiConverterArrayTypeFfiInstallation.allocationSize(
          value.installations
        ) +
        FfiConverterArrayTypeFfiIdentifier.allocationSize(
          value.accountIdentities
        ) +
        FfiConverterOptionalTypeFfiSignatureKind.allocationSize(
          value.creationSignatureKind
        )
      );
    }
  }
  return new FFIConverter();
})();

export type FfiInstallation = {
  id: ArrayBuffer;
  clientTimestampNs: /*u64*/ bigint | undefined;
};

/**
 * Generated factory for {@link FfiInstallation} record objects.
 */
export const FfiInstallation = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<FfiInstallation, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link FfiInstallation}, with defaults specified
     * in Rust, in the {@link xmtpv3} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link FfiInstallation}, with defaults specified
     * in Rust, in the {@link xmtpv3} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link xmtpv3} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<FfiInstallation>,
  });
})();

const FfiConverterTypeFfiInstallation = (() => {
  type TypeName = FfiInstallation;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        id: FfiConverterArrayBuffer.read(from),
        clientTimestampNs: FfiConverterOptionalUInt64.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterArrayBuffer.write(value.id, into);
      FfiConverterOptionalUInt64.write(value.clientTimestampNs, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterArrayBuffer.allocationSize(value.id) +
        FfiConverterOptionalUInt64.allocationSize(value.clientTimestampNs)
      );
    }
  }
  return new FFIConverter();
})();

export type FfiIntent = {
  id: string;
  actionId: string;
  metadata: string | undefined;
};

/**
 * Generated factory for {@link FfiIntent} record objects.
 */
export const FfiIntent = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<FfiIntent, ReturnType<typeof defaults>>(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link FfiIntent}, with defaults specified
     * in Rust, in the {@link xmtpv3} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link FfiIntent}, with defaults specified
     * in Rust, in the {@link xmtpv3} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link xmtpv3} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<FfiIntent>,
  });
})();

const FfiConverterTypeFfiIntent = (() => {
  type TypeName = FfiIntent;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        id: FfiConverterString.read(from),
        actionId: FfiConverterString.read(from),
        metadata: FfiConverterOptionalString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.id, into);
      FfiConverterString.write(value.actionId, into);
      FfiConverterOptionalString.write(value.metadata, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.id) +
        FfiConverterString.allocationSize(value.actionId) +
        FfiConverterOptionalString.allocationSize(value.metadata)
      );
    }
  }
  return new FFIConverter();
})();

export type FfiKeyPackageStatus = {
  lifetime: FfiLifetime | undefined;
  validationError: string | undefined;
};

/**
 * Generated factory for {@link FfiKeyPackageStatus} record objects.
 */
export const FfiKeyPackageStatus = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<FfiKeyPackageStatus, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link FfiKeyPackageStatus}, with defaults specified
     * in Rust, in the {@link xmtpv3} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link FfiKeyPackageStatus}, with defaults specified
     * in Rust, in the {@link xmtpv3} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link xmtpv3} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<FfiKeyPackageStatus>,
  });
})();

const FfiConverterTypeFfiKeyPackageStatus = (() => {
  type TypeName = FfiKeyPackageStatus;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        lifetime: FfiConverterOptionalTypeFfiLifetime.read(from),
        validationError: FfiConverterOptionalString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterOptionalTypeFfiLifetime.write(value.lifetime, into);
      FfiConverterOptionalString.write(value.validationError, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterOptionalTypeFfiLifetime.allocationSize(value.lifetime) +
        FfiConverterOptionalString.allocationSize(value.validationError)
      );
    }
  }
  return new FFIConverter();
})();

export type FfiLifetime = {
  notBefore: /*u64*/ bigint;
  notAfter: /*u64*/ bigint;
};

/**
 * Generated factory for {@link FfiLifetime} record objects.
 */
export const FfiLifetime = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<FfiLifetime, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link FfiLifetime}, with defaults specified
     * in Rust, in the {@link xmtpv3} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link FfiLifetime}, with defaults specified
     * in Rust, in the {@link xmtpv3} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link xmtpv3} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<FfiLifetime>,
  });
})();

const FfiConverterTypeFfiLifetime = (() => {
  type TypeName = FfiLifetime;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        notBefore: FfiConverterUInt64.read(from),
        notAfter: FfiConverterUInt64.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterUInt64.write(value.notBefore, into);
      FfiConverterUInt64.write(value.notAfter, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterUInt64.allocationSize(value.notBefore) +
        FfiConverterUInt64.allocationSize(value.notAfter)
      );
    }
  }
  return new FFIConverter();
})();

export type FfiListConversationsOptions = {
  createdAfterNs: /*i64*/ bigint | undefined;
  createdBeforeNs: /*i64*/ bigint | undefined;
  lastActivityBeforeNs: /*i64*/ bigint | undefined;
  lastActivityAfterNs: /*i64*/ bigint | undefined;
  orderBy: FfiGroupQueryOrderBy | undefined;
  limit: /*i64*/ bigint | undefined;
  consentStates: Array<FfiConsentState> | undefined;
  includeDuplicateDms: boolean;
};

/**
 * Generated factory for {@link FfiListConversationsOptions} record objects.
 */
export const FfiListConversationsOptions = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      FfiListConversationsOptions,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link FfiListConversationsOptions}, with defaults specified
     * in Rust, in the {@link xmtpv3} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link FfiListConversationsOptions}, with defaults specified
     * in Rust, in the {@link xmtpv3} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link xmtpv3} crate.
     */
    defaults: () =>
      Object.freeze(defaults()) as Partial<FfiListConversationsOptions>,
  });
})();

const FfiConverterTypeFfiListConversationsOptions = (() => {
  type TypeName = FfiListConversationsOptions;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        createdAfterNs: FfiConverterOptionalInt64.read(from),
        createdBeforeNs: FfiConverterOptionalInt64.read(from),
        lastActivityBeforeNs: FfiConverterOptionalInt64.read(from),
        lastActivityAfterNs: FfiConverterOptionalInt64.read(from),
        orderBy: FfiConverterOptionalTypeFfiGroupQueryOrderBy.read(from),
        limit: FfiConverterOptionalInt64.read(from),
        consentStates: FfiConverterOptionalArrayTypeFfiConsentState.read(from),
        includeDuplicateDms: FfiConverterBool.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterOptionalInt64.write(value.createdAfterNs, into);
      FfiConverterOptionalInt64.write(value.createdBeforeNs, into);
      FfiConverterOptionalInt64.write(value.lastActivityBeforeNs, into);
      FfiConverterOptionalInt64.write(value.lastActivityAfterNs, into);
      FfiConverterOptionalTypeFfiGroupQueryOrderBy.write(value.orderBy, into);
      FfiConverterOptionalInt64.write(value.limit, into);
      FfiConverterOptionalArrayTypeFfiConsentState.write(
        value.consentStates,
        into
      );
      FfiConverterBool.write(value.includeDuplicateDms, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterOptionalInt64.allocationSize(value.createdAfterNs) +
        FfiConverterOptionalInt64.allocationSize(value.createdBeforeNs) +
        FfiConverterOptionalInt64.allocationSize(value.lastActivityBeforeNs) +
        FfiConverterOptionalInt64.allocationSize(value.lastActivityAfterNs) +
        FfiConverterOptionalTypeFfiGroupQueryOrderBy.allocationSize(
          value.orderBy
        ) +
        FfiConverterOptionalInt64.allocationSize(value.limit) +
        FfiConverterOptionalArrayTypeFfiConsentState.allocationSize(
          value.consentStates
        ) +
        FfiConverterBool.allocationSize(value.includeDuplicateDms)
      );
    }
  }
  return new FFIConverter();
})();

export type FfiListMessagesOptions = {
  sentBeforeNs: /*i64*/ bigint | undefined;
  sentAfterNs: /*i64*/ bigint | undefined;
  limit: /*i64*/ bigint | undefined;
  deliveryStatus: FfiDeliveryStatus | undefined;
  direction: FfiDirection | undefined;
  contentTypes: Array<FfiContentType> | undefined;
  excludeContentTypes: Array<FfiContentType> | undefined;
  excludeSenderInboxIds: Array<string> | undefined;
  sortBy: FfiSortBy | undefined;
  insertedAfterNs: /*i64*/ bigint | undefined;
  insertedBeforeNs: /*i64*/ bigint | undefined;
};

/**
 * Generated factory for {@link FfiListMessagesOptions} record objects.
 */
export const FfiListMessagesOptions = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      FfiListMessagesOptions,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link FfiListMessagesOptions}, with defaults specified
     * in Rust, in the {@link xmtpv3} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link FfiListMessagesOptions}, with defaults specified
     * in Rust, in the {@link xmtpv3} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link xmtpv3} crate.
     */
    defaults: () =>
      Object.freeze(defaults()) as Partial<FfiListMessagesOptions>,
  });
})();

const FfiConverterTypeFfiListMessagesOptions = (() => {
  type TypeName = FfiListMessagesOptions;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        sentBeforeNs: FfiConverterOptionalInt64.read(from),
        sentAfterNs: FfiConverterOptionalInt64.read(from),
        limit: FfiConverterOptionalInt64.read(from),
        deliveryStatus: FfiConverterOptionalTypeFfiDeliveryStatus.read(from),
        direction: FfiConverterOptionalTypeFfiDirection.read(from),
        contentTypes: FfiConverterOptionalArrayTypeFfiContentType.read(from),
        excludeContentTypes:
          FfiConverterOptionalArrayTypeFfiContentType.read(from),
        excludeSenderInboxIds: FfiConverterOptionalArrayString.read(from),
        sortBy: FfiConverterOptionalTypeFfiSortBy.read(from),
        insertedAfterNs: FfiConverterOptionalInt64.read(from),
        insertedBeforeNs: FfiConverterOptionalInt64.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterOptionalInt64.write(value.sentBeforeNs, into);
      FfiConverterOptionalInt64.write(value.sentAfterNs, into);
      FfiConverterOptionalInt64.write(value.limit, into);
      FfiConverterOptionalTypeFfiDeliveryStatus.write(
        value.deliveryStatus,
        into
      );
      FfiConverterOptionalTypeFfiDirection.write(value.direction, into);
      FfiConverterOptionalArrayTypeFfiContentType.write(
        value.contentTypes,
        into
      );
      FfiConverterOptionalArrayTypeFfiContentType.write(
        value.excludeContentTypes,
        into
      );
      FfiConverterOptionalArrayString.write(value.excludeSenderInboxIds, into);
      FfiConverterOptionalTypeFfiSortBy.write(value.sortBy, into);
      FfiConverterOptionalInt64.write(value.insertedAfterNs, into);
      FfiConverterOptionalInt64.write(value.insertedBeforeNs, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterOptionalInt64.allocationSize(value.sentBeforeNs) +
        FfiConverterOptionalInt64.allocationSize(value.sentAfterNs) +
        FfiConverterOptionalInt64.allocationSize(value.limit) +
        FfiConverterOptionalTypeFfiDeliveryStatus.allocationSize(
          value.deliveryStatus
        ) +
        FfiConverterOptionalTypeFfiDirection.allocationSize(value.direction) +
        FfiConverterOptionalArrayTypeFfiContentType.allocationSize(
          value.contentTypes
        ) +
        FfiConverterOptionalArrayTypeFfiContentType.allocationSize(
          value.excludeContentTypes
        ) +
        FfiConverterOptionalArrayString.allocationSize(
          value.excludeSenderInboxIds
        ) +
        FfiConverterOptionalTypeFfiSortBy.allocationSize(value.sortBy) +
        FfiConverterOptionalInt64.allocationSize(value.insertedAfterNs) +
        FfiConverterOptionalInt64.allocationSize(value.insertedBeforeNs)
      );
    }
  }
  return new FFIConverter();
})();

export type FfiMessage = {
  id: ArrayBuffer;
  sentAtNs: /*i64*/ bigint;
  conversationId: ArrayBuffer;
  senderInboxId: string;
  content: ArrayBuffer;
  kind: FfiConversationMessageKind;
  deliveryStatus: FfiDeliveryStatus;
  sequenceId: /*u64*/ bigint;
  originatorId: /*u32*/ number;
  insertedAtNs: /*i64*/ bigint;
};

/**
 * Generated factory for {@link FfiMessage} record objects.
 */
export const FfiMessage = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<FfiMessage, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link FfiMessage}, with defaults specified
     * in Rust, in the {@link xmtpv3} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link FfiMessage}, with defaults specified
     * in Rust, in the {@link xmtpv3} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link xmtpv3} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<FfiMessage>,
  });
})();

const FfiConverterTypeFfiMessage = (() => {
  type TypeName = FfiMessage;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        id: FfiConverterArrayBuffer.read(from),
        sentAtNs: FfiConverterInt64.read(from),
        conversationId: FfiConverterArrayBuffer.read(from),
        senderInboxId: FfiConverterString.read(from),
        content: FfiConverterArrayBuffer.read(from),
        kind: FfiConverterTypeFfiConversationMessageKind.read(from),
        deliveryStatus: FfiConverterTypeFfiDeliveryStatus.read(from),
        sequenceId: FfiConverterUInt64.read(from),
        originatorId: FfiConverterUInt32.read(from),
        insertedAtNs: FfiConverterInt64.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterArrayBuffer.write(value.id, into);
      FfiConverterInt64.write(value.sentAtNs, into);
      FfiConverterArrayBuffer.write(value.conversationId, into);
      FfiConverterString.write(value.senderInboxId, into);
      FfiConverterArrayBuffer.write(value.content, into);
      FfiConverterTypeFfiConversationMessageKind.write(value.kind, into);
      FfiConverterTypeFfiDeliveryStatus.write(value.deliveryStatus, into);
      FfiConverterUInt64.write(value.sequenceId, into);
      FfiConverterUInt32.write(value.originatorId, into);
      FfiConverterInt64.write(value.insertedAtNs, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterArrayBuffer.allocationSize(value.id) +
        FfiConverterInt64.allocationSize(value.sentAtNs) +
        FfiConverterArrayBuffer.allocationSize(value.conversationId) +
        FfiConverterString.allocationSize(value.senderInboxId) +
        FfiConverterArrayBuffer.allocationSize(value.content) +
        FfiConverterTypeFfiConversationMessageKind.allocationSize(value.kind) +
        FfiConverterTypeFfiDeliveryStatus.allocationSize(value.deliveryStatus) +
        FfiConverterUInt64.allocationSize(value.sequenceId) +
        FfiConverterUInt32.allocationSize(value.originatorId) +
        FfiConverterInt64.allocationSize(value.insertedAtNs)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * Settings for disappearing messages in a conversation.
 *
 * # Fields
 *
 * * `from_ns` - The timestamp (in nanoseconds) from when messages should be tracked for deletion.
 * * `in_ns` - The duration (in nanoseconds) after which tracked messages will be deleted.
 */
export type FfiMessageDisappearingSettings = {
  fromNs: /*i64*/ bigint;
  inNs: /*i64*/ bigint;
};

/**
 * Generated factory for {@link FfiMessageDisappearingSettings} record objects.
 */
export const FfiMessageDisappearingSettings = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      FfiMessageDisappearingSettings,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link FfiMessageDisappearingSettings}, with defaults specified
     * in Rust, in the {@link xmtpv3} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link FfiMessageDisappearingSettings}, with defaults specified
     * in Rust, in the {@link xmtpv3} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link xmtpv3} crate.
     */
    defaults: () =>
      Object.freeze(defaults()) as Partial<FfiMessageDisappearingSettings>,
  });
})();

const FfiConverterTypeFfiMessageDisappearingSettings = (() => {
  type TypeName = FfiMessageDisappearingSettings;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        fromNs: FfiConverterInt64.read(from),
        inNs: FfiConverterInt64.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterInt64.write(value.fromNs, into);
      FfiConverterInt64.write(value.inNs, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterInt64.allocationSize(value.fromNs) +
        FfiConverterInt64.allocationSize(value.inNs)
      );
    }
  }
  return new FFIConverter();
})();

export type FfiMessageWithReactions = {
  message: FfiMessage;
  reactions: Array<FfiMessage>;
};

/**
 * Generated factory for {@link FfiMessageWithReactions} record objects.
 */
export const FfiMessageWithReactions = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      FfiMessageWithReactions,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link FfiMessageWithReactions}, with defaults specified
     * in Rust, in the {@link xmtpv3} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link FfiMessageWithReactions}, with defaults specified
     * in Rust, in the {@link xmtpv3} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link xmtpv3} crate.
     */
    defaults: () =>
      Object.freeze(defaults()) as Partial<FfiMessageWithReactions>,
  });
})();

const FfiConverterTypeFfiMessageWithReactions = (() => {
  type TypeName = FfiMessageWithReactions;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        message: FfiConverterTypeFfiMessage.read(from),
        reactions: FfiConverterArrayTypeFfiMessage.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterTypeFfiMessage.write(value.message, into);
      FfiConverterArrayTypeFfiMessage.write(value.reactions, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterTypeFfiMessage.allocationSize(value.message) +
        FfiConverterArrayTypeFfiMessage.allocationSize(value.reactions)
      );
    }
  }
  return new FFIConverter();
})();

export type FfiMetadataFieldChange = {
  fieldName: string;
  oldValue: string | undefined;
  newValue: string | undefined;
};

/**
 * Generated factory for {@link FfiMetadataFieldChange} record objects.
 */
export const FfiMetadataFieldChange = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      FfiMetadataFieldChange,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link FfiMetadataFieldChange}, with defaults specified
     * in Rust, in the {@link xmtpv3} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link FfiMetadataFieldChange}, with defaults specified
     * in Rust, in the {@link xmtpv3} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link xmtpv3} crate.
     */
    defaults: () =>
      Object.freeze(defaults()) as Partial<FfiMetadataFieldChange>,
  });
})();

const FfiConverterTypeFfiMetadataFieldChange = (() => {
  type TypeName = FfiMetadataFieldChange;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        fieldName: FfiConverterString.read(from),
        oldValue: FfiConverterOptionalString.read(from),
        newValue: FfiConverterOptionalString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.fieldName, into);
      FfiConverterOptionalString.write(value.oldValue, into);
      FfiConverterOptionalString.write(value.newValue, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.fieldName) +
        FfiConverterOptionalString.allocationSize(value.oldValue) +
        FfiConverterOptionalString.allocationSize(value.newValue)
      );
    }
  }
  return new FFIConverter();
})();

export type FfiMultiRemoteAttachment = {
  attachments: Array<FfiRemoteAttachmentInfo>;
};

/**
 * Generated factory for {@link FfiMultiRemoteAttachment} record objects.
 */
export const FfiMultiRemoteAttachment = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      FfiMultiRemoteAttachment,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link FfiMultiRemoteAttachment}, with defaults specified
     * in Rust, in the {@link xmtpv3} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link FfiMultiRemoteAttachment}, with defaults specified
     * in Rust, in the {@link xmtpv3} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link xmtpv3} crate.
     */
    defaults: () =>
      Object.freeze(defaults()) as Partial<FfiMultiRemoteAttachment>,
  });
})();

const FfiConverterTypeFfiMultiRemoteAttachment = (() => {
  type TypeName = FfiMultiRemoteAttachment;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        attachments: FfiConverterArrayTypeFfiRemoteAttachmentInfo.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterArrayTypeFfiRemoteAttachmentInfo.write(
        value.attachments,
        into
      );
    }
    allocationSize(value: TypeName): number {
      return FfiConverterArrayTypeFfiRemoteAttachmentInfo.allocationSize(
        value.attachments
      );
    }
  }
  return new FFIConverter();
})();

export type FfiPasskeySignature = {
  publicKey: ArrayBuffer;
  signature: ArrayBuffer;
  authenticatorData: ArrayBuffer;
  clientDataJson: ArrayBuffer;
};

/**
 * Generated factory for {@link FfiPasskeySignature} record objects.
 */
export const FfiPasskeySignature = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<FfiPasskeySignature, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link FfiPasskeySignature}, with defaults specified
     * in Rust, in the {@link xmtpv3} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link FfiPasskeySignature}, with defaults specified
     * in Rust, in the {@link xmtpv3} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link xmtpv3} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<FfiPasskeySignature>,
  });
})();

const FfiConverterTypeFfiPasskeySignature = (() => {
  type TypeName = FfiPasskeySignature;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        publicKey: FfiConverterArrayBuffer.read(from),
        signature: FfiConverterArrayBuffer.read(from),
        authenticatorData: FfiConverterArrayBuffer.read(from),
        clientDataJson: FfiConverterArrayBuffer.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterArrayBuffer.write(value.publicKey, into);
      FfiConverterArrayBuffer.write(value.signature, into);
      FfiConverterArrayBuffer.write(value.authenticatorData, into);
      FfiConverterArrayBuffer.write(value.clientDataJson, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterArrayBuffer.allocationSize(value.publicKey) +
        FfiConverterArrayBuffer.allocationSize(value.signature) +
        FfiConverterArrayBuffer.allocationSize(value.authenticatorData) +
        FfiConverterArrayBuffer.allocationSize(value.clientDataJson)
      );
    }
  }
  return new FFIConverter();
})();

export type FfiPermissionPolicySet = {
  addMemberPolicy: FfiPermissionPolicy;
  removeMemberPolicy: FfiPermissionPolicy;
  addAdminPolicy: FfiPermissionPolicy;
  removeAdminPolicy: FfiPermissionPolicy;
  updateGroupNamePolicy: FfiPermissionPolicy;
  updateGroupDescriptionPolicy: FfiPermissionPolicy;
  updateGroupImageUrlSquarePolicy: FfiPermissionPolicy;
  updateMessageDisappearingPolicy: FfiPermissionPolicy;
};

/**
 * Generated factory for {@link FfiPermissionPolicySet} record objects.
 */
export const FfiPermissionPolicySet = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      FfiPermissionPolicySet,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link FfiPermissionPolicySet}, with defaults specified
     * in Rust, in the {@link xmtpv3} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link FfiPermissionPolicySet}, with defaults specified
     * in Rust, in the {@link xmtpv3} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link xmtpv3} crate.
     */
    defaults: () =>
      Object.freeze(defaults()) as Partial<FfiPermissionPolicySet>,
  });
})();

const FfiConverterTypeFfiPermissionPolicySet = (() => {
  type TypeName = FfiPermissionPolicySet;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        addMemberPolicy: FfiConverterTypeFfiPermissionPolicy.read(from),
        removeMemberPolicy: FfiConverterTypeFfiPermissionPolicy.read(from),
        addAdminPolicy: FfiConverterTypeFfiPermissionPolicy.read(from),
        removeAdminPolicy: FfiConverterTypeFfiPermissionPolicy.read(from),
        updateGroupNamePolicy: FfiConverterTypeFfiPermissionPolicy.read(from),
        updateGroupDescriptionPolicy:
          FfiConverterTypeFfiPermissionPolicy.read(from),
        updateGroupImageUrlSquarePolicy:
          FfiConverterTypeFfiPermissionPolicy.read(from),
        updateMessageDisappearingPolicy:
          FfiConverterTypeFfiPermissionPolicy.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterTypeFfiPermissionPolicy.write(value.addMemberPolicy, into);
      FfiConverterTypeFfiPermissionPolicy.write(value.removeMemberPolicy, into);
      FfiConverterTypeFfiPermissionPolicy.write(value.addAdminPolicy, into);
      FfiConverterTypeFfiPermissionPolicy.write(value.removeAdminPolicy, into);
      FfiConverterTypeFfiPermissionPolicy.write(
        value.updateGroupNamePolicy,
        into
      );
      FfiConverterTypeFfiPermissionPolicy.write(
        value.updateGroupDescriptionPolicy,
        into
      );
      FfiConverterTypeFfiPermissionPolicy.write(
        value.updateGroupImageUrlSquarePolicy,
        into
      );
      FfiConverterTypeFfiPermissionPolicy.write(
        value.updateMessageDisappearingPolicy,
        into
      );
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterTypeFfiPermissionPolicy.allocationSize(
          value.addMemberPolicy
        ) +
        FfiConverterTypeFfiPermissionPolicy.allocationSize(
          value.removeMemberPolicy
        ) +
        FfiConverterTypeFfiPermissionPolicy.allocationSize(
          value.addAdminPolicy
        ) +
        FfiConverterTypeFfiPermissionPolicy.allocationSize(
          value.removeAdminPolicy
        ) +
        FfiConverterTypeFfiPermissionPolicy.allocationSize(
          value.updateGroupNamePolicy
        ) +
        FfiConverterTypeFfiPermissionPolicy.allocationSize(
          value.updateGroupDescriptionPolicy
        ) +
        FfiConverterTypeFfiPermissionPolicy.allocationSize(
          value.updateGroupImageUrlSquarePolicy
        ) +
        FfiConverterTypeFfiPermissionPolicy.allocationSize(
          value.updateMessageDisappearingPolicy
        )
      );
    }
  }
  return new FFIConverter();
})();

export type FfiReactionPayload = {
  reference: string;
  referenceInboxId: string;
  action: FfiReactionAction;
  content: string;
  schema: FfiReactionSchema;
};

/**
 * Generated factory for {@link FfiReactionPayload} record objects.
 */
export const FfiReactionPayload = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<FfiReactionPayload, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link FfiReactionPayload}, with defaults specified
     * in Rust, in the {@link xmtpv3} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link FfiReactionPayload}, with defaults specified
     * in Rust, in the {@link xmtpv3} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link xmtpv3} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<FfiReactionPayload>,
  });
})();

const FfiConverterTypeFfiReactionPayload = (() => {
  type TypeName = FfiReactionPayload;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        reference: FfiConverterString.read(from),
        referenceInboxId: FfiConverterString.read(from),
        action: FfiConverterTypeFfiReactionAction.read(from),
        content: FfiConverterString.read(from),
        schema: FfiConverterTypeFfiReactionSchema.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.reference, into);
      FfiConverterString.write(value.referenceInboxId, into);
      FfiConverterTypeFfiReactionAction.write(value.action, into);
      FfiConverterString.write(value.content, into);
      FfiConverterTypeFfiReactionSchema.write(value.schema, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.reference) +
        FfiConverterString.allocationSize(value.referenceInboxId) +
        FfiConverterTypeFfiReactionAction.allocationSize(value.action) +
        FfiConverterString.allocationSize(value.content) +
        FfiConverterTypeFfiReactionSchema.allocationSize(value.schema)
      );
    }
  }
  return new FFIConverter();
})();

export type FfiReadReceipt = {};

/**
 * Generated factory for {@link FfiReadReceipt} record objects.
 */
export const FfiReadReceipt = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<FfiReadReceipt, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link FfiReadReceipt}, with defaults specified
     * in Rust, in the {@link xmtpv3} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link FfiReadReceipt}, with defaults specified
     * in Rust, in the {@link xmtpv3} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link xmtpv3} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<FfiReadReceipt>,
  });
})();

const FfiConverterTypeFfiReadReceipt = (() => {
  type TypeName = FfiReadReceipt;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {};
    }
    write(value: TypeName, into: RustBuffer): void {}
    allocationSize(value: TypeName): number {
      return 0;
    }
  }
  return new FFIConverter();
})();

export type FfiRemoteAttachment = {
  url: string;
  contentDigest: string;
  secret: ArrayBuffer;
  salt: ArrayBuffer;
  nonce: ArrayBuffer;
  scheme: string;
  contentLength: /*u32*/ number;
  filename: string | undefined;
};

/**
 * Generated factory for {@link FfiRemoteAttachment} record objects.
 */
export const FfiRemoteAttachment = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<FfiRemoteAttachment, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link FfiRemoteAttachment}, with defaults specified
     * in Rust, in the {@link xmtpv3} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link FfiRemoteAttachment}, with defaults specified
     * in Rust, in the {@link xmtpv3} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link xmtpv3} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<FfiRemoteAttachment>,
  });
})();

const FfiConverterTypeFfiRemoteAttachment = (() => {
  type TypeName = FfiRemoteAttachment;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        url: FfiConverterString.read(from),
        contentDigest: FfiConverterString.read(from),
        secret: FfiConverterArrayBuffer.read(from),
        salt: FfiConverterArrayBuffer.read(from),
        nonce: FfiConverterArrayBuffer.read(from),
        scheme: FfiConverterString.read(from),
        contentLength: FfiConverterUInt32.read(from),
        filename: FfiConverterOptionalString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.url, into);
      FfiConverterString.write(value.contentDigest, into);
      FfiConverterArrayBuffer.write(value.secret, into);
      FfiConverterArrayBuffer.write(value.salt, into);
      FfiConverterArrayBuffer.write(value.nonce, into);
      FfiConverterString.write(value.scheme, into);
      FfiConverterUInt32.write(value.contentLength, into);
      FfiConverterOptionalString.write(value.filename, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.url) +
        FfiConverterString.allocationSize(value.contentDigest) +
        FfiConverterArrayBuffer.allocationSize(value.secret) +
        FfiConverterArrayBuffer.allocationSize(value.salt) +
        FfiConverterArrayBuffer.allocationSize(value.nonce) +
        FfiConverterString.allocationSize(value.scheme) +
        FfiConverterUInt32.allocationSize(value.contentLength) +
        FfiConverterOptionalString.allocationSize(value.filename)
      );
    }
  }
  return new FFIConverter();
})();

export type FfiRemoteAttachmentInfo = {
  url: string;
  contentDigest: string;
  secret: ArrayBuffer;
  salt: ArrayBuffer;
  nonce: ArrayBuffer;
  scheme: string;
  contentLength: /*u32*/ number | undefined;
  filename: string | undefined;
};

/**
 * Generated factory for {@link FfiRemoteAttachmentInfo} record objects.
 */
export const FfiRemoteAttachmentInfo = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      FfiRemoteAttachmentInfo,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link FfiRemoteAttachmentInfo}, with defaults specified
     * in Rust, in the {@link xmtpv3} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link FfiRemoteAttachmentInfo}, with defaults specified
     * in Rust, in the {@link xmtpv3} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link xmtpv3} crate.
     */
    defaults: () =>
      Object.freeze(defaults()) as Partial<FfiRemoteAttachmentInfo>,
  });
})();

const FfiConverterTypeFfiRemoteAttachmentInfo = (() => {
  type TypeName = FfiRemoteAttachmentInfo;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        url: FfiConverterString.read(from),
        contentDigest: FfiConverterString.read(from),
        secret: FfiConverterArrayBuffer.read(from),
        salt: FfiConverterArrayBuffer.read(from),
        nonce: FfiConverterArrayBuffer.read(from),
        scheme: FfiConverterString.read(from),
        contentLength: FfiConverterOptionalUInt32.read(from),
        filename: FfiConverterOptionalString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.url, into);
      FfiConverterString.write(value.contentDigest, into);
      FfiConverterArrayBuffer.write(value.secret, into);
      FfiConverterArrayBuffer.write(value.salt, into);
      FfiConverterArrayBuffer.write(value.nonce, into);
      FfiConverterString.write(value.scheme, into);
      FfiConverterOptionalUInt32.write(value.contentLength, into);
      FfiConverterOptionalString.write(value.filename, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.url) +
        FfiConverterString.allocationSize(value.contentDigest) +
        FfiConverterArrayBuffer.allocationSize(value.secret) +
        FfiConverterArrayBuffer.allocationSize(value.salt) +
        FfiConverterArrayBuffer.allocationSize(value.nonce) +
        FfiConverterString.allocationSize(value.scheme) +
        FfiConverterOptionalUInt32.allocationSize(value.contentLength) +
        FfiConverterOptionalString.allocationSize(value.filename)
      );
    }
  }
  return new FFIConverter();
})();

export type FfiReply = {
  reference: string;
  referenceInboxId: string | undefined;
  content: FfiEncodedContent;
};

/**
 * Generated factory for {@link FfiReply} record objects.
 */
export const FfiReply = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<FfiReply, ReturnType<typeof defaults>>(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link FfiReply}, with defaults specified
     * in Rust, in the {@link xmtpv3} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link FfiReply}, with defaults specified
     * in Rust, in the {@link xmtpv3} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link xmtpv3} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<FfiReply>,
  });
})();

const FfiConverterTypeFfiReply = (() => {
  type TypeName = FfiReply;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        reference: FfiConverterString.read(from),
        referenceInboxId: FfiConverterOptionalString.read(from),
        content: FfiConverterTypeFfiEncodedContent.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.reference, into);
      FfiConverterOptionalString.write(value.referenceInboxId, into);
      FfiConverterTypeFfiEncodedContent.write(value.content, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.reference) +
        FfiConverterOptionalString.allocationSize(value.referenceInboxId) +
        FfiConverterTypeFfiEncodedContent.allocationSize(value.content)
      );
    }
  }
  return new FFIConverter();
})();

export type FfiSendMessageOpts = {
  shouldPush: boolean;
};

/**
 * Generated factory for {@link FfiSendMessageOpts} record objects.
 */
export const FfiSendMessageOpts = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<FfiSendMessageOpts, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link FfiSendMessageOpts}, with defaults specified
     * in Rust, in the {@link xmtpv3} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link FfiSendMessageOpts}, with defaults specified
     * in Rust, in the {@link xmtpv3} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link xmtpv3} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<FfiSendMessageOpts>,
  });
})();

const FfiConverterTypeFfiSendMessageOpts = (() => {
  type TypeName = FfiSendMessageOpts;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        shouldPush: FfiConverterBool.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterBool.write(value.shouldPush, into);
    }
    allocationSize(value: TypeName): number {
      return FfiConverterBool.allocationSize(value.shouldPush);
    }
  }
  return new FFIConverter();
})();

export type FfiTextContent = {
  content: string;
};

/**
 * Generated factory for {@link FfiTextContent} record objects.
 */
export const FfiTextContent = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<FfiTextContent, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link FfiTextContent}, with defaults specified
     * in Rust, in the {@link xmtpv3} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link FfiTextContent}, with defaults specified
     * in Rust, in the {@link xmtpv3} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link xmtpv3} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<FfiTextContent>,
  });
})();

const FfiConverterTypeFfiTextContent = (() => {
  type TypeName = FfiTextContent;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        content: FfiConverterString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.content, into);
    }
    allocationSize(value: TypeName): number {
      return FfiConverterString.allocationSize(value.content);
    }
  }
  return new FFIConverter();
})();

export type FfiTransactionMetadata = {
  transactionType: string;
  currency: string;
  amount: /*f64*/ number;
  decimals: /*u32*/ number;
  fromAddress: string;
  toAddress: string;
};

/**
 * Generated factory for {@link FfiTransactionMetadata} record objects.
 */
export const FfiTransactionMetadata = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      FfiTransactionMetadata,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link FfiTransactionMetadata}, with defaults specified
     * in Rust, in the {@link xmtpv3} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link FfiTransactionMetadata}, with defaults specified
     * in Rust, in the {@link xmtpv3} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link xmtpv3} crate.
     */
    defaults: () =>
      Object.freeze(defaults()) as Partial<FfiTransactionMetadata>,
  });
})();

const FfiConverterTypeFfiTransactionMetadata = (() => {
  type TypeName = FfiTransactionMetadata;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        transactionType: FfiConverterString.read(from),
        currency: FfiConverterString.read(from),
        amount: FfiConverterFloat64.read(from),
        decimals: FfiConverterUInt32.read(from),
        fromAddress: FfiConverterString.read(from),
        toAddress: FfiConverterString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.transactionType, into);
      FfiConverterString.write(value.currency, into);
      FfiConverterFloat64.write(value.amount, into);
      FfiConverterUInt32.write(value.decimals, into);
      FfiConverterString.write(value.fromAddress, into);
      FfiConverterString.write(value.toAddress, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.transactionType) +
        FfiConverterString.allocationSize(value.currency) +
        FfiConverterFloat64.allocationSize(value.amount) +
        FfiConverterUInt32.allocationSize(value.decimals) +
        FfiConverterString.allocationSize(value.fromAddress) +
        FfiConverterString.allocationSize(value.toAddress)
      );
    }
  }
  return new FFIConverter();
})();

export type FfiTransactionReference = {
  namespace: string | undefined;
  networkId: string;
  reference: string;
  metadata: FfiTransactionMetadata | undefined;
};

/**
 * Generated factory for {@link FfiTransactionReference} record objects.
 */
export const FfiTransactionReference = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      FfiTransactionReference,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link FfiTransactionReference}, with defaults specified
     * in Rust, in the {@link xmtpv3} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link FfiTransactionReference}, with defaults specified
     * in Rust, in the {@link xmtpv3} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link xmtpv3} crate.
     */
    defaults: () =>
      Object.freeze(defaults()) as Partial<FfiTransactionReference>,
  });
})();

const FfiConverterTypeFfiTransactionReference = (() => {
  type TypeName = FfiTransactionReference;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        namespace: FfiConverterOptionalString.read(from),
        networkId: FfiConverterString.read(from),
        reference: FfiConverterString.read(from),
        metadata: FfiConverterOptionalTypeFfiTransactionMetadata.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterOptionalString.write(value.namespace, into);
      FfiConverterString.write(value.networkId, into);
      FfiConverterString.write(value.reference, into);
      FfiConverterOptionalTypeFfiTransactionMetadata.write(
        value.metadata,
        into
      );
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterOptionalString.allocationSize(value.namespace) +
        FfiConverterString.allocationSize(value.networkId) +
        FfiConverterString.allocationSize(value.reference) +
        FfiConverterOptionalTypeFfiTransactionMetadata.allocationSize(
          value.metadata
        )
      );
    }
  }
  return new FFIConverter();
})();

export type FfiUpdateGroupMembershipResult = {
  addedMembers: Map<string, /*u64*/ bigint>;
  removedMembers: Array<string>;
  failedInstallations: Array<ArrayBuffer>;
};

/**
 * Generated factory for {@link FfiUpdateGroupMembershipResult} record objects.
 */
export const FfiUpdateGroupMembershipResult = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      FfiUpdateGroupMembershipResult,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link FfiUpdateGroupMembershipResult}, with defaults specified
     * in Rust, in the {@link xmtpv3} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link FfiUpdateGroupMembershipResult}, with defaults specified
     * in Rust, in the {@link xmtpv3} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link xmtpv3} crate.
     */
    defaults: () =>
      Object.freeze(defaults()) as Partial<FfiUpdateGroupMembershipResult>,
  });
})();

const FfiConverterTypeFfiUpdateGroupMembershipResult = (() => {
  type TypeName = FfiUpdateGroupMembershipResult;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        addedMembers: FfiConverterMapStringUInt64.read(from),
        removedMembers: FfiConverterArrayString.read(from),
        failedInstallations: FfiConverterArrayArrayBuffer.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterMapStringUInt64.write(value.addedMembers, into);
      FfiConverterArrayString.write(value.removedMembers, into);
      FfiConverterArrayArrayBuffer.write(value.failedInstallations, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterMapStringUInt64.allocationSize(value.addedMembers) +
        FfiConverterArrayString.allocationSize(value.removedMembers) +
        FfiConverterArrayArrayBuffer.allocationSize(value.failedInstallations)
      );
    }
  }
  return new FFIConverter();
})();

export type FfiWalletCall = {
  to: string | undefined;
  data: string | undefined;
  value: string | undefined;
  gas: string | undefined;
  metadata: FfiWalletCallMetadata | undefined;
};

/**
 * Generated factory for {@link FfiWalletCall} record objects.
 */
export const FfiWalletCall = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<FfiWalletCall, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link FfiWalletCall}, with defaults specified
     * in Rust, in the {@link xmtpv3} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link FfiWalletCall}, with defaults specified
     * in Rust, in the {@link xmtpv3} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link xmtpv3} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<FfiWalletCall>,
  });
})();

const FfiConverterTypeFfiWalletCall = (() => {
  type TypeName = FfiWalletCall;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        to: FfiConverterOptionalString.read(from),
        data: FfiConverterOptionalString.read(from),
        value: FfiConverterOptionalString.read(from),
        gas: FfiConverterOptionalString.read(from),
        metadata: FfiConverterOptionalTypeFfiWalletCallMetadata.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterOptionalString.write(value.to, into);
      FfiConverterOptionalString.write(value.data, into);
      FfiConverterOptionalString.write(value.value, into);
      FfiConverterOptionalString.write(value.gas, into);
      FfiConverterOptionalTypeFfiWalletCallMetadata.write(value.metadata, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterOptionalString.allocationSize(value.to) +
        FfiConverterOptionalString.allocationSize(value.data) +
        FfiConverterOptionalString.allocationSize(value.value) +
        FfiConverterOptionalString.allocationSize(value.gas) +
        FfiConverterOptionalTypeFfiWalletCallMetadata.allocationSize(
          value.metadata
        )
      );
    }
  }
  return new FFIConverter();
})();

export type FfiWalletCallMetadata = {
  description: string;
  transactionType: string;
  extra: Map<string, string>;
};

/**
 * Generated factory for {@link FfiWalletCallMetadata} record objects.
 */
export const FfiWalletCallMetadata = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      FfiWalletCallMetadata,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link FfiWalletCallMetadata}, with defaults specified
     * in Rust, in the {@link xmtpv3} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link FfiWalletCallMetadata}, with defaults specified
     * in Rust, in the {@link xmtpv3} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link xmtpv3} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<FfiWalletCallMetadata>,
  });
})();

const FfiConverterTypeFfiWalletCallMetadata = (() => {
  type TypeName = FfiWalletCallMetadata;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        description: FfiConverterString.read(from),
        transactionType: FfiConverterString.read(from),
        extra: FfiConverterMapStringString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.description, into);
      FfiConverterString.write(value.transactionType, into);
      FfiConverterMapStringString.write(value.extra, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.description) +
        FfiConverterString.allocationSize(value.transactionType) +
        FfiConverterMapStringString.allocationSize(value.extra)
      );
    }
  }
  return new FFIConverter();
})();

export type FfiWalletSendCalls = {
  version: string;
  chainId: string;
  from: string;
  calls: Array<FfiWalletCall>;
  capabilities: Map<string, string> | undefined;
};

/**
 * Generated factory for {@link FfiWalletSendCalls} record objects.
 */
export const FfiWalletSendCalls = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<FfiWalletSendCalls, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link FfiWalletSendCalls}, with defaults specified
     * in Rust, in the {@link xmtpv3} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link FfiWalletSendCalls}, with defaults specified
     * in Rust, in the {@link xmtpv3} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link xmtpv3} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<FfiWalletSendCalls>,
  });
})();

const FfiConverterTypeFfiWalletSendCalls = (() => {
  type TypeName = FfiWalletSendCalls;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        version: FfiConverterString.read(from),
        chainId: FfiConverterString.read(from),
        from: FfiConverterString.read(from),
        calls: FfiConverterArrayTypeFfiWalletCall.read(from),
        capabilities: FfiConverterOptionalMapStringString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.version, into);
      FfiConverterString.write(value.chainId, into);
      FfiConverterString.write(value.from, into);
      FfiConverterArrayTypeFfiWalletCall.write(value.calls, into);
      FfiConverterOptionalMapStringString.write(value.capabilities, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.version) +
        FfiConverterString.allocationSize(value.chainId) +
        FfiConverterString.allocationSize(value.from) +
        FfiConverterArrayTypeFfiWalletCall.allocationSize(value.calls) +
        FfiConverterOptionalMapStringString.allocationSize(value.capabilities)
      );
    }
  }
  return new FFIConverter();
})();

const stringConverter = {
  stringToBytes: (s: string) =>
    uniffiCaller.rustCall((status) =>
      nativeModule().ubrn_uniffi_internal_fn_func_ffi__string_to_arraybuffer(
        s,
        status
      )
    ),
  bytesToString: (ab: UniffiByteArray) =>
    uniffiCaller.rustCall((status) =>
      nativeModule().ubrn_uniffi_internal_fn_func_ffi__arraybuffer_to_string(
        ab,
        status
      )
    ),
  stringByteLength: (s: string) =>
    uniffiCaller.rustCall((status) =>
      nativeModule().ubrn_uniffi_internal_fn_func_ffi__string_to_byte_length(
        s,
        status
      )
    ),
};
const FfiConverterString = uniffiCreateFfiConverterString(stringConverter);

export enum FfiActionStyle {
  Primary,
  Secondary,
  Danger,
}

const FfiConverterTypeFfiActionStyle = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = FfiActionStyle;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return FfiActionStyle.Primary;
        case 2:
          return FfiActionStyle.Secondary;
        case 3:
          return FfiActionStyle.Danger;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case FfiActionStyle.Primary:
          return ordinalConverter.write(1, into);
        case FfiActionStyle.Secondary:
          return ordinalConverter.write(2, into);
        case FfiActionStyle.Danger:
          return ordinalConverter.write(3, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

export enum FfiBackupElementSelection {
  Messages,
  Consent,
}

const FfiConverterTypeFfiBackupElementSelection = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = FfiBackupElementSelection;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return FfiBackupElementSelection.Messages;
        case 2:
          return FfiBackupElementSelection.Consent;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case FfiBackupElementSelection.Messages:
          return ordinalConverter.write(1, into);
        case FfiBackupElementSelection.Consent:
          return ordinalConverter.write(2, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

export enum FfiClientMode {
  Default,
  Notification,
}

const FfiConverterTypeFfiClientMode = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = FfiClientMode;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return FfiClientMode.Default;
        case 2:
          return FfiClientMode.Notification;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case FfiClientMode.Default:
          return ordinalConverter.write(1, into);
        case FfiClientMode.Notification:
          return ordinalConverter.write(2, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

export enum FfiConsentEntityType {
  ConversationId,
  InboxId,
}

const FfiConverterTypeFfiConsentEntityType = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = FfiConsentEntityType;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return FfiConsentEntityType.ConversationId;
        case 2:
          return FfiConsentEntityType.InboxId;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case FfiConsentEntityType.ConversationId:
          return ordinalConverter.write(1, into);
        case FfiConsentEntityType.InboxId:
          return ordinalConverter.write(2, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

export enum FfiConsentState {
  Unknown,
  Allowed,
  Denied,
}

const FfiConverterTypeFfiConsentState = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = FfiConsentState;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return FfiConsentState.Unknown;
        case 2:
          return FfiConsentState.Allowed;
        case 3:
          return FfiConsentState.Denied;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case FfiConsentState.Unknown:
          return ordinalConverter.write(1, into);
        case FfiConsentState.Allowed:
          return ordinalConverter.write(2, into);
        case FfiConsentState.Denied:
          return ordinalConverter.write(3, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

export enum FfiContentType {
  Unknown,
  Text,
  GroupMembershipChange,
  GroupUpdated,
  Reaction,
  ReadReceipt,
  Reply,
  Attachment,
  RemoteAttachment,
  TransactionReference,
}

const FfiConverterTypeFfiContentType = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = FfiContentType;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return FfiContentType.Unknown;
        case 2:
          return FfiContentType.Text;
        case 3:
          return FfiContentType.GroupMembershipChange;
        case 4:
          return FfiContentType.GroupUpdated;
        case 5:
          return FfiContentType.Reaction;
        case 6:
          return FfiContentType.ReadReceipt;
        case 7:
          return FfiContentType.Reply;
        case 8:
          return FfiContentType.Attachment;
        case 9:
          return FfiContentType.RemoteAttachment;
        case 10:
          return FfiContentType.TransactionReference;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case FfiContentType.Unknown:
          return ordinalConverter.write(1, into);
        case FfiContentType.Text:
          return ordinalConverter.write(2, into);
        case FfiContentType.GroupMembershipChange:
          return ordinalConverter.write(3, into);
        case FfiContentType.GroupUpdated:
          return ordinalConverter.write(4, into);
        case FfiContentType.Reaction:
          return ordinalConverter.write(5, into);
        case FfiContentType.ReadReceipt:
          return ordinalConverter.write(6, into);
        case FfiContentType.Reply:
          return ordinalConverter.write(7, into);
        case FfiContentType.Attachment:
          return ordinalConverter.write(8, into);
        case FfiContentType.RemoteAttachment:
          return ordinalConverter.write(9, into);
        case FfiContentType.TransactionReference:
          return ordinalConverter.write(10, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

export enum FfiConversationMessageKind {
  Application,
  MembershipChange,
}

const FfiConverterTypeFfiConversationMessageKind = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = FfiConversationMessageKind;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return FfiConversationMessageKind.Application;
        case 2:
          return FfiConversationMessageKind.MembershipChange;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case FfiConversationMessageKind.Application:
          return ordinalConverter.write(1, into);
        case FfiConversationMessageKind.MembershipChange:
          return ordinalConverter.write(2, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

export enum FfiConversationType {
  Group,
  Dm,
  Sync,
  Oneshot,
}

const FfiConverterTypeFfiConversationType = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = FfiConversationType;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return FfiConversationType.Group;
        case 2:
          return FfiConversationType.Dm;
        case 3:
          return FfiConversationType.Sync;
        case 4:
          return FfiConversationType.Oneshot;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case FfiConversationType.Group:
          return ordinalConverter.write(1, into);
        case FfiConversationType.Dm:
          return ordinalConverter.write(2, into);
        case FfiConversationType.Sync:
          return ordinalConverter.write(3, into);
        case FfiConversationType.Oneshot:
          return ordinalConverter.write(4, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

// Error type: FfiCryptoError

// Enum: FfiCryptoError
export enum FfiCryptoError_Tags {
  InvalidLength = 'InvalidLength',
  InvalidKey = 'InvalidKey',
  SignFailure = 'SignFailure',
  DecompressFailure = 'DecompressFailure',
}
export const FfiCryptoError = (() => {
  type InvalidLength__interface = {
    tag: FfiCryptoError_Tags.InvalidLength;
  };

  class InvalidLength_ extends UniffiError implements InvalidLength__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'FfiCryptoError';
    readonly tag = FfiCryptoError_Tags.InvalidLength;
    constructor() {
      super('FfiCryptoError', 'InvalidLength');
    }

    static new(): InvalidLength_ {
      return new InvalidLength_();
    }

    static instanceOf(obj: any): obj is InvalidLength_ {
      return obj.tag === FfiCryptoError_Tags.InvalidLength;
    }

    static hasInner(obj: any): obj is InvalidLength_ {
      return false;
    }
  }

  type InvalidKey__interface = {
    tag: FfiCryptoError_Tags.InvalidKey;
  };

  class InvalidKey_ extends UniffiError implements InvalidKey__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'FfiCryptoError';
    readonly tag = FfiCryptoError_Tags.InvalidKey;
    constructor() {
      super('FfiCryptoError', 'InvalidKey');
    }

    static new(): InvalidKey_ {
      return new InvalidKey_();
    }

    static instanceOf(obj: any): obj is InvalidKey_ {
      return obj.tag === FfiCryptoError_Tags.InvalidKey;
    }

    static hasInner(obj: any): obj is InvalidKey_ {
      return false;
    }
  }

  type SignFailure__interface = {
    tag: FfiCryptoError_Tags.SignFailure;
  };

  class SignFailure_ extends UniffiError implements SignFailure__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'FfiCryptoError';
    readonly tag = FfiCryptoError_Tags.SignFailure;
    constructor() {
      super('FfiCryptoError', 'SignFailure');
    }

    static new(): SignFailure_ {
      return new SignFailure_();
    }

    static instanceOf(obj: any): obj is SignFailure_ {
      return obj.tag === FfiCryptoError_Tags.SignFailure;
    }

    static hasInner(obj: any): obj is SignFailure_ {
      return false;
    }
  }

  type DecompressFailure__interface = {
    tag: FfiCryptoError_Tags.DecompressFailure;
  };

  class DecompressFailure_
    extends UniffiError
    implements DecompressFailure__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'FfiCryptoError';
    readonly tag = FfiCryptoError_Tags.DecompressFailure;
    constructor() {
      super('FfiCryptoError', 'DecompressFailure');
    }

    static new(): DecompressFailure_ {
      return new DecompressFailure_();
    }

    static instanceOf(obj: any): obj is DecompressFailure_ {
      return obj.tag === FfiCryptoError_Tags.DecompressFailure;
    }

    static hasInner(obj: any): obj is DecompressFailure_ {
      return false;
    }
  }

  function instanceOf(obj: any): obj is FfiCryptoError {
    return obj[uniffiTypeNameSymbol] === 'FfiCryptoError';
  }

  return Object.freeze({
    instanceOf,
    InvalidLength: InvalidLength_,
    InvalidKey: InvalidKey_,
    SignFailure: SignFailure_,
    DecompressFailure: DecompressFailure_,
  });
})();

export type FfiCryptoError = InstanceType<
  (typeof FfiCryptoError)[keyof Omit<typeof FfiCryptoError, 'instanceOf'>]
>;

// FfiConverter for enum FfiCryptoError
const FfiConverterTypeFfiCryptoError = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = FfiCryptoError;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new FfiCryptoError.InvalidLength();
        case 2:
          return new FfiCryptoError.InvalidKey();
        case 3:
          return new FfiCryptoError.SignFailure();
        case 4:
          return new FfiCryptoError.DecompressFailure();
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case FfiCryptoError_Tags.InvalidLength: {
          ordinalConverter.write(1, into);
          return;
        }
        case FfiCryptoError_Tags.InvalidKey: {
          ordinalConverter.write(2, into);
          return;
        }
        case FfiCryptoError_Tags.SignFailure: {
          ordinalConverter.write(3, into);
          return;
        }
        case FfiCryptoError_Tags.DecompressFailure: {
          ordinalConverter.write(4, into);
          return;
        }
        default:
          // Throwing from here means that FfiCryptoError_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case FfiCryptoError_Tags.InvalidLength: {
          return ordinalConverter.allocationSize(1);
        }
        case FfiCryptoError_Tags.InvalidKey: {
          return ordinalConverter.allocationSize(2);
        }
        case FfiCryptoError_Tags.SignFailure: {
          return ordinalConverter.allocationSize(3);
        }
        case FfiCryptoError_Tags.DecompressFailure: {
          return ordinalConverter.allocationSize(4);
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Enum: FfiDecodedMessageBody
export enum FfiDecodedMessageBody_Tags {
  Text = 'Text',
  Reaction = 'Reaction',
  Attachment = 'Attachment',
  RemoteAttachment = 'RemoteAttachment',
  MultiRemoteAttachment = 'MultiRemoteAttachment',
  TransactionReference = 'TransactionReference',
  GroupUpdated = 'GroupUpdated',
  ReadReceipt = 'ReadReceipt',
  WalletSendCalls = 'WalletSendCalls',
  Intent = 'Intent',
  Actions = 'Actions',
  Custom = 'Custom',
}
export const FfiDecodedMessageBody = (() => {
  type Text__interface = {
    tag: FfiDecodedMessageBody_Tags.Text;
    inner: Readonly<[FfiTextContent]>;
  };

  class Text_ extends UniffiEnum implements Text__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'FfiDecodedMessageBody';
    readonly tag = FfiDecodedMessageBody_Tags.Text;
    readonly inner: Readonly<[FfiTextContent]>;
    constructor(v0: FfiTextContent) {
      super('FfiDecodedMessageBody', 'Text');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: FfiTextContent): Text_ {
      return new Text_(v0);
    }

    static instanceOf(obj: any): obj is Text_ {
      return obj.tag === FfiDecodedMessageBody_Tags.Text;
    }
  }

  type Reaction__interface = {
    tag: FfiDecodedMessageBody_Tags.Reaction;
    inner: Readonly<[FfiReactionPayload]>;
  };

  class Reaction_ extends UniffiEnum implements Reaction__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'FfiDecodedMessageBody';
    readonly tag = FfiDecodedMessageBody_Tags.Reaction;
    readonly inner: Readonly<[FfiReactionPayload]>;
    constructor(v0: FfiReactionPayload) {
      super('FfiDecodedMessageBody', 'Reaction');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: FfiReactionPayload): Reaction_ {
      return new Reaction_(v0);
    }

    static instanceOf(obj: any): obj is Reaction_ {
      return obj.tag === FfiDecodedMessageBody_Tags.Reaction;
    }
  }

  type Attachment__interface = {
    tag: FfiDecodedMessageBody_Tags.Attachment;
    inner: Readonly<[FfiAttachment]>;
  };

  class Attachment_ extends UniffiEnum implements Attachment__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'FfiDecodedMessageBody';
    readonly tag = FfiDecodedMessageBody_Tags.Attachment;
    readonly inner: Readonly<[FfiAttachment]>;
    constructor(v0: FfiAttachment) {
      super('FfiDecodedMessageBody', 'Attachment');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: FfiAttachment): Attachment_ {
      return new Attachment_(v0);
    }

    static instanceOf(obj: any): obj is Attachment_ {
      return obj.tag === FfiDecodedMessageBody_Tags.Attachment;
    }
  }

  type RemoteAttachment__interface = {
    tag: FfiDecodedMessageBody_Tags.RemoteAttachment;
    inner: Readonly<[FfiRemoteAttachment]>;
  };

  class RemoteAttachment_
    extends UniffiEnum
    implements RemoteAttachment__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'FfiDecodedMessageBody';
    readonly tag = FfiDecodedMessageBody_Tags.RemoteAttachment;
    readonly inner: Readonly<[FfiRemoteAttachment]>;
    constructor(v0: FfiRemoteAttachment) {
      super('FfiDecodedMessageBody', 'RemoteAttachment');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: FfiRemoteAttachment): RemoteAttachment_ {
      return new RemoteAttachment_(v0);
    }

    static instanceOf(obj: any): obj is RemoteAttachment_ {
      return obj.tag === FfiDecodedMessageBody_Tags.RemoteAttachment;
    }
  }

  type MultiRemoteAttachment__interface = {
    tag: FfiDecodedMessageBody_Tags.MultiRemoteAttachment;
    inner: Readonly<[FfiMultiRemoteAttachment]>;
  };

  class MultiRemoteAttachment_
    extends UniffiEnum
    implements MultiRemoteAttachment__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'FfiDecodedMessageBody';
    readonly tag = FfiDecodedMessageBody_Tags.MultiRemoteAttachment;
    readonly inner: Readonly<[FfiMultiRemoteAttachment]>;
    constructor(v0: FfiMultiRemoteAttachment) {
      super('FfiDecodedMessageBody', 'MultiRemoteAttachment');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: FfiMultiRemoteAttachment): MultiRemoteAttachment_ {
      return new MultiRemoteAttachment_(v0);
    }

    static instanceOf(obj: any): obj is MultiRemoteAttachment_ {
      return obj.tag === FfiDecodedMessageBody_Tags.MultiRemoteAttachment;
    }
  }

  type TransactionReference__interface = {
    tag: FfiDecodedMessageBody_Tags.TransactionReference;
    inner: Readonly<[FfiTransactionReference]>;
  };

  class TransactionReference_
    extends UniffiEnum
    implements TransactionReference__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'FfiDecodedMessageBody';
    readonly tag = FfiDecodedMessageBody_Tags.TransactionReference;
    readonly inner: Readonly<[FfiTransactionReference]>;
    constructor(v0: FfiTransactionReference) {
      super('FfiDecodedMessageBody', 'TransactionReference');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: FfiTransactionReference): TransactionReference_ {
      return new TransactionReference_(v0);
    }

    static instanceOf(obj: any): obj is TransactionReference_ {
      return obj.tag === FfiDecodedMessageBody_Tags.TransactionReference;
    }
  }

  type GroupUpdated__interface = {
    tag: FfiDecodedMessageBody_Tags.GroupUpdated;
    inner: Readonly<[FfiGroupUpdated]>;
  };

  class GroupUpdated_ extends UniffiEnum implements GroupUpdated__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'FfiDecodedMessageBody';
    readonly tag = FfiDecodedMessageBody_Tags.GroupUpdated;
    readonly inner: Readonly<[FfiGroupUpdated]>;
    constructor(v0: FfiGroupUpdated) {
      super('FfiDecodedMessageBody', 'GroupUpdated');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: FfiGroupUpdated): GroupUpdated_ {
      return new GroupUpdated_(v0);
    }

    static instanceOf(obj: any): obj is GroupUpdated_ {
      return obj.tag === FfiDecodedMessageBody_Tags.GroupUpdated;
    }
  }

  type ReadReceipt__interface = {
    tag: FfiDecodedMessageBody_Tags.ReadReceipt;
    inner: Readonly<[FfiReadReceipt]>;
  };

  class ReadReceipt_ extends UniffiEnum implements ReadReceipt__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'FfiDecodedMessageBody';
    readonly tag = FfiDecodedMessageBody_Tags.ReadReceipt;
    readonly inner: Readonly<[FfiReadReceipt]>;
    constructor(v0: FfiReadReceipt) {
      super('FfiDecodedMessageBody', 'ReadReceipt');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: FfiReadReceipt): ReadReceipt_ {
      return new ReadReceipt_(v0);
    }

    static instanceOf(obj: any): obj is ReadReceipt_ {
      return obj.tag === FfiDecodedMessageBody_Tags.ReadReceipt;
    }
  }

  type WalletSendCalls__interface = {
    tag: FfiDecodedMessageBody_Tags.WalletSendCalls;
    inner: Readonly<[FfiWalletSendCalls]>;
  };

  class WalletSendCalls_
    extends UniffiEnum
    implements WalletSendCalls__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'FfiDecodedMessageBody';
    readonly tag = FfiDecodedMessageBody_Tags.WalletSendCalls;
    readonly inner: Readonly<[FfiWalletSendCalls]>;
    constructor(v0: FfiWalletSendCalls) {
      super('FfiDecodedMessageBody', 'WalletSendCalls');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: FfiWalletSendCalls): WalletSendCalls_ {
      return new WalletSendCalls_(v0);
    }

    static instanceOf(obj: any): obj is WalletSendCalls_ {
      return obj.tag === FfiDecodedMessageBody_Tags.WalletSendCalls;
    }
  }

  type Intent__interface = {
    tag: FfiDecodedMessageBody_Tags.Intent;
    inner: Readonly<[FfiIntent]>;
  };

  class Intent_ extends UniffiEnum implements Intent__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'FfiDecodedMessageBody';
    readonly tag = FfiDecodedMessageBody_Tags.Intent;
    readonly inner: Readonly<[FfiIntent]>;
    constructor(v0: FfiIntent) {
      super('FfiDecodedMessageBody', 'Intent');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: FfiIntent): Intent_ {
      return new Intent_(v0);
    }

    static instanceOf(obj: any): obj is Intent_ {
      return obj.tag === FfiDecodedMessageBody_Tags.Intent;
    }
  }

  type Actions__interface = {
    tag: FfiDecodedMessageBody_Tags.Actions;
    inner: Readonly<[FfiActions]>;
  };

  class Actions_ extends UniffiEnum implements Actions__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'FfiDecodedMessageBody';
    readonly tag = FfiDecodedMessageBody_Tags.Actions;
    readonly inner: Readonly<[FfiActions]>;
    constructor(v0: FfiActions) {
      super('FfiDecodedMessageBody', 'Actions');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: FfiActions): Actions_ {
      return new Actions_(v0);
    }

    static instanceOf(obj: any): obj is Actions_ {
      return obj.tag === FfiDecodedMessageBody_Tags.Actions;
    }
  }

  type Custom__interface = {
    tag: FfiDecodedMessageBody_Tags.Custom;
    inner: Readonly<[FfiEncodedContent]>;
  };

  class Custom_ extends UniffiEnum implements Custom__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'FfiDecodedMessageBody';
    readonly tag = FfiDecodedMessageBody_Tags.Custom;
    readonly inner: Readonly<[FfiEncodedContent]>;
    constructor(v0: FfiEncodedContent) {
      super('FfiDecodedMessageBody', 'Custom');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: FfiEncodedContent): Custom_ {
      return new Custom_(v0);
    }

    static instanceOf(obj: any): obj is Custom_ {
      return obj.tag === FfiDecodedMessageBody_Tags.Custom;
    }
  }

  function instanceOf(obj: any): obj is FfiDecodedMessageBody {
    return obj[uniffiTypeNameSymbol] === 'FfiDecodedMessageBody';
  }

  return Object.freeze({
    instanceOf,
    Text: Text_,
    Reaction: Reaction_,
    Attachment: Attachment_,
    RemoteAttachment: RemoteAttachment_,
    MultiRemoteAttachment: MultiRemoteAttachment_,
    TransactionReference: TransactionReference_,
    GroupUpdated: GroupUpdated_,
    ReadReceipt: ReadReceipt_,
    WalletSendCalls: WalletSendCalls_,
    Intent: Intent_,
    Actions: Actions_,
    Custom: Custom_,
  });
})();

export type FfiDecodedMessageBody = InstanceType<
  (typeof FfiDecodedMessageBody)[keyof Omit<
    typeof FfiDecodedMessageBody,
    'instanceOf'
  >]
>;

// FfiConverter for enum FfiDecodedMessageBody
const FfiConverterTypeFfiDecodedMessageBody = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = FfiDecodedMessageBody;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new FfiDecodedMessageBody.Text(
            FfiConverterTypeFfiTextContent.read(from)
          );
        case 2:
          return new FfiDecodedMessageBody.Reaction(
            FfiConverterTypeFfiReactionPayload.read(from)
          );
        case 3:
          return new FfiDecodedMessageBody.Attachment(
            FfiConverterTypeFfiAttachment.read(from)
          );
        case 4:
          return new FfiDecodedMessageBody.RemoteAttachment(
            FfiConverterTypeFfiRemoteAttachment.read(from)
          );
        case 5:
          return new FfiDecodedMessageBody.MultiRemoteAttachment(
            FfiConverterTypeFfiMultiRemoteAttachment.read(from)
          );
        case 6:
          return new FfiDecodedMessageBody.TransactionReference(
            FfiConverterTypeFfiTransactionReference.read(from)
          );
        case 7:
          return new FfiDecodedMessageBody.GroupUpdated(
            FfiConverterTypeFfiGroupUpdated.read(from)
          );
        case 8:
          return new FfiDecodedMessageBody.ReadReceipt(
            FfiConverterTypeFfiReadReceipt.read(from)
          );
        case 9:
          return new FfiDecodedMessageBody.WalletSendCalls(
            FfiConverterTypeFfiWalletSendCalls.read(from)
          );
        case 10:
          return new FfiDecodedMessageBody.Intent(
            FfiConverterTypeFfiIntent.read(from)
          );
        case 11:
          return new FfiDecodedMessageBody.Actions(
            FfiConverterTypeFfiActions.read(from)
          );
        case 12:
          return new FfiDecodedMessageBody.Custom(
            FfiConverterTypeFfiEncodedContent.read(from)
          );
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case FfiDecodedMessageBody_Tags.Text: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterTypeFfiTextContent.write(inner[0], into);
          return;
        }
        case FfiDecodedMessageBody_Tags.Reaction: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterTypeFfiReactionPayload.write(inner[0], into);
          return;
        }
        case FfiDecodedMessageBody_Tags.Attachment: {
          ordinalConverter.write(3, into);
          const inner = value.inner;
          FfiConverterTypeFfiAttachment.write(inner[0], into);
          return;
        }
        case FfiDecodedMessageBody_Tags.RemoteAttachment: {
          ordinalConverter.write(4, into);
          const inner = value.inner;
          FfiConverterTypeFfiRemoteAttachment.write(inner[0], into);
          return;
        }
        case FfiDecodedMessageBody_Tags.MultiRemoteAttachment: {
          ordinalConverter.write(5, into);
          const inner = value.inner;
          FfiConverterTypeFfiMultiRemoteAttachment.write(inner[0], into);
          return;
        }
        case FfiDecodedMessageBody_Tags.TransactionReference: {
          ordinalConverter.write(6, into);
          const inner = value.inner;
          FfiConverterTypeFfiTransactionReference.write(inner[0], into);
          return;
        }
        case FfiDecodedMessageBody_Tags.GroupUpdated: {
          ordinalConverter.write(7, into);
          const inner = value.inner;
          FfiConverterTypeFfiGroupUpdated.write(inner[0], into);
          return;
        }
        case FfiDecodedMessageBody_Tags.ReadReceipt: {
          ordinalConverter.write(8, into);
          const inner = value.inner;
          FfiConverterTypeFfiReadReceipt.write(inner[0], into);
          return;
        }
        case FfiDecodedMessageBody_Tags.WalletSendCalls: {
          ordinalConverter.write(9, into);
          const inner = value.inner;
          FfiConverterTypeFfiWalletSendCalls.write(inner[0], into);
          return;
        }
        case FfiDecodedMessageBody_Tags.Intent: {
          ordinalConverter.write(10, into);
          const inner = value.inner;
          FfiConverterTypeFfiIntent.write(inner[0], into);
          return;
        }
        case FfiDecodedMessageBody_Tags.Actions: {
          ordinalConverter.write(11, into);
          const inner = value.inner;
          FfiConverterTypeFfiActions.write(inner[0], into);
          return;
        }
        case FfiDecodedMessageBody_Tags.Custom: {
          ordinalConverter.write(12, into);
          const inner = value.inner;
          FfiConverterTypeFfiEncodedContent.write(inner[0], into);
          return;
        }
        default:
          // Throwing from here means that FfiDecodedMessageBody_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case FfiDecodedMessageBody_Tags.Text: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterTypeFfiTextContent.allocationSize(inner[0]);
          return size;
        }
        case FfiDecodedMessageBody_Tags.Reaction: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterTypeFfiReactionPayload.allocationSize(inner[0]);
          return size;
        }
        case FfiDecodedMessageBody_Tags.Attachment: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(3);
          size += FfiConverterTypeFfiAttachment.allocationSize(inner[0]);
          return size;
        }
        case FfiDecodedMessageBody_Tags.RemoteAttachment: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(4);
          size += FfiConverterTypeFfiRemoteAttachment.allocationSize(inner[0]);
          return size;
        }
        case FfiDecodedMessageBody_Tags.MultiRemoteAttachment: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(5);
          size += FfiConverterTypeFfiMultiRemoteAttachment.allocationSize(
            inner[0]
          );
          return size;
        }
        case FfiDecodedMessageBody_Tags.TransactionReference: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(6);
          size += FfiConverterTypeFfiTransactionReference.allocationSize(
            inner[0]
          );
          return size;
        }
        case FfiDecodedMessageBody_Tags.GroupUpdated: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(7);
          size += FfiConverterTypeFfiGroupUpdated.allocationSize(inner[0]);
          return size;
        }
        case FfiDecodedMessageBody_Tags.ReadReceipt: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(8);
          size += FfiConverterTypeFfiReadReceipt.allocationSize(inner[0]);
          return size;
        }
        case FfiDecodedMessageBody_Tags.WalletSendCalls: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(9);
          size += FfiConverterTypeFfiWalletSendCalls.allocationSize(inner[0]);
          return size;
        }
        case FfiDecodedMessageBody_Tags.Intent: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(10);
          size += FfiConverterTypeFfiIntent.allocationSize(inner[0]);
          return size;
        }
        case FfiDecodedMessageBody_Tags.Actions: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(11);
          size += FfiConverterTypeFfiActions.allocationSize(inner[0]);
          return size;
        }
        case FfiDecodedMessageBody_Tags.Custom: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(12);
          size += FfiConverterTypeFfiEncodedContent.allocationSize(inner[0]);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Enum: FfiDecodedMessageContent
export enum FfiDecodedMessageContent_Tags {
  Text = 'Text',
  Reply = 'Reply',
  Reaction = 'Reaction',
  Attachment = 'Attachment',
  RemoteAttachment = 'RemoteAttachment',
  MultiRemoteAttachment = 'MultiRemoteAttachment',
  TransactionReference = 'TransactionReference',
  GroupUpdated = 'GroupUpdated',
  ReadReceipt = 'ReadReceipt',
  WalletSendCalls = 'WalletSendCalls',
  Intent = 'Intent',
  Actions = 'Actions',
  Custom = 'Custom',
}
export const FfiDecodedMessageContent = (() => {
  type Text__interface = {
    tag: FfiDecodedMessageContent_Tags.Text;
    inner: Readonly<[FfiTextContent]>;
  };

  class Text_ extends UniffiEnum implements Text__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'FfiDecodedMessageContent';
    readonly tag = FfiDecodedMessageContent_Tags.Text;
    readonly inner: Readonly<[FfiTextContent]>;
    constructor(v0: FfiTextContent) {
      super('FfiDecodedMessageContent', 'Text');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: FfiTextContent): Text_ {
      return new Text_(v0);
    }

    static instanceOf(obj: any): obj is Text_ {
      return obj.tag === FfiDecodedMessageContent_Tags.Text;
    }
  }

  type Reply__interface = {
    tag: FfiDecodedMessageContent_Tags.Reply;
    inner: Readonly<[FfiEnrichedReply]>;
  };

  class Reply_ extends UniffiEnum implements Reply__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'FfiDecodedMessageContent';
    readonly tag = FfiDecodedMessageContent_Tags.Reply;
    readonly inner: Readonly<[FfiEnrichedReply]>;
    constructor(v0: FfiEnrichedReply) {
      super('FfiDecodedMessageContent', 'Reply');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: FfiEnrichedReply): Reply_ {
      return new Reply_(v0);
    }

    static instanceOf(obj: any): obj is Reply_ {
      return obj.tag === FfiDecodedMessageContent_Tags.Reply;
    }
  }

  type Reaction__interface = {
    tag: FfiDecodedMessageContent_Tags.Reaction;
    inner: Readonly<[FfiReactionPayload]>;
  };

  class Reaction_ extends UniffiEnum implements Reaction__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'FfiDecodedMessageContent';
    readonly tag = FfiDecodedMessageContent_Tags.Reaction;
    readonly inner: Readonly<[FfiReactionPayload]>;
    constructor(v0: FfiReactionPayload) {
      super('FfiDecodedMessageContent', 'Reaction');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: FfiReactionPayload): Reaction_ {
      return new Reaction_(v0);
    }

    static instanceOf(obj: any): obj is Reaction_ {
      return obj.tag === FfiDecodedMessageContent_Tags.Reaction;
    }
  }

  type Attachment__interface = {
    tag: FfiDecodedMessageContent_Tags.Attachment;
    inner: Readonly<[FfiAttachment]>;
  };

  class Attachment_ extends UniffiEnum implements Attachment__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'FfiDecodedMessageContent';
    readonly tag = FfiDecodedMessageContent_Tags.Attachment;
    readonly inner: Readonly<[FfiAttachment]>;
    constructor(v0: FfiAttachment) {
      super('FfiDecodedMessageContent', 'Attachment');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: FfiAttachment): Attachment_ {
      return new Attachment_(v0);
    }

    static instanceOf(obj: any): obj is Attachment_ {
      return obj.tag === FfiDecodedMessageContent_Tags.Attachment;
    }
  }

  type RemoteAttachment__interface = {
    tag: FfiDecodedMessageContent_Tags.RemoteAttachment;
    inner: Readonly<[FfiRemoteAttachment]>;
  };

  class RemoteAttachment_
    extends UniffiEnum
    implements RemoteAttachment__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'FfiDecodedMessageContent';
    readonly tag = FfiDecodedMessageContent_Tags.RemoteAttachment;
    readonly inner: Readonly<[FfiRemoteAttachment]>;
    constructor(v0: FfiRemoteAttachment) {
      super('FfiDecodedMessageContent', 'RemoteAttachment');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: FfiRemoteAttachment): RemoteAttachment_ {
      return new RemoteAttachment_(v0);
    }

    static instanceOf(obj: any): obj is RemoteAttachment_ {
      return obj.tag === FfiDecodedMessageContent_Tags.RemoteAttachment;
    }
  }

  type MultiRemoteAttachment__interface = {
    tag: FfiDecodedMessageContent_Tags.MultiRemoteAttachment;
    inner: Readonly<[FfiMultiRemoteAttachment]>;
  };

  class MultiRemoteAttachment_
    extends UniffiEnum
    implements MultiRemoteAttachment__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'FfiDecodedMessageContent';
    readonly tag = FfiDecodedMessageContent_Tags.MultiRemoteAttachment;
    readonly inner: Readonly<[FfiMultiRemoteAttachment]>;
    constructor(v0: FfiMultiRemoteAttachment) {
      super('FfiDecodedMessageContent', 'MultiRemoteAttachment');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: FfiMultiRemoteAttachment): MultiRemoteAttachment_ {
      return new MultiRemoteAttachment_(v0);
    }

    static instanceOf(obj: any): obj is MultiRemoteAttachment_ {
      return obj.tag === FfiDecodedMessageContent_Tags.MultiRemoteAttachment;
    }
  }

  type TransactionReference__interface = {
    tag: FfiDecodedMessageContent_Tags.TransactionReference;
    inner: Readonly<[FfiTransactionReference]>;
  };

  class TransactionReference_
    extends UniffiEnum
    implements TransactionReference__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'FfiDecodedMessageContent';
    readonly tag = FfiDecodedMessageContent_Tags.TransactionReference;
    readonly inner: Readonly<[FfiTransactionReference]>;
    constructor(v0: FfiTransactionReference) {
      super('FfiDecodedMessageContent', 'TransactionReference');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: FfiTransactionReference): TransactionReference_ {
      return new TransactionReference_(v0);
    }

    static instanceOf(obj: any): obj is TransactionReference_ {
      return obj.tag === FfiDecodedMessageContent_Tags.TransactionReference;
    }
  }

  type GroupUpdated__interface = {
    tag: FfiDecodedMessageContent_Tags.GroupUpdated;
    inner: Readonly<[FfiGroupUpdated]>;
  };

  class GroupUpdated_ extends UniffiEnum implements GroupUpdated__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'FfiDecodedMessageContent';
    readonly tag = FfiDecodedMessageContent_Tags.GroupUpdated;
    readonly inner: Readonly<[FfiGroupUpdated]>;
    constructor(v0: FfiGroupUpdated) {
      super('FfiDecodedMessageContent', 'GroupUpdated');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: FfiGroupUpdated): GroupUpdated_ {
      return new GroupUpdated_(v0);
    }

    static instanceOf(obj: any): obj is GroupUpdated_ {
      return obj.tag === FfiDecodedMessageContent_Tags.GroupUpdated;
    }
  }

  type ReadReceipt__interface = {
    tag: FfiDecodedMessageContent_Tags.ReadReceipt;
    inner: Readonly<[FfiReadReceipt]>;
  };

  class ReadReceipt_ extends UniffiEnum implements ReadReceipt__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'FfiDecodedMessageContent';
    readonly tag = FfiDecodedMessageContent_Tags.ReadReceipt;
    readonly inner: Readonly<[FfiReadReceipt]>;
    constructor(v0: FfiReadReceipt) {
      super('FfiDecodedMessageContent', 'ReadReceipt');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: FfiReadReceipt): ReadReceipt_ {
      return new ReadReceipt_(v0);
    }

    static instanceOf(obj: any): obj is ReadReceipt_ {
      return obj.tag === FfiDecodedMessageContent_Tags.ReadReceipt;
    }
  }

  type WalletSendCalls__interface = {
    tag: FfiDecodedMessageContent_Tags.WalletSendCalls;
    inner: Readonly<[FfiWalletSendCalls]>;
  };

  class WalletSendCalls_
    extends UniffiEnum
    implements WalletSendCalls__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'FfiDecodedMessageContent';
    readonly tag = FfiDecodedMessageContent_Tags.WalletSendCalls;
    readonly inner: Readonly<[FfiWalletSendCalls]>;
    constructor(v0: FfiWalletSendCalls) {
      super('FfiDecodedMessageContent', 'WalletSendCalls');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: FfiWalletSendCalls): WalletSendCalls_ {
      return new WalletSendCalls_(v0);
    }

    static instanceOf(obj: any): obj is WalletSendCalls_ {
      return obj.tag === FfiDecodedMessageContent_Tags.WalletSendCalls;
    }
  }

  type Intent__interface = {
    tag: FfiDecodedMessageContent_Tags.Intent;
    inner: Readonly<[FfiIntent | undefined]>;
  };

  class Intent_ extends UniffiEnum implements Intent__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'FfiDecodedMessageContent';
    readonly tag = FfiDecodedMessageContent_Tags.Intent;
    readonly inner: Readonly<[FfiIntent | undefined]>;
    constructor(v0: FfiIntent | undefined) {
      super('FfiDecodedMessageContent', 'Intent');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: FfiIntent | undefined): Intent_ {
      return new Intent_(v0);
    }

    static instanceOf(obj: any): obj is Intent_ {
      return obj.tag === FfiDecodedMessageContent_Tags.Intent;
    }
  }

  type Actions__interface = {
    tag: FfiDecodedMessageContent_Tags.Actions;
    inner: Readonly<[FfiActions | undefined]>;
  };

  class Actions_ extends UniffiEnum implements Actions__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'FfiDecodedMessageContent';
    readonly tag = FfiDecodedMessageContent_Tags.Actions;
    readonly inner: Readonly<[FfiActions | undefined]>;
    constructor(v0: FfiActions | undefined) {
      super('FfiDecodedMessageContent', 'Actions');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: FfiActions | undefined): Actions_ {
      return new Actions_(v0);
    }

    static instanceOf(obj: any): obj is Actions_ {
      return obj.tag === FfiDecodedMessageContent_Tags.Actions;
    }
  }

  type Custom__interface = {
    tag: FfiDecodedMessageContent_Tags.Custom;
    inner: Readonly<[FfiEncodedContent]>;
  };

  class Custom_ extends UniffiEnum implements Custom__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'FfiDecodedMessageContent';
    readonly tag = FfiDecodedMessageContent_Tags.Custom;
    readonly inner: Readonly<[FfiEncodedContent]>;
    constructor(v0: FfiEncodedContent) {
      super('FfiDecodedMessageContent', 'Custom');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: FfiEncodedContent): Custom_ {
      return new Custom_(v0);
    }

    static instanceOf(obj: any): obj is Custom_ {
      return obj.tag === FfiDecodedMessageContent_Tags.Custom;
    }
  }

  function instanceOf(obj: any): obj is FfiDecodedMessageContent {
    return obj[uniffiTypeNameSymbol] === 'FfiDecodedMessageContent';
  }

  return Object.freeze({
    instanceOf,
    Text: Text_,
    Reply: Reply_,
    Reaction: Reaction_,
    Attachment: Attachment_,
    RemoteAttachment: RemoteAttachment_,
    MultiRemoteAttachment: MultiRemoteAttachment_,
    TransactionReference: TransactionReference_,
    GroupUpdated: GroupUpdated_,
    ReadReceipt: ReadReceipt_,
    WalletSendCalls: WalletSendCalls_,
    Intent: Intent_,
    Actions: Actions_,
    Custom: Custom_,
  });
})();

export type FfiDecodedMessageContent = InstanceType<
  (typeof FfiDecodedMessageContent)[keyof Omit<
    typeof FfiDecodedMessageContent,
    'instanceOf'
  >]
>;

// FfiConverter for enum FfiDecodedMessageContent
const FfiConverterTypeFfiDecodedMessageContent = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = FfiDecodedMessageContent;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new FfiDecodedMessageContent.Text(
            FfiConverterTypeFfiTextContent.read(from)
          );
        case 2:
          return new FfiDecodedMessageContent.Reply(
            FfiConverterTypeFfiEnrichedReply.read(from)
          );
        case 3:
          return new FfiDecodedMessageContent.Reaction(
            FfiConverterTypeFfiReactionPayload.read(from)
          );
        case 4:
          return new FfiDecodedMessageContent.Attachment(
            FfiConverterTypeFfiAttachment.read(from)
          );
        case 5:
          return new FfiDecodedMessageContent.RemoteAttachment(
            FfiConverterTypeFfiRemoteAttachment.read(from)
          );
        case 6:
          return new FfiDecodedMessageContent.MultiRemoteAttachment(
            FfiConverterTypeFfiMultiRemoteAttachment.read(from)
          );
        case 7:
          return new FfiDecodedMessageContent.TransactionReference(
            FfiConverterTypeFfiTransactionReference.read(from)
          );
        case 8:
          return new FfiDecodedMessageContent.GroupUpdated(
            FfiConverterTypeFfiGroupUpdated.read(from)
          );
        case 9:
          return new FfiDecodedMessageContent.ReadReceipt(
            FfiConverterTypeFfiReadReceipt.read(from)
          );
        case 10:
          return new FfiDecodedMessageContent.WalletSendCalls(
            FfiConverterTypeFfiWalletSendCalls.read(from)
          );
        case 11:
          return new FfiDecodedMessageContent.Intent(
            FfiConverterOptionalTypeFfiIntent.read(from)
          );
        case 12:
          return new FfiDecodedMessageContent.Actions(
            FfiConverterOptionalTypeFfiActions.read(from)
          );
        case 13:
          return new FfiDecodedMessageContent.Custom(
            FfiConverterTypeFfiEncodedContent.read(from)
          );
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case FfiDecodedMessageContent_Tags.Text: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterTypeFfiTextContent.write(inner[0], into);
          return;
        }
        case FfiDecodedMessageContent_Tags.Reply: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterTypeFfiEnrichedReply.write(inner[0], into);
          return;
        }
        case FfiDecodedMessageContent_Tags.Reaction: {
          ordinalConverter.write(3, into);
          const inner = value.inner;
          FfiConverterTypeFfiReactionPayload.write(inner[0], into);
          return;
        }
        case FfiDecodedMessageContent_Tags.Attachment: {
          ordinalConverter.write(4, into);
          const inner = value.inner;
          FfiConverterTypeFfiAttachment.write(inner[0], into);
          return;
        }
        case FfiDecodedMessageContent_Tags.RemoteAttachment: {
          ordinalConverter.write(5, into);
          const inner = value.inner;
          FfiConverterTypeFfiRemoteAttachment.write(inner[0], into);
          return;
        }
        case FfiDecodedMessageContent_Tags.MultiRemoteAttachment: {
          ordinalConverter.write(6, into);
          const inner = value.inner;
          FfiConverterTypeFfiMultiRemoteAttachment.write(inner[0], into);
          return;
        }
        case FfiDecodedMessageContent_Tags.TransactionReference: {
          ordinalConverter.write(7, into);
          const inner = value.inner;
          FfiConverterTypeFfiTransactionReference.write(inner[0], into);
          return;
        }
        case FfiDecodedMessageContent_Tags.GroupUpdated: {
          ordinalConverter.write(8, into);
          const inner = value.inner;
          FfiConverterTypeFfiGroupUpdated.write(inner[0], into);
          return;
        }
        case FfiDecodedMessageContent_Tags.ReadReceipt: {
          ordinalConverter.write(9, into);
          const inner = value.inner;
          FfiConverterTypeFfiReadReceipt.write(inner[0], into);
          return;
        }
        case FfiDecodedMessageContent_Tags.WalletSendCalls: {
          ordinalConverter.write(10, into);
          const inner = value.inner;
          FfiConverterTypeFfiWalletSendCalls.write(inner[0], into);
          return;
        }
        case FfiDecodedMessageContent_Tags.Intent: {
          ordinalConverter.write(11, into);
          const inner = value.inner;
          FfiConverterOptionalTypeFfiIntent.write(inner[0], into);
          return;
        }
        case FfiDecodedMessageContent_Tags.Actions: {
          ordinalConverter.write(12, into);
          const inner = value.inner;
          FfiConverterOptionalTypeFfiActions.write(inner[0], into);
          return;
        }
        case FfiDecodedMessageContent_Tags.Custom: {
          ordinalConverter.write(13, into);
          const inner = value.inner;
          FfiConverterTypeFfiEncodedContent.write(inner[0], into);
          return;
        }
        default:
          // Throwing from here means that FfiDecodedMessageContent_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case FfiDecodedMessageContent_Tags.Text: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterTypeFfiTextContent.allocationSize(inner[0]);
          return size;
        }
        case FfiDecodedMessageContent_Tags.Reply: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterTypeFfiEnrichedReply.allocationSize(inner[0]);
          return size;
        }
        case FfiDecodedMessageContent_Tags.Reaction: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(3);
          size += FfiConverterTypeFfiReactionPayload.allocationSize(inner[0]);
          return size;
        }
        case FfiDecodedMessageContent_Tags.Attachment: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(4);
          size += FfiConverterTypeFfiAttachment.allocationSize(inner[0]);
          return size;
        }
        case FfiDecodedMessageContent_Tags.RemoteAttachment: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(5);
          size += FfiConverterTypeFfiRemoteAttachment.allocationSize(inner[0]);
          return size;
        }
        case FfiDecodedMessageContent_Tags.MultiRemoteAttachment: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(6);
          size += FfiConverterTypeFfiMultiRemoteAttachment.allocationSize(
            inner[0]
          );
          return size;
        }
        case FfiDecodedMessageContent_Tags.TransactionReference: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(7);
          size += FfiConverterTypeFfiTransactionReference.allocationSize(
            inner[0]
          );
          return size;
        }
        case FfiDecodedMessageContent_Tags.GroupUpdated: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(8);
          size += FfiConverterTypeFfiGroupUpdated.allocationSize(inner[0]);
          return size;
        }
        case FfiDecodedMessageContent_Tags.ReadReceipt: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(9);
          size += FfiConverterTypeFfiReadReceipt.allocationSize(inner[0]);
          return size;
        }
        case FfiDecodedMessageContent_Tags.WalletSendCalls: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(10);
          size += FfiConverterTypeFfiWalletSendCalls.allocationSize(inner[0]);
          return size;
        }
        case FfiDecodedMessageContent_Tags.Intent: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(11);
          size += FfiConverterOptionalTypeFfiIntent.allocationSize(inner[0]);
          return size;
        }
        case FfiDecodedMessageContent_Tags.Actions: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(12);
          size += FfiConverterOptionalTypeFfiActions.allocationSize(inner[0]);
          return size;
        }
        case FfiDecodedMessageContent_Tags.Custom: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(13);
          size += FfiConverterTypeFfiEncodedContent.allocationSize(inner[0]);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

export enum FfiDeliveryStatus {
  Unpublished,
  Published,
  Failed,
}

const FfiConverterTypeFfiDeliveryStatus = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = FfiDeliveryStatus;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return FfiDeliveryStatus.Unpublished;
        case 2:
          return FfiDeliveryStatus.Published;
        case 3:
          return FfiDeliveryStatus.Failed;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case FfiDeliveryStatus.Unpublished:
          return ordinalConverter.write(1, into);
        case FfiDeliveryStatus.Published:
          return ordinalConverter.write(2, into);
        case FfiDeliveryStatus.Failed:
          return ordinalConverter.write(3, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

export enum FfiDirection {
  Ascending,
  Descending,
}

const FfiConverterTypeFfiDirection = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = FfiDirection;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return FfiDirection.Ascending;
        case 2:
          return FfiDirection.Descending;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case FfiDirection.Ascending:
          return ordinalConverter.write(1, into);
        case FfiDirection.Descending:
          return ordinalConverter.write(2, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

export enum FfiForkRecoveryPolicy {
  None,
  AllowlistedGroups,
  All,
}

const FfiConverterTypeFfiForkRecoveryPolicy = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = FfiForkRecoveryPolicy;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return FfiForkRecoveryPolicy.None;
        case 2:
          return FfiForkRecoveryPolicy.AllowlistedGroups;
        case 3:
          return FfiForkRecoveryPolicy.All;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case FfiForkRecoveryPolicy.None:
          return ordinalConverter.write(1, into);
        case FfiForkRecoveryPolicy.AllowlistedGroups:
          return ordinalConverter.write(2, into);
        case FfiForkRecoveryPolicy.All:
          return ordinalConverter.write(3, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

export enum FfiGroupMembershipState {
  Allowed,
  Rejected,
  Pending,
  Restored,
  PendingRemove,
}

const FfiConverterTypeFfiGroupMembershipState = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = FfiGroupMembershipState;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return FfiGroupMembershipState.Allowed;
        case 2:
          return FfiGroupMembershipState.Rejected;
        case 3:
          return FfiGroupMembershipState.Pending;
        case 4:
          return FfiGroupMembershipState.Restored;
        case 5:
          return FfiGroupMembershipState.PendingRemove;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case FfiGroupMembershipState.Allowed:
          return ordinalConverter.write(1, into);
        case FfiGroupMembershipState.Rejected:
          return ordinalConverter.write(2, into);
        case FfiGroupMembershipState.Pending:
          return ordinalConverter.write(3, into);
        case FfiGroupMembershipState.Restored:
          return ordinalConverter.write(4, into);
        case FfiGroupMembershipState.PendingRemove:
          return ordinalConverter.write(5, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

export enum FfiGroupMessageKind {
  Application,
  MembershipChange,
}

const FfiConverterTypeFfiGroupMessageKind = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = FfiGroupMessageKind;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return FfiGroupMessageKind.Application;
        case 2:
          return FfiGroupMessageKind.MembershipChange;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case FfiGroupMessageKind.Application:
          return ordinalConverter.write(1, into);
        case FfiGroupMessageKind.MembershipChange:
          return ordinalConverter.write(2, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

export enum FfiGroupPermissionsOptions {
  Default,
  AdminOnly,
  CustomPolicy,
}

const FfiConverterTypeFfiGroupPermissionsOptions = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = FfiGroupPermissionsOptions;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return FfiGroupPermissionsOptions.Default;
        case 2:
          return FfiGroupPermissionsOptions.AdminOnly;
        case 3:
          return FfiGroupPermissionsOptions.CustomPolicy;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case FfiGroupPermissionsOptions.Default:
          return ordinalConverter.write(1, into);
        case FfiGroupPermissionsOptions.AdminOnly:
          return ordinalConverter.write(2, into);
        case FfiGroupPermissionsOptions.CustomPolicy:
          return ordinalConverter.write(3, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

export enum FfiGroupQueryOrderBy {
  CreatedAt,
  LastActivity,
}

const FfiConverterTypeFfiGroupQueryOrderBy = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = FfiGroupQueryOrderBy;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return FfiGroupQueryOrderBy.CreatedAt;
        case 2:
          return FfiGroupQueryOrderBy.LastActivity;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case FfiGroupQueryOrderBy.CreatedAt:
          return ordinalConverter.write(1, into);
        case FfiGroupQueryOrderBy.LastActivity:
          return ordinalConverter.write(2, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

export enum FfiIdentifierKind {
  Ethereum,
  Passkey,
}

const FfiConverterTypeFfiIdentifierKind = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = FfiIdentifierKind;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return FfiIdentifierKind.Ethereum;
        case 2:
          return FfiIdentifierKind.Passkey;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case FfiIdentifierKind.Ethereum:
          return ordinalConverter.write(1, into);
        case FfiIdentifierKind.Passkey:
          return ordinalConverter.write(2, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

/**
 * Enum representing log levels
 */
export enum FfiLogLevel {
  /**
   * Error level logs only
   */
  Error,
  /**
   * Warning level and above
   */
  Warn,
  /**
   * Info level and above
   */
  Info,
  /**
   * Debug level and above
   */
  Debug,
  /**
   * Trace level and all logs
   */
  Trace,
}

const FfiConverterTypeFfiLogLevel = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = FfiLogLevel;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return FfiLogLevel.Error;
        case 2:
          return FfiLogLevel.Warn;
        case 3:
          return FfiLogLevel.Info;
        case 4:
          return FfiLogLevel.Debug;
        case 5:
          return FfiLogLevel.Trace;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case FfiLogLevel.Error:
          return ordinalConverter.write(1, into);
        case FfiLogLevel.Warn:
          return ordinalConverter.write(2, into);
        case FfiLogLevel.Info:
          return ordinalConverter.write(3, into);
        case FfiLogLevel.Debug:
          return ordinalConverter.write(4, into);
        case FfiLogLevel.Trace:
          return ordinalConverter.write(5, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

/**
 * Enum representing log file rotation options
 */
export enum FfiLogRotation {
  /**
   * Rotate log files every minute
   */
  Minutely,
  /**
   * Rotate log files every hour
   */
  Hourly,
  /**
   * Rotate log files every day
   */
  Daily,
  /**
   * Never rotate log files
   */
  Never,
}

const FfiConverterTypeFfiLogRotation = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = FfiLogRotation;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return FfiLogRotation.Minutely;
        case 2:
          return FfiLogRotation.Hourly;
        case 3:
          return FfiLogRotation.Daily;
        case 4:
          return FfiLogRotation.Never;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case FfiLogRotation.Minutely:
          return ordinalConverter.write(1, into);
        case FfiLogRotation.Hourly:
          return ordinalConverter.write(2, into);
        case FfiLogRotation.Daily:
          return ordinalConverter.write(3, into);
        case FfiLogRotation.Never:
          return ordinalConverter.write(4, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

export enum FfiMetadataField {
  GroupName,
  Description,
  ImageUrlSquare,
}

const FfiConverterTypeFfiMetadataField = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = FfiMetadataField;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return FfiMetadataField.GroupName;
        case 2:
          return FfiMetadataField.Description;
        case 3:
          return FfiMetadataField.ImageUrlSquare;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case FfiMetadataField.GroupName:
          return ordinalConverter.write(1, into);
        case FfiMetadataField.Description:
          return ordinalConverter.write(2, into);
        case FfiMetadataField.ImageUrlSquare:
          return ordinalConverter.write(3, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

export enum FfiPermissionLevel {
  Member,
  Admin,
  SuperAdmin,
}

const FfiConverterTypeFfiPermissionLevel = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = FfiPermissionLevel;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return FfiPermissionLevel.Member;
        case 2:
          return FfiPermissionLevel.Admin;
        case 3:
          return FfiPermissionLevel.SuperAdmin;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case FfiPermissionLevel.Member:
          return ordinalConverter.write(1, into);
        case FfiPermissionLevel.Admin:
          return ordinalConverter.write(2, into);
        case FfiPermissionLevel.SuperAdmin:
          return ordinalConverter.write(3, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

export enum FfiPermissionPolicy {
  Allow,
  Deny,
  Admin,
  SuperAdmin,
  DoesNotExist,
  Other,
}

const FfiConverterTypeFfiPermissionPolicy = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = FfiPermissionPolicy;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return FfiPermissionPolicy.Allow;
        case 2:
          return FfiPermissionPolicy.Deny;
        case 3:
          return FfiPermissionPolicy.Admin;
        case 4:
          return FfiPermissionPolicy.SuperAdmin;
        case 5:
          return FfiPermissionPolicy.DoesNotExist;
        case 6:
          return FfiPermissionPolicy.Other;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case FfiPermissionPolicy.Allow:
          return ordinalConverter.write(1, into);
        case FfiPermissionPolicy.Deny:
          return ordinalConverter.write(2, into);
        case FfiPermissionPolicy.Admin:
          return ordinalConverter.write(3, into);
        case FfiPermissionPolicy.SuperAdmin:
          return ordinalConverter.write(4, into);
        case FfiPermissionPolicy.DoesNotExist:
          return ordinalConverter.write(5, into);
        case FfiPermissionPolicy.Other:
          return ordinalConverter.write(6, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

export enum FfiPermissionUpdateType {
  AddMember,
  RemoveMember,
  AddAdmin,
  RemoveAdmin,
  UpdateMetadata,
}

const FfiConverterTypeFfiPermissionUpdateType = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = FfiPermissionUpdateType;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return FfiPermissionUpdateType.AddMember;
        case 2:
          return FfiPermissionUpdateType.RemoveMember;
        case 3:
          return FfiPermissionUpdateType.AddAdmin;
        case 4:
          return FfiPermissionUpdateType.RemoveAdmin;
        case 5:
          return FfiPermissionUpdateType.UpdateMetadata;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case FfiPermissionUpdateType.AddMember:
          return ordinalConverter.write(1, into);
        case FfiPermissionUpdateType.RemoveMember:
          return ordinalConverter.write(2, into);
        case FfiPermissionUpdateType.AddAdmin:
          return ordinalConverter.write(3, into);
        case FfiPermissionUpdateType.RemoveAdmin:
          return ordinalConverter.write(4, into);
        case FfiPermissionUpdateType.UpdateMetadata:
          return ordinalConverter.write(5, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

// Enum: FfiPreferenceUpdate
export enum FfiPreferenceUpdate_Tags {
  Hmac = 'HMAC',
}
export const FfiPreferenceUpdate = (() => {
  type Hmac__interface = {
    tag: FfiPreferenceUpdate_Tags.Hmac;
    inner: Readonly<{ key: ArrayBuffer }>;
  };

  class Hmac_ extends UniffiEnum implements Hmac__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'FfiPreferenceUpdate';
    readonly tag = FfiPreferenceUpdate_Tags.Hmac;
    readonly inner: Readonly<{ key: ArrayBuffer }>;
    constructor(inner: { key: ArrayBuffer }) {
      super('FfiPreferenceUpdate', 'Hmac');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { key: ArrayBuffer }): Hmac_ {
      return new Hmac_(inner);
    }

    static instanceOf(obj: any): obj is Hmac_ {
      return obj.tag === FfiPreferenceUpdate_Tags.Hmac;
    }
  }

  function instanceOf(obj: any): obj is FfiPreferenceUpdate {
    return obj[uniffiTypeNameSymbol] === 'FfiPreferenceUpdate';
  }

  return Object.freeze({
    instanceOf,
    Hmac: Hmac_,
  });
})();

export type FfiPreferenceUpdate = InstanceType<
  (typeof FfiPreferenceUpdate)[keyof Omit<
    typeof FfiPreferenceUpdate,
    'instanceOf'
  >]
>;

// FfiConverter for enum FfiPreferenceUpdate
const FfiConverterTypeFfiPreferenceUpdate = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = FfiPreferenceUpdate;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new FfiPreferenceUpdate.Hmac({
            key: FfiConverterArrayBuffer.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case FfiPreferenceUpdate_Tags.Hmac: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterArrayBuffer.write(inner.key, into);
          return;
        }
        default:
          // Throwing from here means that FfiPreferenceUpdate_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case FfiPreferenceUpdate_Tags.Hmac: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterArrayBuffer.allocationSize(inner.key);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

/**
 * Enum representing process types for logging
 */
export enum FfiProcessType {
  /**
   * Main application process
   */
  Main,
  /**
   * Notification extension/service process
   */
  NotificationExtension,
}

const FfiConverterTypeFfiProcessType = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = FfiProcessType;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return FfiProcessType.Main;
        case 2:
          return FfiProcessType.NotificationExtension;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case FfiProcessType.Main:
          return ordinalConverter.write(1, into);
        case FfiProcessType.NotificationExtension:
          return ordinalConverter.write(2, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

export enum FfiReactionAction {
  Unknown,
  Added,
  Removed,
}

const FfiConverterTypeFfiReactionAction = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = FfiReactionAction;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return FfiReactionAction.Unknown;
        case 2:
          return FfiReactionAction.Added;
        case 3:
          return FfiReactionAction.Removed;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case FfiReactionAction.Unknown:
          return ordinalConverter.write(1, into);
        case FfiReactionAction.Added:
          return ordinalConverter.write(2, into);
        case FfiReactionAction.Removed:
          return ordinalConverter.write(3, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

export enum FfiReactionSchema {
  Unknown,
  Unicode,
  Shortcode,
  Custom,
}

const FfiConverterTypeFfiReactionSchema = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = FfiReactionSchema;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return FfiReactionSchema.Unknown;
        case 2:
          return FfiReactionSchema.Unicode;
        case 3:
          return FfiReactionSchema.Shortcode;
        case 4:
          return FfiReactionSchema.Custom;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case FfiReactionSchema.Unknown:
          return ordinalConverter.write(1, into);
        case FfiReactionSchema.Unicode:
          return ordinalConverter.write(2, into);
        case FfiReactionSchema.Shortcode:
          return ordinalConverter.write(3, into);
        case FfiReactionSchema.Custom:
          return ordinalConverter.write(4, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

/**
 * Signature kind used in identity operations
 */
export enum FfiSignatureKind {
  /**
   * ERC-191 signature (Externally Owned Account/EOA)
   */
  Erc191,
  /**
   * ERC-1271 signature (Smart Contract Wallet/SCW)
   */
  Erc1271,
  /**
   * Installation key signature
   */
  InstallationKey,
  /**
   * Legacy delegated signature
   */
  LegacyDelegated,
  /**
   * P256 passkey signature
   */
  P256,
}

const FfiConverterTypeFfiSignatureKind = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = FfiSignatureKind;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return FfiSignatureKind.Erc191;
        case 2:
          return FfiSignatureKind.Erc1271;
        case 3:
          return FfiSignatureKind.InstallationKey;
        case 4:
          return FfiSignatureKind.LegacyDelegated;
        case 5:
          return FfiSignatureKind.P256;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case FfiSignatureKind.Erc191:
          return ordinalConverter.write(1, into);
        case FfiSignatureKind.Erc1271:
          return ordinalConverter.write(2, into);
        case FfiSignatureKind.InstallationKey:
          return ordinalConverter.write(3, into);
        case FfiSignatureKind.LegacyDelegated:
          return ordinalConverter.write(4, into);
        case FfiSignatureKind.P256:
          return ordinalConverter.write(5, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

export enum FfiSortBy {
  SentAt,
  InsertedAt,
}

const FfiConverterTypeFfiSortBy = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = FfiSortBy;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return FfiSortBy.SentAt;
        case 2:
          return FfiSortBy.InsertedAt;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case FfiSortBy.SentAt:
          return ordinalConverter.write(1, into);
        case FfiSortBy.InsertedAt:
          return ordinalConverter.write(2, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

// Flat error type: FfiSubscribeError
export enum FfiSubscribeError_Tags {
  Subscribe = 'Subscribe',
  Storage = 'Storage',
}
export const FfiSubscribeError = (() => {
  class Subscribe extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'FfiSubscribeError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 1;

    public readonly tag = FfiSubscribeError_Tags.Subscribe;

    constructor(message: string) {
      super('FfiSubscribeError', 'Subscribe', message);
    }

    static instanceOf(e: any): e is Subscribe {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 1;
    }
  }
  class Storage extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'FfiSubscribeError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 2;

    public readonly tag = FfiSubscribeError_Tags.Storage;

    constructor(message: string) {
      super('FfiSubscribeError', 'Storage', message);
    }

    static instanceOf(e: any): e is Storage {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 2;
    }
  }

  // Utility function which does not rely on instanceof.
  function instanceOf(e: any): e is FfiSubscribeError {
    return (e as any)[uniffiTypeNameSymbol] === 'FfiSubscribeError';
  }
  return {
    Subscribe,
    Storage,
    instanceOf,
  };
})();

// Union type for FfiSubscribeError error type.

export type FfiSubscribeError = InstanceType<
  (typeof FfiSubscribeError)[keyof Omit<typeof FfiSubscribeError, 'instanceOf'>]
>;

const FfiConverterTypeFfiSubscribeError = (() => {
  const intConverter = FfiConverterInt32;
  type TypeName = FfiSubscribeError;
  class FfiConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (intConverter.read(from)) {
        case 1:
          return new FfiSubscribeError.Subscribe(FfiConverterString.read(from));

        case 2:
          return new FfiSubscribeError.Storage(FfiConverterString.read(from));

        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      const obj = value as any;
      const index = obj[variantOrdinalSymbol] as number;
      intConverter.write(index, into);
    }
    allocationSize(value: TypeName): number {
      return intConverter.allocationSize(0);
    }
  }
  return new FfiConverter();
})();

export enum FfiSyncMetric {
  Init,
  SyncGroupCreated,
  SyncGroupWelcomesProcessed,
  RequestReceived,
  PayloadSent,
  PayloadProcessed,
  HmacSent,
  HmacReceived,
  ConsentSent,
  ConsentReceived,
  V1ConsentSent,
  V1HmacSent,
  V1PayloadSent,
  V1PayloadProcessed,
}

const FfiConverterTypeFfiSyncMetric = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = FfiSyncMetric;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return FfiSyncMetric.Init;
        case 2:
          return FfiSyncMetric.SyncGroupCreated;
        case 3:
          return FfiSyncMetric.SyncGroupWelcomesProcessed;
        case 4:
          return FfiSyncMetric.RequestReceived;
        case 5:
          return FfiSyncMetric.PayloadSent;
        case 6:
          return FfiSyncMetric.PayloadProcessed;
        case 7:
          return FfiSyncMetric.HmacSent;
        case 8:
          return FfiSyncMetric.HmacReceived;
        case 9:
          return FfiSyncMetric.ConsentSent;
        case 10:
          return FfiSyncMetric.ConsentReceived;
        case 11:
          return FfiSyncMetric.V1ConsentSent;
        case 12:
          return FfiSyncMetric.V1HmacSent;
        case 13:
          return FfiSyncMetric.V1PayloadSent;
        case 14:
          return FfiSyncMetric.V1PayloadProcessed;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case FfiSyncMetric.Init:
          return ordinalConverter.write(1, into);
        case FfiSyncMetric.SyncGroupCreated:
          return ordinalConverter.write(2, into);
        case FfiSyncMetric.SyncGroupWelcomesProcessed:
          return ordinalConverter.write(3, into);
        case FfiSyncMetric.RequestReceived:
          return ordinalConverter.write(4, into);
        case FfiSyncMetric.PayloadSent:
          return ordinalConverter.write(5, into);
        case FfiSyncMetric.PayloadProcessed:
          return ordinalConverter.write(6, into);
        case FfiSyncMetric.HmacSent:
          return ordinalConverter.write(7, into);
        case FfiSyncMetric.HmacReceived:
          return ordinalConverter.write(8, into);
        case FfiSyncMetric.ConsentSent:
          return ordinalConverter.write(9, into);
        case FfiSyncMetric.ConsentReceived:
          return ordinalConverter.write(10, into);
        case FfiSyncMetric.V1ConsentSent:
          return ordinalConverter.write(11, into);
        case FfiSyncMetric.V1HmacSent:
          return ordinalConverter.write(12, into);
        case FfiSyncMetric.V1PayloadSent:
          return ordinalConverter.write(13, into);
        case FfiSyncMetric.V1PayloadProcessed:
          return ordinalConverter.write(14, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

export enum FfiSyncWorkerMode {
  Enabled,
  Disabled,
}

const FfiConverterTypeFfiSyncWorkerMode = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = FfiSyncWorkerMode;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return FfiSyncWorkerMode.Enabled;
        case 2:
          return FfiSyncWorkerMode.Disabled;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case FfiSyncWorkerMode.Enabled:
          return ordinalConverter.write(1, into);
        case FfiSyncWorkerMode.Disabled:
          return ordinalConverter.write(2, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

// Flat error type: GenericError
export enum GenericError_Tags {
  Client = 'Client',
  ClientBuilder = 'ClientBuilder',
  Storage = 'Storage',
  GroupError = 'GroupError',
  Signature = 'Signature',
  GroupMetadata = 'GroupMetadata',
  GroupMutablePermissions = 'GroupMutablePermissions',
  Generic = 'Generic',
  SignatureRequestError = 'SignatureRequestError',
  Erc1271SignatureError = 'Erc1271SignatureError',
  Verifier = 'Verifier',
  FailedToConvertToU32 = 'FailedToConvertToU32',
  Association = 'Association',
  DeviceSync = 'DeviceSync',
  Identity = 'Identity',
  JoinError = 'JoinError',
  IoError = 'IoError',
  Subscription = 'Subscription',
  ApiClientBuild = 'ApiClientBuild',
  Grpc = 'Grpc',
  AddressValidation = 'AddressValidation',
  LogInit = 'LogInit',
  ReloadLog = 'ReloadLog',
  Log = 'Log',
  Expired = 'Expired',
  BackendBuilder = 'BackendBuilder',
}
export const GenericError = (() => {
  class Client extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'GenericError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 1;

    public readonly tag = GenericError_Tags.Client;

    constructor(message: string) {
      super('GenericError', 'Client', message);
    }

    static instanceOf(e: any): e is Client {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 1;
    }
  }
  class ClientBuilder extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'GenericError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 2;

    public readonly tag = GenericError_Tags.ClientBuilder;

    constructor(message: string) {
      super('GenericError', 'ClientBuilder', message);
    }

    static instanceOf(e: any): e is ClientBuilder {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 2;
    }
  }
  class Storage extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'GenericError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 3;

    public readonly tag = GenericError_Tags.Storage;

    constructor(message: string) {
      super('GenericError', 'Storage', message);
    }

    static instanceOf(e: any): e is Storage {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 3;
    }
  }
  class GroupError extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'GenericError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 4;

    public readonly tag = GenericError_Tags.GroupError;

    constructor(message: string) {
      super('GenericError', 'GroupError', message);
    }

    static instanceOf(e: any): e is GroupError {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 4;
    }
  }
  class Signature extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'GenericError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 5;

    public readonly tag = GenericError_Tags.Signature;

    constructor(message: string) {
      super('GenericError', 'Signature', message);
    }

    static instanceOf(e: any): e is Signature {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 5;
    }
  }
  class GroupMetadata extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'GenericError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 6;

    public readonly tag = GenericError_Tags.GroupMetadata;

    constructor(message: string) {
      super('GenericError', 'GroupMetadata', message);
    }

    static instanceOf(e: any): e is GroupMetadata {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 6;
    }
  }
  class GroupMutablePermissions extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'GenericError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 7;

    public readonly tag = GenericError_Tags.GroupMutablePermissions;

    constructor(message: string) {
      super('GenericError', 'GroupMutablePermissions', message);
    }

    static instanceOf(e: any): e is GroupMutablePermissions {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 7;
    }
  }
  class Generic extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'GenericError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 8;

    public readonly tag = GenericError_Tags.Generic;

    constructor(message: string) {
      super('GenericError', 'Generic', message);
    }

    static instanceOf(e: any): e is Generic {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 8;
    }
  }
  class SignatureRequestError extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'GenericError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 9;

    public readonly tag = GenericError_Tags.SignatureRequestError;

    constructor(message: string) {
      super('GenericError', 'SignatureRequestError', message);
    }

    static instanceOf(e: any): e is SignatureRequestError {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 9;
    }
  }
  class Erc1271SignatureError extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'GenericError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 10;

    public readonly tag = GenericError_Tags.Erc1271SignatureError;

    constructor(message: string) {
      super('GenericError', 'Erc1271SignatureError', message);
    }

    static instanceOf(e: any): e is Erc1271SignatureError {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 10;
    }
  }
  class Verifier extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'GenericError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 11;

    public readonly tag = GenericError_Tags.Verifier;

    constructor(message: string) {
      super('GenericError', 'Verifier', message);
    }

    static instanceOf(e: any): e is Verifier {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 11;
    }
  }
  class FailedToConvertToU32 extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'GenericError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 12;

    public readonly tag = GenericError_Tags.FailedToConvertToU32;

    constructor(message: string) {
      super('GenericError', 'FailedToConvertToU32', message);
    }

    static instanceOf(e: any): e is FailedToConvertToU32 {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 12;
    }
  }
  class Association extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'GenericError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 13;

    public readonly tag = GenericError_Tags.Association;

    constructor(message: string) {
      super('GenericError', 'Association', message);
    }

    static instanceOf(e: any): e is Association {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 13;
    }
  }
  class DeviceSync extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'GenericError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 14;

    public readonly tag = GenericError_Tags.DeviceSync;

    constructor(message: string) {
      super('GenericError', 'DeviceSync', message);
    }

    static instanceOf(e: any): e is DeviceSync {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 14;
    }
  }
  class Identity extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'GenericError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 15;

    public readonly tag = GenericError_Tags.Identity;

    constructor(message: string) {
      super('GenericError', 'Identity', message);
    }

    static instanceOf(e: any): e is Identity {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 15;
    }
  }
  class JoinError extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'GenericError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 16;

    public readonly tag = GenericError_Tags.JoinError;

    constructor(message: string) {
      super('GenericError', 'JoinError', message);
    }

    static instanceOf(e: any): e is JoinError {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 16;
    }
  }
  class IoError extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'GenericError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 17;

    public readonly tag = GenericError_Tags.IoError;

    constructor(message: string) {
      super('GenericError', 'IoError', message);
    }

    static instanceOf(e: any): e is IoError {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 17;
    }
  }
  class Subscription extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'GenericError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 18;

    public readonly tag = GenericError_Tags.Subscription;

    constructor(message: string) {
      super('GenericError', 'Subscription', message);
    }

    static instanceOf(e: any): e is Subscription {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 18;
    }
  }
  class ApiClientBuild extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'GenericError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 19;

    public readonly tag = GenericError_Tags.ApiClientBuild;

    constructor(message: string) {
      super('GenericError', 'ApiClientBuild', message);
    }

    static instanceOf(e: any): e is ApiClientBuild {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 19;
    }
  }
  class Grpc extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'GenericError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 20;

    public readonly tag = GenericError_Tags.Grpc;

    constructor(message: string) {
      super('GenericError', 'Grpc', message);
    }

    static instanceOf(e: any): e is Grpc {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 20;
    }
  }
  class AddressValidation extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'GenericError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 21;

    public readonly tag = GenericError_Tags.AddressValidation;

    constructor(message: string) {
      super('GenericError', 'AddressValidation', message);
    }

    static instanceOf(e: any): e is AddressValidation {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 21;
    }
  }
  class LogInit extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'GenericError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 22;

    public readonly tag = GenericError_Tags.LogInit;

    constructor(message: string) {
      super('GenericError', 'LogInit', message);
    }

    static instanceOf(e: any): e is LogInit {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 22;
    }
  }
  class ReloadLog extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'GenericError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 23;

    public readonly tag = GenericError_Tags.ReloadLog;

    constructor(message: string) {
      super('GenericError', 'ReloadLog', message);
    }

    static instanceOf(e: any): e is ReloadLog {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 23;
    }
  }
  class Log extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'GenericError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 24;

    public readonly tag = GenericError_Tags.Log;

    constructor(message: string) {
      super('GenericError', 'Log', message);
    }

    static instanceOf(e: any): e is Log {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 24;
    }
  }
  class Expired extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'GenericError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 25;

    public readonly tag = GenericError_Tags.Expired;

    constructor(message: string) {
      super('GenericError', 'Expired', message);
    }

    static instanceOf(e: any): e is Expired {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 25;
    }
  }
  class BackendBuilder extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'GenericError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 26;

    public readonly tag = GenericError_Tags.BackendBuilder;

    constructor(message: string) {
      super('GenericError', 'BackendBuilder', message);
    }

    static instanceOf(e: any): e is BackendBuilder {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 26;
    }
  }

  // Utility function which does not rely on instanceof.
  function instanceOf(e: any): e is GenericError {
    return (e as any)[uniffiTypeNameSymbol] === 'GenericError';
  }
  return {
    Client,
    ClientBuilder,
    Storage,
    GroupError,
    Signature,
    GroupMetadata,
    GroupMutablePermissions,
    Generic,
    SignatureRequestError,
    Erc1271SignatureError,
    Verifier,
    FailedToConvertToU32,
    Association,
    DeviceSync,
    Identity,
    JoinError,
    IoError,
    Subscription,
    ApiClientBuild,
    Grpc,
    AddressValidation,
    LogInit,
    ReloadLog,
    Log,
    Expired,
    BackendBuilder,
    instanceOf,
  };
})();

// Union type for GenericError error type.

export type GenericError = InstanceType<
  (typeof GenericError)[keyof Omit<typeof GenericError, 'instanceOf'>]
>;

const FfiConverterTypeGenericError = (() => {
  const intConverter = FfiConverterInt32;
  type TypeName = GenericError;
  class FfiConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (intConverter.read(from)) {
        case 1:
          return new GenericError.Client(FfiConverterString.read(from));

        case 2:
          return new GenericError.ClientBuilder(FfiConverterString.read(from));

        case 3:
          return new GenericError.Storage(FfiConverterString.read(from));

        case 4:
          return new GenericError.GroupError(FfiConverterString.read(from));

        case 5:
          return new GenericError.Signature(FfiConverterString.read(from));

        case 6:
          return new GenericError.GroupMetadata(FfiConverterString.read(from));

        case 7:
          return new GenericError.GroupMutablePermissions(
            FfiConverterString.read(from)
          );

        case 8:
          return new GenericError.Generic(FfiConverterString.read(from));

        case 9:
          return new GenericError.SignatureRequestError(
            FfiConverterString.read(from)
          );

        case 10:
          return new GenericError.Erc1271SignatureError(
            FfiConverterString.read(from)
          );

        case 11:
          return new GenericError.Verifier(FfiConverterString.read(from));

        case 12:
          return new GenericError.FailedToConvertToU32(
            FfiConverterString.read(from)
          );

        case 13:
          return new GenericError.Association(FfiConverterString.read(from));

        case 14:
          return new GenericError.DeviceSync(FfiConverterString.read(from));

        case 15:
          return new GenericError.Identity(FfiConverterString.read(from));

        case 16:
          return new GenericError.JoinError(FfiConverterString.read(from));

        case 17:
          return new GenericError.IoError(FfiConverterString.read(from));

        case 18:
          return new GenericError.Subscription(FfiConverterString.read(from));

        case 19:
          return new GenericError.ApiClientBuild(FfiConverterString.read(from));

        case 20:
          return new GenericError.Grpc(FfiConverterString.read(from));

        case 21:
          return new GenericError.AddressValidation(
            FfiConverterString.read(from)
          );

        case 22:
          return new GenericError.LogInit(FfiConverterString.read(from));

        case 23:
          return new GenericError.ReloadLog(FfiConverterString.read(from));

        case 24:
          return new GenericError.Log(FfiConverterString.read(from));

        case 25:
          return new GenericError.Expired(FfiConverterString.read(from));

        case 26:
          return new GenericError.BackendBuilder(FfiConverterString.read(from));

        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      const obj = value as any;
      const index = obj[variantOrdinalSymbol] as number;
      intConverter.write(index, into);
    }
    allocationSize(value: TypeName): number {
      return intConverter.allocationSize(0);
    }
  }
  return new FfiConverter();
})();

// Error type: IdentityValidationError

// Enum: IdentityValidationError
export enum IdentityValidationError_Tags {
  Generic = 'Generic',
}
export const IdentityValidationError = (() => {
  type Generic__interface = {
    tag: IdentityValidationError_Tags.Generic;
    inner: Readonly<[string]>;
  };

  class Generic_ extends UniffiError implements Generic__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'IdentityValidationError';
    readonly tag = IdentityValidationError_Tags.Generic;
    readonly inner: Readonly<[string]>;
    constructor(v0: string) {
      super('IdentityValidationError', 'Generic');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: string): Generic_ {
      return new Generic_(v0);
    }

    static instanceOf(obj: any): obj is Generic_ {
      return obj.tag === IdentityValidationError_Tags.Generic;
    }

    static hasInner(obj: any): obj is Generic_ {
      return Generic_.instanceOf(obj);
    }

    static getInner(obj: Generic_): Readonly<[string]> {
      return obj.inner;
    }
  }

  function instanceOf(obj: any): obj is IdentityValidationError {
    return obj[uniffiTypeNameSymbol] === 'IdentityValidationError';
  }

  return Object.freeze({
    instanceOf,
    Generic: Generic_,
  });
})();

export type IdentityValidationError = InstanceType<
  (typeof IdentityValidationError)[keyof Omit<
    typeof IdentityValidationError,
    'instanceOf'
  >]
>;

// FfiConverter for enum IdentityValidationError
const FfiConverterTypeIdentityValidationError = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = IdentityValidationError;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new IdentityValidationError.Generic(
            FfiConverterString.read(from)
          );
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case IdentityValidationError_Tags.Generic: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterString.write(inner[0], into);
          return;
        }
        default:
          // Throwing from here means that IdentityValidationError_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case IdentityValidationError_Tags.Generic: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterString.allocationSize(inner[0]);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Error type: SigningError

// Enum: SigningError
export enum SigningError_Tags {
  Generic = 'Generic',
}
export const SigningError = (() => {
  type Generic__interface = {
    tag: SigningError_Tags.Generic;
  };

  class Generic_ extends UniffiError implements Generic__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'SigningError';
    readonly tag = SigningError_Tags.Generic;
    constructor() {
      super('SigningError', 'Generic');
    }

    static new(): Generic_ {
      return new Generic_();
    }

    static instanceOf(obj: any): obj is Generic_ {
      return obj.tag === SigningError_Tags.Generic;
    }

    static hasInner(obj: any): obj is Generic_ {
      return false;
    }
  }

  function instanceOf(obj: any): obj is SigningError {
    return obj[uniffiTypeNameSymbol] === 'SigningError';
  }

  return Object.freeze({
    instanceOf,
    Generic: Generic_,
  });
})();

export type SigningError = InstanceType<
  (typeof SigningError)[keyof Omit<typeof SigningError, 'instanceOf'>]
>;

// FfiConverter for enum SigningError
const FfiConverterTypeSigningError = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = SigningError;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new SigningError.Generic();
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case SigningError_Tags.Generic: {
          ordinalConverter.write(1, into);
          return;
        }
        default:
          // Throwing from here means that SigningError_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case SigningError_Tags.Generic: {
          return ordinalConverter.allocationSize(1);
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// FfiConverter for Map<ArrayBuffer, FfiKeyPackageStatus>
const FfiConverterMapArrayBufferTypeFfiKeyPackageStatus = new FfiConverterMap(
  FfiConverterArrayBuffer,
  FfiConverterTypeFfiKeyPackageStatus
);

// FfiConverter for Map<FfiIdentifier, boolean>
const FfiConverterMapTypeFfiIdentifierBool = new FfiConverterMap(
  FfiConverterTypeFfiIdentifier,
  FfiConverterBool
);

// FfiConverter for Map<string, /*i64*/bigint>
const FfiConverterMapStringInt64 = new FfiConverterMap(
  FfiConverterString,
  FfiConverterInt64
);

// FfiConverter for Map<string, string>
const FfiConverterMapStringString = new FfiConverterMap(
  FfiConverterString,
  FfiConverterString
);

// FfiConverter for Map<string, /*u64*/bigint>
const FfiConverterMapStringUInt64 = new FfiConverterMap(
  FfiConverterString,
  FfiConverterUInt64
);

export interface FfiAuthCallback {
  onAuthRequired(asyncOpts_?: {
    signal: AbortSignal;
  }): /*throws*/ Promise<FfiCredential>;
}

export class FfiAuthCallbackImpl
  extends UniffiAbstractObject
  implements FfiAuthCallback
{
  readonly [uniffiTypeNameSymbol] = 'FfiAuthCallbackImpl';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeFfiAuthCallbackImplObjectFactory.bless(pointer);
  }

  public async onAuthRequired(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<FfiCredential> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_xmtpv3_fn_method_ffiauthcallback_on_auth_required(
            uniffiTypeFfiAuthCallbackImplObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterTypeFfiCredential.lift.bind(
          FfiConverterTypeFfiCredential
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeGenericError.lift.bind(
          FfiConverterTypeGenericError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeFfiAuthCallbackImplObjectFactory.pointer(this);
      uniffiTypeFfiAuthCallbackImplObjectFactory.freePointer(pointer);
      uniffiTypeFfiAuthCallbackImplObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is FfiAuthCallbackImpl {
    return uniffiTypeFfiAuthCallbackImplObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeFfiAuthCallbackImplObjectFactory: UniffiObjectFactory<FfiAuthCallback> =
  (() => {
    return {
      create(pointer: UnsafeMutableRawPointer): FfiAuthCallback {
        const instance = Object.create(FfiAuthCallbackImpl.prototype);
        instance[pointerLiteralSymbol] = pointer;
        instance[destructorGuardSymbol] = this.bless(pointer);
        instance[uniffiTypeNameSymbol] = 'FfiAuthCallbackImpl';
        return instance;
      },

      bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
        return uniffiCaller.rustCall(
          /*caller:*/ (status) =>
            nativeModule().ubrn_uniffi_internal_fn_method_ffiauthcallback_ffi__bless_pointer(
              p,
              status
            ),
          /*liftString:*/ FfiConverterString.lift
        );
      },

      unbless(ptr: UniffiRustArcPtr) {
        ptr.markDestroyed();
      },

      pointer(obj: FfiAuthCallback): UnsafeMutableRawPointer {
        if ((obj as any)[destructorGuardSymbol] === undefined) {
          throw new UniffiInternalError.UnexpectedNullPointer();
        }
        return (obj as any)[pointerLiteralSymbol];
      },

      clonePointer(obj: FfiAuthCallback): UnsafeMutableRawPointer {
        const pointer = this.pointer(obj);
        return uniffiCaller.rustCall(
          /*caller:*/ (callStatus) =>
            nativeModule().ubrn_uniffi_xmtpv3_fn_clone_ffiauthcallback(
              pointer,
              callStatus
            ),
          /*liftString:*/ FfiConverterString.lift
        );
      },

      freePointer(pointer: UnsafeMutableRawPointer): void {
        uniffiCaller.rustCall(
          /*caller:*/ (callStatus) =>
            nativeModule().ubrn_uniffi_xmtpv3_fn_free_ffiauthcallback(
              pointer,
              callStatus
            ),
          /*liftString:*/ FfiConverterString.lift
        );
      },

      isConcreteType(obj: any): obj is FfiAuthCallback {
        return (
          obj[destructorGuardSymbol] &&
          obj[uniffiTypeNameSymbol] === 'FfiAuthCallbackImpl'
        );
      },
    };
  })();
// FfiConverter for FfiAuthCallback
const FfiConverterTypeFfiAuthCallback = new FfiConverterObjectWithCallbacks(
  uniffiTypeFfiAuthCallbackImplObjectFactory
);

// Add a vtavble for the callbacks that go in FfiAuthCallback.

// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceFfiAuthCallback: {
  vtable: UniffiVTableCallbackInterfaceFfiAuthCallback;
  register: () => void;
} = {
  // Create the VTable using a series of closures.
  // ts automatically converts these into C callback functions.
  vtable: {
    onAuthRequired: (
      uniffiHandle: bigint,
      uniffiFutureCallback: UniffiForeignFutureCompleteRustBuffer,
      uniffiCallbackData: bigint
    ) => {
      const uniffiMakeCall = async (
        signal: AbortSignal
      ): Promise<FfiCredential> => {
        const jsCallback = FfiConverterTypeFfiAuthCallback.lift(uniffiHandle);
        return await jsCallback.onAuthRequired({ signal });
      };
      const uniffiHandleSuccess = (returnValue: FfiCredential) => {
        uniffiFutureCallback.call(
          uniffiFutureCallback,
          uniffiCallbackData,
          /* UniffiForeignFutureStructRustBuffer */ {
            returnValue: FfiConverterTypeFfiCredential.lower(returnValue),
            callStatus: uniffiCaller.createCallStatus(),
          }
        );
      };
      const uniffiHandleError = (code: number, errorBuf: UniffiByteArray) => {
        uniffiFutureCallback.call(
          uniffiFutureCallback,
          uniffiCallbackData,
          /* UniffiForeignFutureStructRustBuffer */ {
            returnValue: /*empty*/ new Uint8Array(0),
            // TODO create callstatus with error.
            callStatus: uniffiCaller.createErrorStatus(code, errorBuf),
          }
        );
      };
      const uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*isErrorType:*/ GenericError.instanceOf,
        /*lowerError:*/ FfiConverterTypeGenericError.lower.bind(
          FfiConverterTypeGenericError
        ),
        /*lowerString:*/ FfiConverterString.lower
      );
      return uniffiForeignFuture;
    },
    uniffiFree: (uniffiHandle: UniffiHandle): void => {
      // FfiAuthCallback: this will throw a stale handle error if the handle isn't found.
      FfiConverterTypeFfiAuthCallback.drop(uniffiHandle);
    },
  },
  register: () => {
    nativeModule().ubrn_uniffi_xmtpv3_fn_init_callback_vtable_ffiauthcallback(
      uniffiCallbackInterfaceFfiAuthCallback.vtable
    );
  },
};

export interface FfiAuthHandleInterface {
  id(): /*u64*/ bigint;
  set(
    credential: FfiCredential,
    asyncOpts_?: { signal: AbortSignal }
  ): /*throws*/ Promise<void>;
}

export class FfiAuthHandle
  extends UniffiAbstractObject
  implements FfiAuthHandleInterface
{
  readonly [uniffiTypeNameSymbol] = 'FfiAuthHandle';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  constructor() {
    super();
    const pointer = uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_xmtpv3_fn_constructor_ffiauthhandle_new(
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeFfiAuthHandleObjectFactory.bless(pointer);
  }

  public id(): /*u64*/ bigint {
    return FfiConverterUInt64.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_xmtpv3_fn_method_ffiauthhandle_id(
            uniffiTypeFfiAuthHandleObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public async set(
    credential: FfiCredential,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_xmtpv3_fn_method_ffiauthhandle_set(
            uniffiTypeFfiAuthHandleObjectFactory.clonePointer(this),
            FfiConverterTypeFfiCredential.lower(credential)
          );
        },
        /*pollFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_complete_void,
        /*freeFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeGenericError.lift.bind(
          FfiConverterTypeGenericError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeFfiAuthHandleObjectFactory.pointer(this);
      uniffiTypeFfiAuthHandleObjectFactory.freePointer(pointer);
      uniffiTypeFfiAuthHandleObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is FfiAuthHandle {
    return uniffiTypeFfiAuthHandleObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeFfiAuthHandleObjectFactory: UniffiObjectFactory<FfiAuthHandleInterface> =
  (() => {
    return {
      create(pointer: UnsafeMutableRawPointer): FfiAuthHandleInterface {
        const instance = Object.create(FfiAuthHandle.prototype);
        instance[pointerLiteralSymbol] = pointer;
        instance[destructorGuardSymbol] = this.bless(pointer);
        instance[uniffiTypeNameSymbol] = 'FfiAuthHandle';
        return instance;
      },

      bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
        return uniffiCaller.rustCall(
          /*caller:*/ (status) =>
            nativeModule().ubrn_uniffi_internal_fn_method_ffiauthhandle_ffi__bless_pointer(
              p,
              status
            ),
          /*liftString:*/ FfiConverterString.lift
        );
      },

      unbless(ptr: UniffiRustArcPtr) {
        ptr.markDestroyed();
      },

      pointer(obj: FfiAuthHandleInterface): UnsafeMutableRawPointer {
        if ((obj as any)[destructorGuardSymbol] === undefined) {
          throw new UniffiInternalError.UnexpectedNullPointer();
        }
        return (obj as any)[pointerLiteralSymbol];
      },

      clonePointer(obj: FfiAuthHandleInterface): UnsafeMutableRawPointer {
        const pointer = this.pointer(obj);
        return uniffiCaller.rustCall(
          /*caller:*/ (callStatus) =>
            nativeModule().ubrn_uniffi_xmtpv3_fn_clone_ffiauthhandle(
              pointer,
              callStatus
            ),
          /*liftString:*/ FfiConverterString.lift
        );
      },

      freePointer(pointer: UnsafeMutableRawPointer): void {
        uniffiCaller.rustCall(
          /*caller:*/ (callStatus) =>
            nativeModule().ubrn_uniffi_xmtpv3_fn_free_ffiauthhandle(
              pointer,
              callStatus
            ),
          /*liftString:*/ FfiConverterString.lift
        );
      },

      isConcreteType(obj: any): obj is FfiAuthHandleInterface {
        return (
          obj[destructorGuardSymbol] &&
          obj[uniffiTypeNameSymbol] === 'FfiAuthHandle'
        );
      },
    };
  })();
// FfiConverter for FfiAuthHandleInterface
const FfiConverterTypeFfiAuthHandle = new FfiConverterObject(
  uniffiTypeFfiAuthHandleObjectFactory
);

export interface FfiConsentCallback {
  onConsentUpdate(consent: Array<FfiConsent>): void;
  onError(error: FfiSubscribeError): void;
  onClose(): void;
}

export class FfiConsentCallbackImpl
  extends UniffiAbstractObject
  implements FfiConsentCallback
{
  readonly [uniffiTypeNameSymbol] = 'FfiConsentCallbackImpl';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeFfiConsentCallbackImplObjectFactory.bless(pointer);
  }

  public onConsentUpdate(consent: Array<FfiConsent>): void {
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_xmtpv3_fn_method_fficonsentcallback_on_consent_update(
          uniffiTypeFfiConsentCallbackImplObjectFactory.clonePointer(this),
          FfiConverterArrayTypeFfiConsent.lower(consent),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  public onError(error: FfiSubscribeError): void {
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_xmtpv3_fn_method_fficonsentcallback_on_error(
          uniffiTypeFfiConsentCallbackImplObjectFactory.clonePointer(this),
          FfiConverterTypeFfiSubscribeError.lower(error),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  public onClose(): void {
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_xmtpv3_fn_method_fficonsentcallback_on_close(
          uniffiTypeFfiConsentCallbackImplObjectFactory.clonePointer(this),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer =
        uniffiTypeFfiConsentCallbackImplObjectFactory.pointer(this);
      uniffiTypeFfiConsentCallbackImplObjectFactory.freePointer(pointer);
      uniffiTypeFfiConsentCallbackImplObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is FfiConsentCallbackImpl {
    return uniffiTypeFfiConsentCallbackImplObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeFfiConsentCallbackImplObjectFactory: UniffiObjectFactory<FfiConsentCallback> =
  (() => {
    return {
      create(pointer: UnsafeMutableRawPointer): FfiConsentCallback {
        const instance = Object.create(FfiConsentCallbackImpl.prototype);
        instance[pointerLiteralSymbol] = pointer;
        instance[destructorGuardSymbol] = this.bless(pointer);
        instance[uniffiTypeNameSymbol] = 'FfiConsentCallbackImpl';
        return instance;
      },

      bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
        return uniffiCaller.rustCall(
          /*caller:*/ (status) =>
            nativeModule().ubrn_uniffi_internal_fn_method_fficonsentcallback_ffi__bless_pointer(
              p,
              status
            ),
          /*liftString:*/ FfiConverterString.lift
        );
      },

      unbless(ptr: UniffiRustArcPtr) {
        ptr.markDestroyed();
      },

      pointer(obj: FfiConsentCallback): UnsafeMutableRawPointer {
        if ((obj as any)[destructorGuardSymbol] === undefined) {
          throw new UniffiInternalError.UnexpectedNullPointer();
        }
        return (obj as any)[pointerLiteralSymbol];
      },

      clonePointer(obj: FfiConsentCallback): UnsafeMutableRawPointer {
        const pointer = this.pointer(obj);
        return uniffiCaller.rustCall(
          /*caller:*/ (callStatus) =>
            nativeModule().ubrn_uniffi_xmtpv3_fn_clone_fficonsentcallback(
              pointer,
              callStatus
            ),
          /*liftString:*/ FfiConverterString.lift
        );
      },

      freePointer(pointer: UnsafeMutableRawPointer): void {
        uniffiCaller.rustCall(
          /*caller:*/ (callStatus) =>
            nativeModule().ubrn_uniffi_xmtpv3_fn_free_fficonsentcallback(
              pointer,
              callStatus
            ),
          /*liftString:*/ FfiConverterString.lift
        );
      },

      isConcreteType(obj: any): obj is FfiConsentCallback {
        return (
          obj[destructorGuardSymbol] &&
          obj[uniffiTypeNameSymbol] === 'FfiConsentCallbackImpl'
        );
      },
    };
  })();
// FfiConverter for FfiConsentCallback
const FfiConverterTypeFfiConsentCallback = new FfiConverterObjectWithCallbacks(
  uniffiTypeFfiConsentCallbackImplObjectFactory
);

// Add a vtavble for the callbacks that go in FfiConsentCallback.

// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceFfiConsentCallback: {
  vtable: UniffiVTableCallbackInterfaceFfiConsentCallback;
  register: () => void;
} = {
  // Create the VTable using a series of closures.
  // ts automatically converts these into C callback functions.
  vtable: {
    onConsentUpdate: (uniffiHandle: bigint, consent: Uint8Array) => {
      const uniffiMakeCall = (): void => {
        const jsCallback =
          FfiConverterTypeFfiConsentCallback.lift(uniffiHandle);
        return jsCallback.onConsentUpdate(
          FfiConverterArrayTypeFfiConsent.lift(consent)
        );
      };
      const uniffiResult = UniffiResult.ready<void>();
      const uniffiHandleSuccess = (obj: any) => {};
      const uniffiHandleError = (code: number, errBuf: UniffiByteArray) => {
        UniffiResult.writeError(uniffiResult, code, errBuf);
      };
      uniffiTraitInterfaceCall(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*lowerString:*/ FfiConverterString.lower
      );
      return uniffiResult;
    },
    onError: (uniffiHandle: bigint, error: Uint8Array) => {
      const uniffiMakeCall = (): void => {
        const jsCallback =
          FfiConverterTypeFfiConsentCallback.lift(uniffiHandle);
        return jsCallback.onError(
          FfiConverterTypeFfiSubscribeError.lift(error)
        );
      };
      const uniffiResult = UniffiResult.ready<void>();
      const uniffiHandleSuccess = (obj: any) => {};
      const uniffiHandleError = (code: number, errBuf: UniffiByteArray) => {
        UniffiResult.writeError(uniffiResult, code, errBuf);
      };
      uniffiTraitInterfaceCall(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*lowerString:*/ FfiConverterString.lower
      );
      return uniffiResult;
    },
    onClose: (uniffiHandle: bigint) => {
      const uniffiMakeCall = (): void => {
        const jsCallback =
          FfiConverterTypeFfiConsentCallback.lift(uniffiHandle);
        return jsCallback.onClose();
      };
      const uniffiResult = UniffiResult.ready<void>();
      const uniffiHandleSuccess = (obj: any) => {};
      const uniffiHandleError = (code: number, errBuf: UniffiByteArray) => {
        UniffiResult.writeError(uniffiResult, code, errBuf);
      };
      uniffiTraitInterfaceCall(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*lowerString:*/ FfiConverterString.lower
      );
      return uniffiResult;
    },
    uniffiFree: (uniffiHandle: UniffiHandle): void => {
      // FfiConsentCallback: this will throw a stale handle error if the handle isn't found.
      FfiConverterTypeFfiConsentCallback.drop(uniffiHandle);
    },
  },
  register: () => {
    nativeModule().ubrn_uniffi_xmtpv3_fn_init_callback_vtable_fficonsentcallback(
      uniffiCallbackInterfaceFfiConsentCallback.vtable
    );
  },
};

export interface FfiConversationInterface {
  addAdmin(
    inboxId: string,
    asyncOpts_?: { signal: AbortSignal }
  ): /*throws*/ Promise<void>;
  addMembers(
    accountIdentifiers: Array<FfiIdentifier>,
    asyncOpts_?: { signal: AbortSignal }
  ): /*throws*/ Promise<FfiUpdateGroupMembershipResult>;
  addMembersByInboxId(
    inboxIds: Array<string>,
    asyncOpts_?: { signal: AbortSignal }
  ): /*throws*/ Promise<FfiUpdateGroupMembershipResult>;
  addSuperAdmin(
    inboxId: string,
    asyncOpts_?: { signal: AbortSignal }
  ): /*throws*/ Promise<void>;
  addedByInboxId(): /*throws*/ string;
  adminList(): /*throws*/ Array<string>;
  appData(): /*throws*/ string;
  consentState(): /*throws*/ FfiConsentState;
  conversationDebugInfo(asyncOpts_?: {
    signal: AbortSignal;
  }): /*throws*/ Promise<FfiConversationDebugInfo>;
  conversationMessageDisappearingSettings(): /*throws*/
    | FfiMessageDisappearingSettings
    | undefined;
  conversationType(): FfiConversationType;
  countMessages(opts: FfiListMessagesOptions): /*throws*/ /*i64*/ bigint;
  createdAtNs(): /*i64*/ bigint;
  dmPeerInboxId(): string | undefined;
  findDuplicateDms(asyncOpts_?: {
    signal: AbortSignal;
  }): /*throws*/ Promise<Array<FfiConversationInterface>>;
  findEnrichedMessages(
    opts: FfiListMessagesOptions
  ): /*throws*/ Array<FfiDecodedMessageInterface>;
  findMessages(
    opts: FfiListMessagesOptions,
    asyncOpts_?: { signal: AbortSignal }
  ): /*throws*/ Promise<Array<FfiMessage>>;
  findMessagesWithReactions(
    opts: FfiListMessagesOptions
  ): /*throws*/ Array<FfiMessageWithReactions>;
  getHmacKeys(): /*throws*/ Map<ArrayBuffer, Array<FfiHmacKey>>;
  getLastReadTimes(): /*throws*/ Map<string, /*i64*/ bigint>;
  groupDescription(): /*throws*/ string;
  groupImageUrlSquare(): /*throws*/ string;
  groupMetadata(asyncOpts_?: {
    signal: AbortSignal;
  }): /*throws*/ Promise<FfiConversationMetadataInterface>;
  groupName(): /*throws*/ string;
  groupPermissions(): /*throws*/ FfiGroupPermissionsInterface;
  id(): ArrayBuffer;
  isActive(): /*throws*/ boolean;
  isAdmin(inboxId: string): /*throws*/ boolean;
  isConversationMessageDisappearingEnabled(): /*throws*/ boolean;
  isSuperAdmin(inboxId: string): /*throws*/ boolean;
  leaveGroup(asyncOpts_?: { signal: AbortSignal }): /*throws*/ Promise<void>;
  listMembers(asyncOpts_?: {
    signal: AbortSignal;
  }): /*throws*/ Promise<Array<FfiConversationMember>>;
  membershipState(): /*throws*/ FfiGroupMembershipState;
  pausedForVersion(): /*throws*/ string | undefined;
  processStreamedConversationMessage(
    envelopeBytes: ArrayBuffer,
    asyncOpts_?: { signal: AbortSignal }
  ): /*throws*/ Promise<FfiMessage>;
  /**
   * Publish all unpublished messages
   */
  publishMessages(asyncOpts_?: {
    signal: AbortSignal;
  }): /*throws*/ Promise<void>;
  removeAdmin(
    inboxId: string,
    asyncOpts_?: { signal: AbortSignal }
  ): /*throws*/ Promise<void>;
  removeConversationMessageDisappearingSettings(asyncOpts_?: {
    signal: AbortSignal;
  }): /*throws*/ Promise<void>;
  removeMembers(
    accountIdentifiers: Array<FfiIdentifier>,
    asyncOpts_?: { signal: AbortSignal }
  ): /*throws*/ Promise<void>;
  removeMembersByInboxId(
    inboxIds: Array<string>,
    asyncOpts_?: { signal: AbortSignal }
  ): /*throws*/ Promise<void>;
  removeSuperAdmin(
    inboxId: string,
    asyncOpts_?: { signal: AbortSignal }
  ): /*throws*/ Promise<void>;
  send(
    contentBytes: ArrayBuffer,
    opts: FfiSendMessageOpts,
    asyncOpts_?: { signal: AbortSignal }
  ): /*throws*/ Promise<ArrayBuffer>;
  /**
   * send a message without immediately publishing to the delivery service.
   */
  sendOptimistic(
    contentBytes: ArrayBuffer,
    opts: FfiSendMessageOpts
  ): /*throws*/ ArrayBuffer;
  sendText(
    text: string,
    asyncOpts_?: { signal: AbortSignal }
  ): /*throws*/ Promise<ArrayBuffer>;
  stream(
    messageCallback: FfiMessageCallback,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<FfiStreamCloserInterface>;
  superAdminList(): /*throws*/ Array<string>;
  sync(asyncOpts_?: { signal: AbortSignal }): /*throws*/ Promise<void>;
  updateAppData(
    appData: string,
    asyncOpts_?: { signal: AbortSignal }
  ): /*throws*/ Promise<void>;
  updateConsentState(state: FfiConsentState): /*throws*/ void;
  updateConversationMessageDisappearingSettings(
    settings: FfiMessageDisappearingSettings,
    asyncOpts_?: { signal: AbortSignal }
  ): /*throws*/ Promise<void>;
  updateGroupDescription(
    groupDescription: string,
    asyncOpts_?: { signal: AbortSignal }
  ): /*throws*/ Promise<void>;
  updateGroupImageUrlSquare(
    groupImageUrlSquare: string,
    asyncOpts_?: { signal: AbortSignal }
  ): /*throws*/ Promise<void>;
  updateGroupName(
    groupName: string,
    asyncOpts_?: { signal: AbortSignal }
  ): /*throws*/ Promise<void>;
  updatePermissionPolicy(
    permissionUpdateType: FfiPermissionUpdateType,
    permissionPolicyOption: FfiPermissionPolicy,
    metadataField: FfiMetadataField | undefined,
    asyncOpts_?: { signal: AbortSignal }
  ): /*throws*/ Promise<void>;
}

export class FfiConversation
  extends UniffiAbstractObject
  implements FfiConversationInterface
{
  readonly [uniffiTypeNameSymbol] = 'FfiConversation';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeFfiConversationObjectFactory.bless(pointer);
  }

  public async addAdmin(
    inboxId: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_xmtpv3_fn_method_fficonversation_add_admin(
            uniffiTypeFfiConversationObjectFactory.clonePointer(this),
            FfiConverterString.lower(inboxId)
          );
        },
        /*pollFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_complete_void,
        /*freeFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeGenericError.lift.bind(
          FfiConverterTypeGenericError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async addMembers(
    accountIdentifiers: Array<FfiIdentifier>,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<FfiUpdateGroupMembershipResult> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_xmtpv3_fn_method_fficonversation_add_members(
            uniffiTypeFfiConversationObjectFactory.clonePointer(this),
            FfiConverterArrayTypeFfiIdentifier.lower(accountIdentifiers)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterTypeFfiUpdateGroupMembershipResult.lift.bind(
          FfiConverterTypeFfiUpdateGroupMembershipResult
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeGenericError.lift.bind(
          FfiConverterTypeGenericError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async addMembersByInboxId(
    inboxIds: Array<string>,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<FfiUpdateGroupMembershipResult> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_xmtpv3_fn_method_fficonversation_add_members_by_inbox_id(
            uniffiTypeFfiConversationObjectFactory.clonePointer(this),
            FfiConverterArrayString.lower(inboxIds)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterTypeFfiUpdateGroupMembershipResult.lift.bind(
          FfiConverterTypeFfiUpdateGroupMembershipResult
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeGenericError.lift.bind(
          FfiConverterTypeGenericError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async addSuperAdmin(
    inboxId: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_xmtpv3_fn_method_fficonversation_add_super_admin(
            uniffiTypeFfiConversationObjectFactory.clonePointer(this),
            FfiConverterString.lower(inboxId)
          );
        },
        /*pollFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_complete_void,
        /*freeFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeGenericError.lift.bind(
          FfiConverterTypeGenericError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public addedByInboxId(): string /*throws*/ {
    return FfiConverterString.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeGenericError.lift.bind(
          FfiConverterTypeGenericError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_xmtpv3_fn_method_fficonversation_added_by_inbox_id(
            uniffiTypeFfiConversationObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public adminList(): Array<string> /*throws*/ {
    return FfiConverterArrayString.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeGenericError.lift.bind(
          FfiConverterTypeGenericError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_xmtpv3_fn_method_fficonversation_admin_list(
            uniffiTypeFfiConversationObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public appData(): string /*throws*/ {
    return FfiConverterString.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeGenericError.lift.bind(
          FfiConverterTypeGenericError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_xmtpv3_fn_method_fficonversation_app_data(
            uniffiTypeFfiConversationObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public consentState(): FfiConsentState /*throws*/ {
    return FfiConverterTypeFfiConsentState.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeGenericError.lift.bind(
          FfiConverterTypeGenericError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_xmtpv3_fn_method_fficonversation_consent_state(
            uniffiTypeFfiConversationObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public async conversationDebugInfo(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<FfiConversationDebugInfo> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_xmtpv3_fn_method_fficonversation_conversation_debug_info(
            uniffiTypeFfiConversationObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterTypeFfiConversationDebugInfo.lift.bind(
          FfiConverterTypeFfiConversationDebugInfo
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeGenericError.lift.bind(
          FfiConverterTypeGenericError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public conversationMessageDisappearingSettings():
    | FfiMessageDisappearingSettings
    | undefined /*throws*/ {
    return FfiConverterOptionalTypeFfiMessageDisappearingSettings.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeGenericError.lift.bind(
          FfiConverterTypeGenericError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_xmtpv3_fn_method_fficonversation_conversation_message_disappearing_settings(
            uniffiTypeFfiConversationObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public conversationType(): FfiConversationType {
    return FfiConverterTypeFfiConversationType.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_xmtpv3_fn_method_fficonversation_conversation_type(
            uniffiTypeFfiConversationObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public countMessages(
    opts: FfiListMessagesOptions
  ): /*i64*/ bigint /*throws*/ {
    return FfiConverterInt64.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeGenericError.lift.bind(
          FfiConverterTypeGenericError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_xmtpv3_fn_method_fficonversation_count_messages(
            uniffiTypeFfiConversationObjectFactory.clonePointer(this),
            FfiConverterTypeFfiListMessagesOptions.lower(opts),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public createdAtNs(): /*i64*/ bigint {
    return FfiConverterInt64.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_xmtpv3_fn_method_fficonversation_created_at_ns(
            uniffiTypeFfiConversationObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public dmPeerInboxId(): string | undefined {
    return FfiConverterOptionalString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_xmtpv3_fn_method_fficonversation_dm_peer_inbox_id(
            uniffiTypeFfiConversationObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public async findDuplicateDms(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<Array<FfiConversationInterface>> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_xmtpv3_fn_method_fficonversation_find_duplicate_dms(
            uniffiTypeFfiConversationObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterArrayTypeFfiConversation.lift.bind(
          FfiConverterArrayTypeFfiConversation
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeGenericError.lift.bind(
          FfiConverterTypeGenericError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public findEnrichedMessages(
    opts: FfiListMessagesOptions
  ): Array<FfiDecodedMessageInterface> /*throws*/ {
    return FfiConverterArrayTypeFfiDecodedMessage.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeGenericError.lift.bind(
          FfiConverterTypeGenericError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_xmtpv3_fn_method_fficonversation_find_enriched_messages(
            uniffiTypeFfiConversationObjectFactory.clonePointer(this),
            FfiConverterTypeFfiListMessagesOptions.lower(opts),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public async findMessages(
    opts: FfiListMessagesOptions,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<Array<FfiMessage>> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_xmtpv3_fn_method_fficonversation_find_messages(
            uniffiTypeFfiConversationObjectFactory.clonePointer(this),
            FfiConverterTypeFfiListMessagesOptions.lower(opts)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterArrayTypeFfiMessage.lift.bind(
          FfiConverterArrayTypeFfiMessage
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeGenericError.lift.bind(
          FfiConverterTypeGenericError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public findMessagesWithReactions(
    opts: FfiListMessagesOptions
  ): Array<FfiMessageWithReactions> /*throws*/ {
    return FfiConverterArrayTypeFfiMessageWithReactions.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeGenericError.lift.bind(
          FfiConverterTypeGenericError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_xmtpv3_fn_method_fficonversation_find_messages_with_reactions(
            uniffiTypeFfiConversationObjectFactory.clonePointer(this),
            FfiConverterTypeFfiListMessagesOptions.lower(opts),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public getHmacKeys(): Map<ArrayBuffer, Array<FfiHmacKey>> /*throws*/ {
    return FfiConverterMapArrayBufferArrayTypeFfiHmacKey.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeGenericError.lift.bind(
          FfiConverterTypeGenericError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_xmtpv3_fn_method_fficonversation_get_hmac_keys(
            uniffiTypeFfiConversationObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public getLastReadTimes(): Map<string, /*i64*/ bigint> /*throws*/ {
    return FfiConverterMapStringInt64.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeGenericError.lift.bind(
          FfiConverterTypeGenericError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_xmtpv3_fn_method_fficonversation_get_last_read_times(
            uniffiTypeFfiConversationObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public groupDescription(): string /*throws*/ {
    return FfiConverterString.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeGenericError.lift.bind(
          FfiConverterTypeGenericError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_xmtpv3_fn_method_fficonversation_group_description(
            uniffiTypeFfiConversationObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public groupImageUrlSquare(): string /*throws*/ {
    return FfiConverterString.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeGenericError.lift.bind(
          FfiConverterTypeGenericError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_xmtpv3_fn_method_fficonversation_group_image_url_square(
            uniffiTypeFfiConversationObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public async groupMetadata(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<FfiConversationMetadataInterface> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_xmtpv3_fn_method_fficonversation_group_metadata(
            uniffiTypeFfiConversationObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_poll_pointer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_cancel_pointer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_complete_pointer,
        /*freeFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_free_pointer,
        /*liftFunc:*/ FfiConverterTypeFfiConversationMetadata.lift.bind(
          FfiConverterTypeFfiConversationMetadata
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeGenericError.lift.bind(
          FfiConverterTypeGenericError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public groupName(): string /*throws*/ {
    return FfiConverterString.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeGenericError.lift.bind(
          FfiConverterTypeGenericError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_xmtpv3_fn_method_fficonversation_group_name(
            uniffiTypeFfiConversationObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public groupPermissions(): FfiGroupPermissionsInterface /*throws*/ {
    return FfiConverterTypeFfiGroupPermissions.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeGenericError.lift.bind(
          FfiConverterTypeGenericError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_xmtpv3_fn_method_fficonversation_group_permissions(
            uniffiTypeFfiConversationObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public id(): ArrayBuffer {
    return FfiConverterArrayBuffer.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_xmtpv3_fn_method_fficonversation_id(
            uniffiTypeFfiConversationObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public isActive(): boolean /*throws*/ {
    return FfiConverterBool.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeGenericError.lift.bind(
          FfiConverterTypeGenericError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_xmtpv3_fn_method_fficonversation_is_active(
            uniffiTypeFfiConversationObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public isAdmin(inboxId: string): boolean /*throws*/ {
    return FfiConverterBool.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeGenericError.lift.bind(
          FfiConverterTypeGenericError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_xmtpv3_fn_method_fficonversation_is_admin(
            uniffiTypeFfiConversationObjectFactory.clonePointer(this),
            FfiConverterString.lower(inboxId),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public isConversationMessageDisappearingEnabled(): boolean /*throws*/ {
    return FfiConverterBool.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeGenericError.lift.bind(
          FfiConverterTypeGenericError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_xmtpv3_fn_method_fficonversation_is_conversation_message_disappearing_enabled(
            uniffiTypeFfiConversationObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public isSuperAdmin(inboxId: string): boolean /*throws*/ {
    return FfiConverterBool.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeGenericError.lift.bind(
          FfiConverterTypeGenericError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_xmtpv3_fn_method_fficonversation_is_super_admin(
            uniffiTypeFfiConversationObjectFactory.clonePointer(this),
            FfiConverterString.lower(inboxId),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public async leaveGroup(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_xmtpv3_fn_method_fficonversation_leave_group(
            uniffiTypeFfiConversationObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_complete_void,
        /*freeFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeGenericError.lift.bind(
          FfiConverterTypeGenericError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async listMembers(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<Array<FfiConversationMember>> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_xmtpv3_fn_method_fficonversation_list_members(
            uniffiTypeFfiConversationObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterArrayTypeFfiConversationMember.lift.bind(
          FfiConverterArrayTypeFfiConversationMember
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeGenericError.lift.bind(
          FfiConverterTypeGenericError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public membershipState(): FfiGroupMembershipState /*throws*/ {
    return FfiConverterTypeFfiGroupMembershipState.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeGenericError.lift.bind(
          FfiConverterTypeGenericError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_xmtpv3_fn_method_fficonversation_membership_state(
            uniffiTypeFfiConversationObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public pausedForVersion(): string | undefined /*throws*/ {
    return FfiConverterOptionalString.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeGenericError.lift.bind(
          FfiConverterTypeGenericError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_xmtpv3_fn_method_fficonversation_paused_for_version(
            uniffiTypeFfiConversationObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public async processStreamedConversationMessage(
    envelopeBytes: ArrayBuffer,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<FfiMessage> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_xmtpv3_fn_method_fficonversation_process_streamed_conversation_message(
            uniffiTypeFfiConversationObjectFactory.clonePointer(this),
            FfiConverterArrayBuffer.lower(envelopeBytes)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterTypeFfiMessage.lift.bind(
          FfiConverterTypeFfiMessage
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeFfiSubscribeError.lift.bind(
          FfiConverterTypeFfiSubscribeError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Publish all unpublished messages
   */
  public async publishMessages(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_xmtpv3_fn_method_fficonversation_publish_messages(
            uniffiTypeFfiConversationObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_complete_void,
        /*freeFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeGenericError.lift.bind(
          FfiConverterTypeGenericError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async removeAdmin(
    inboxId: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_xmtpv3_fn_method_fficonversation_remove_admin(
            uniffiTypeFfiConversationObjectFactory.clonePointer(this),
            FfiConverterString.lower(inboxId)
          );
        },
        /*pollFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_complete_void,
        /*freeFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeGenericError.lift.bind(
          FfiConverterTypeGenericError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async removeConversationMessageDisappearingSettings(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_xmtpv3_fn_method_fficonversation_remove_conversation_message_disappearing_settings(
            uniffiTypeFfiConversationObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_complete_void,
        /*freeFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeGenericError.lift.bind(
          FfiConverterTypeGenericError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async removeMembers(
    accountIdentifiers: Array<FfiIdentifier>,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_xmtpv3_fn_method_fficonversation_remove_members(
            uniffiTypeFfiConversationObjectFactory.clonePointer(this),
            FfiConverterArrayTypeFfiIdentifier.lower(accountIdentifiers)
          );
        },
        /*pollFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_complete_void,
        /*freeFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeGenericError.lift.bind(
          FfiConverterTypeGenericError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async removeMembersByInboxId(
    inboxIds: Array<string>,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_xmtpv3_fn_method_fficonversation_remove_members_by_inbox_id(
            uniffiTypeFfiConversationObjectFactory.clonePointer(this),
            FfiConverterArrayString.lower(inboxIds)
          );
        },
        /*pollFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_complete_void,
        /*freeFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeGenericError.lift.bind(
          FfiConverterTypeGenericError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async removeSuperAdmin(
    inboxId: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_xmtpv3_fn_method_fficonversation_remove_super_admin(
            uniffiTypeFfiConversationObjectFactory.clonePointer(this),
            FfiConverterString.lower(inboxId)
          );
        },
        /*pollFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_complete_void,
        /*freeFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeGenericError.lift.bind(
          FfiConverterTypeGenericError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async send(
    contentBytes: ArrayBuffer,
    opts: FfiSendMessageOpts,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<ArrayBuffer> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_xmtpv3_fn_method_fficonversation_send(
            uniffiTypeFfiConversationObjectFactory.clonePointer(this),
            FfiConverterArrayBuffer.lower(contentBytes),
            FfiConverterTypeFfiSendMessageOpts.lower(opts)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterArrayBuffer.lift.bind(
          FfiConverterArrayBuffer
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeGenericError.lift.bind(
          FfiConverterTypeGenericError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * send a message without immediately publishing to the delivery service.
   */
  public sendOptimistic(
    contentBytes: ArrayBuffer,
    opts: FfiSendMessageOpts
  ): ArrayBuffer /*throws*/ {
    return FfiConverterArrayBuffer.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeGenericError.lift.bind(
          FfiConverterTypeGenericError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_xmtpv3_fn_method_fficonversation_send_optimistic(
            uniffiTypeFfiConversationObjectFactory.clonePointer(this),
            FfiConverterArrayBuffer.lower(contentBytes),
            FfiConverterTypeFfiSendMessageOpts.lower(opts),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public async sendText(
    text: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<ArrayBuffer> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_xmtpv3_fn_method_fficonversation_send_text(
            uniffiTypeFfiConversationObjectFactory.clonePointer(this),
            FfiConverterString.lower(text)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterArrayBuffer.lift.bind(
          FfiConverterArrayBuffer
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeGenericError.lift.bind(
          FfiConverterTypeGenericError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async stream(
    messageCallback: FfiMessageCallback,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<FfiStreamCloserInterface> {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_xmtpv3_fn_method_fficonversation_stream(
            uniffiTypeFfiConversationObjectFactory.clonePointer(this),
            FfiConverterTypeFfiMessageCallback.lower(messageCallback)
          );
        },
        /*pollFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_poll_pointer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_cancel_pointer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_complete_pointer,
        /*freeFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_free_pointer,
        /*liftFunc:*/ FfiConverterTypeFfiStreamCloser.lift.bind(
          FfiConverterTypeFfiStreamCloser
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public superAdminList(): Array<string> /*throws*/ {
    return FfiConverterArrayString.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeGenericError.lift.bind(
          FfiConverterTypeGenericError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_xmtpv3_fn_method_fficonversation_super_admin_list(
            uniffiTypeFfiConversationObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public async sync(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_xmtpv3_fn_method_fficonversation_sync(
            uniffiTypeFfiConversationObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_complete_void,
        /*freeFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeGenericError.lift.bind(
          FfiConverterTypeGenericError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async updateAppData(
    appData: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_xmtpv3_fn_method_fficonversation_update_app_data(
            uniffiTypeFfiConversationObjectFactory.clonePointer(this),
            FfiConverterString.lower(appData)
          );
        },
        /*pollFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_complete_void,
        /*freeFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeGenericError.lift.bind(
          FfiConverterTypeGenericError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public updateConsentState(state: FfiConsentState): void /*throws*/ {
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeGenericError.lift.bind(
        FfiConverterTypeGenericError
      ),
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_xmtpv3_fn_method_fficonversation_update_consent_state(
          uniffiTypeFfiConversationObjectFactory.clonePointer(this),
          FfiConverterTypeFfiConsentState.lower(state),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  public async updateConversationMessageDisappearingSettings(
    settings: FfiMessageDisappearingSettings,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_xmtpv3_fn_method_fficonversation_update_conversation_message_disappearing_settings(
            uniffiTypeFfiConversationObjectFactory.clonePointer(this),
            FfiConverterTypeFfiMessageDisappearingSettings.lower(settings)
          );
        },
        /*pollFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_complete_void,
        /*freeFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeGenericError.lift.bind(
          FfiConverterTypeGenericError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async updateGroupDescription(
    groupDescription: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_xmtpv3_fn_method_fficonversation_update_group_description(
            uniffiTypeFfiConversationObjectFactory.clonePointer(this),
            FfiConverterString.lower(groupDescription)
          );
        },
        /*pollFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_complete_void,
        /*freeFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeGenericError.lift.bind(
          FfiConverterTypeGenericError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async updateGroupImageUrlSquare(
    groupImageUrlSquare: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_xmtpv3_fn_method_fficonversation_update_group_image_url_square(
            uniffiTypeFfiConversationObjectFactory.clonePointer(this),
            FfiConverterString.lower(groupImageUrlSquare)
          );
        },
        /*pollFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_complete_void,
        /*freeFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeGenericError.lift.bind(
          FfiConverterTypeGenericError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async updateGroupName(
    groupName: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_xmtpv3_fn_method_fficonversation_update_group_name(
            uniffiTypeFfiConversationObjectFactory.clonePointer(this),
            FfiConverterString.lower(groupName)
          );
        },
        /*pollFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_complete_void,
        /*freeFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeGenericError.lift.bind(
          FfiConverterTypeGenericError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async updatePermissionPolicy(
    permissionUpdateType: FfiPermissionUpdateType,
    permissionPolicyOption: FfiPermissionPolicy,
    metadataField: FfiMetadataField | undefined,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_xmtpv3_fn_method_fficonversation_update_permission_policy(
            uniffiTypeFfiConversationObjectFactory.clonePointer(this),
            FfiConverterTypeFfiPermissionUpdateType.lower(permissionUpdateType),
            FfiConverterTypeFfiPermissionPolicy.lower(permissionPolicyOption),
            FfiConverterOptionalTypeFfiMetadataField.lower(metadataField)
          );
        },
        /*pollFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_complete_void,
        /*freeFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeGenericError.lift.bind(
          FfiConverterTypeGenericError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeFfiConversationObjectFactory.pointer(this);
      uniffiTypeFfiConversationObjectFactory.freePointer(pointer);
      uniffiTypeFfiConversationObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is FfiConversation {
    return uniffiTypeFfiConversationObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeFfiConversationObjectFactory: UniffiObjectFactory<FfiConversationInterface> =
  (() => {
    return {
      create(pointer: UnsafeMutableRawPointer): FfiConversationInterface {
        const instance = Object.create(FfiConversation.prototype);
        instance[pointerLiteralSymbol] = pointer;
        instance[destructorGuardSymbol] = this.bless(pointer);
        instance[uniffiTypeNameSymbol] = 'FfiConversation';
        return instance;
      },

      bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
        return uniffiCaller.rustCall(
          /*caller:*/ (status) =>
            nativeModule().ubrn_uniffi_internal_fn_method_fficonversation_ffi__bless_pointer(
              p,
              status
            ),
          /*liftString:*/ FfiConverterString.lift
        );
      },

      unbless(ptr: UniffiRustArcPtr) {
        ptr.markDestroyed();
      },

      pointer(obj: FfiConversationInterface): UnsafeMutableRawPointer {
        if ((obj as any)[destructorGuardSymbol] === undefined) {
          throw new UniffiInternalError.UnexpectedNullPointer();
        }
        return (obj as any)[pointerLiteralSymbol];
      },

      clonePointer(obj: FfiConversationInterface): UnsafeMutableRawPointer {
        const pointer = this.pointer(obj);
        return uniffiCaller.rustCall(
          /*caller:*/ (callStatus) =>
            nativeModule().ubrn_uniffi_xmtpv3_fn_clone_fficonversation(
              pointer,
              callStatus
            ),
          /*liftString:*/ FfiConverterString.lift
        );
      },

      freePointer(pointer: UnsafeMutableRawPointer): void {
        uniffiCaller.rustCall(
          /*caller:*/ (callStatus) =>
            nativeModule().ubrn_uniffi_xmtpv3_fn_free_fficonversation(
              pointer,
              callStatus
            ),
          /*liftString:*/ FfiConverterString.lift
        );
      },

      isConcreteType(obj: any): obj is FfiConversationInterface {
        return (
          obj[destructorGuardSymbol] &&
          obj[uniffiTypeNameSymbol] === 'FfiConversation'
        );
      },
    };
  })();
// FfiConverter for FfiConversationInterface
const FfiConverterTypeFfiConversation = new FfiConverterObject(
  uniffiTypeFfiConversationObjectFactory
);

export interface FfiConversationCallback {
  onConversation(conversation: FfiConversationInterface): void;
  onError(error: FfiSubscribeError): void;
  onClose(): void;
}

export class FfiConversationCallbackImpl
  extends UniffiAbstractObject
  implements FfiConversationCallback
{
  readonly [uniffiTypeNameSymbol] = 'FfiConversationCallbackImpl';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeFfiConversationCallbackImplObjectFactory.bless(pointer);
  }

  public onConversation(conversation: FfiConversationInterface): void {
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_xmtpv3_fn_method_fficonversationcallback_on_conversation(
          uniffiTypeFfiConversationCallbackImplObjectFactory.clonePointer(this),
          FfiConverterTypeFfiConversation.lower(conversation),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  public onError(error: FfiSubscribeError): void {
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_xmtpv3_fn_method_fficonversationcallback_on_error(
          uniffiTypeFfiConversationCallbackImplObjectFactory.clonePointer(this),
          FfiConverterTypeFfiSubscribeError.lower(error),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  public onClose(): void {
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_xmtpv3_fn_method_fficonversationcallback_on_close(
          uniffiTypeFfiConversationCallbackImplObjectFactory.clonePointer(this),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer =
        uniffiTypeFfiConversationCallbackImplObjectFactory.pointer(this);
      uniffiTypeFfiConversationCallbackImplObjectFactory.freePointer(pointer);
      uniffiTypeFfiConversationCallbackImplObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is FfiConversationCallbackImpl {
    return uniffiTypeFfiConversationCallbackImplObjectFactory.isConcreteType(
      obj
    );
  }
}

const uniffiTypeFfiConversationCallbackImplObjectFactory: UniffiObjectFactory<FfiConversationCallback> =
  (() => {
    return {
      create(pointer: UnsafeMutableRawPointer): FfiConversationCallback {
        const instance = Object.create(FfiConversationCallbackImpl.prototype);
        instance[pointerLiteralSymbol] = pointer;
        instance[destructorGuardSymbol] = this.bless(pointer);
        instance[uniffiTypeNameSymbol] = 'FfiConversationCallbackImpl';
        return instance;
      },

      bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
        return uniffiCaller.rustCall(
          /*caller:*/ (status) =>
            nativeModule().ubrn_uniffi_internal_fn_method_fficonversationcallback_ffi__bless_pointer(
              p,
              status
            ),
          /*liftString:*/ FfiConverterString.lift
        );
      },

      unbless(ptr: UniffiRustArcPtr) {
        ptr.markDestroyed();
      },

      pointer(obj: FfiConversationCallback): UnsafeMutableRawPointer {
        if ((obj as any)[destructorGuardSymbol] === undefined) {
          throw new UniffiInternalError.UnexpectedNullPointer();
        }
        return (obj as any)[pointerLiteralSymbol];
      },

      clonePointer(obj: FfiConversationCallback): UnsafeMutableRawPointer {
        const pointer = this.pointer(obj);
        return uniffiCaller.rustCall(
          /*caller:*/ (callStatus) =>
            nativeModule().ubrn_uniffi_xmtpv3_fn_clone_fficonversationcallback(
              pointer,
              callStatus
            ),
          /*liftString:*/ FfiConverterString.lift
        );
      },

      freePointer(pointer: UnsafeMutableRawPointer): void {
        uniffiCaller.rustCall(
          /*caller:*/ (callStatus) =>
            nativeModule().ubrn_uniffi_xmtpv3_fn_free_fficonversationcallback(
              pointer,
              callStatus
            ),
          /*liftString:*/ FfiConverterString.lift
        );
      },

      isConcreteType(obj: any): obj is FfiConversationCallback {
        return (
          obj[destructorGuardSymbol] &&
          obj[uniffiTypeNameSymbol] === 'FfiConversationCallbackImpl'
        );
      },
    };
  })();
// FfiConverter for FfiConversationCallback
const FfiConverterTypeFfiConversationCallback =
  new FfiConverterObjectWithCallbacks(
    uniffiTypeFfiConversationCallbackImplObjectFactory
  );

// Add a vtavble for the callbacks that go in FfiConversationCallback.

// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceFfiConversationCallback: {
  vtable: UniffiVTableCallbackInterfaceFfiConversationCallback;
  register: () => void;
} = {
  // Create the VTable using a series of closures.
  // ts automatically converts these into C callback functions.
  vtable: {
    onConversation: (uniffiHandle: bigint, conversation: bigint) => {
      const uniffiMakeCall = (): void => {
        const jsCallback =
          FfiConverterTypeFfiConversationCallback.lift(uniffiHandle);
        return jsCallback.onConversation(
          FfiConverterTypeFfiConversation.lift(conversation)
        );
      };
      const uniffiResult = UniffiResult.ready<void>();
      const uniffiHandleSuccess = (obj: any) => {};
      const uniffiHandleError = (code: number, errBuf: UniffiByteArray) => {
        UniffiResult.writeError(uniffiResult, code, errBuf);
      };
      uniffiTraitInterfaceCall(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*lowerString:*/ FfiConverterString.lower
      );
      return uniffiResult;
    },
    onError: (uniffiHandle: bigint, error: Uint8Array) => {
      const uniffiMakeCall = (): void => {
        const jsCallback =
          FfiConverterTypeFfiConversationCallback.lift(uniffiHandle);
        return jsCallback.onError(
          FfiConverterTypeFfiSubscribeError.lift(error)
        );
      };
      const uniffiResult = UniffiResult.ready<void>();
      const uniffiHandleSuccess = (obj: any) => {};
      const uniffiHandleError = (code: number, errBuf: UniffiByteArray) => {
        UniffiResult.writeError(uniffiResult, code, errBuf);
      };
      uniffiTraitInterfaceCall(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*lowerString:*/ FfiConverterString.lower
      );
      return uniffiResult;
    },
    onClose: (uniffiHandle: bigint) => {
      const uniffiMakeCall = (): void => {
        const jsCallback =
          FfiConverterTypeFfiConversationCallback.lift(uniffiHandle);
        return jsCallback.onClose();
      };
      const uniffiResult = UniffiResult.ready<void>();
      const uniffiHandleSuccess = (obj: any) => {};
      const uniffiHandleError = (code: number, errBuf: UniffiByteArray) => {
        UniffiResult.writeError(uniffiResult, code, errBuf);
      };
      uniffiTraitInterfaceCall(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*lowerString:*/ FfiConverterString.lower
      );
      return uniffiResult;
    },
    uniffiFree: (uniffiHandle: UniffiHandle): void => {
      // FfiConversationCallback: this will throw a stale handle error if the handle isn't found.
      FfiConverterTypeFfiConversationCallback.drop(uniffiHandle);
    },
  },
  register: () => {
    nativeModule().ubrn_uniffi_xmtpv3_fn_init_callback_vtable_fficonversationcallback(
      uniffiCallbackInterfaceFfiConversationCallback.vtable
    );
  },
};

export interface FfiConversationListItemInterface {
  conversation(): FfiConversationInterface;
  isCommitLogForked(): boolean | undefined;
  lastMessage(): FfiMessage | undefined;
}

export class FfiConversationListItem
  extends UniffiAbstractObject
  implements FfiConversationListItemInterface
{
  readonly [uniffiTypeNameSymbol] = 'FfiConversationListItem';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeFfiConversationListItemObjectFactory.bless(pointer);
  }

  public conversation(): FfiConversationInterface {
    return FfiConverterTypeFfiConversation.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_xmtpv3_fn_method_fficonversationlistitem_conversation(
            uniffiTypeFfiConversationListItemObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public isCommitLogForked(): boolean | undefined {
    return FfiConverterOptionalBool.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_xmtpv3_fn_method_fficonversationlistitem_is_commit_log_forked(
            uniffiTypeFfiConversationListItemObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public lastMessage(): FfiMessage | undefined {
    return FfiConverterOptionalTypeFfiMessage.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_xmtpv3_fn_method_fficonversationlistitem_last_message(
            uniffiTypeFfiConversationListItemObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer =
        uniffiTypeFfiConversationListItemObjectFactory.pointer(this);
      uniffiTypeFfiConversationListItemObjectFactory.freePointer(pointer);
      uniffiTypeFfiConversationListItemObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is FfiConversationListItem {
    return uniffiTypeFfiConversationListItemObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeFfiConversationListItemObjectFactory: UniffiObjectFactory<FfiConversationListItemInterface> =
  (() => {
    return {
      create(
        pointer: UnsafeMutableRawPointer
      ): FfiConversationListItemInterface {
        const instance = Object.create(FfiConversationListItem.prototype);
        instance[pointerLiteralSymbol] = pointer;
        instance[destructorGuardSymbol] = this.bless(pointer);
        instance[uniffiTypeNameSymbol] = 'FfiConversationListItem';
        return instance;
      },

      bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
        return uniffiCaller.rustCall(
          /*caller:*/ (status) =>
            nativeModule().ubrn_uniffi_internal_fn_method_fficonversationlistitem_ffi__bless_pointer(
              p,
              status
            ),
          /*liftString:*/ FfiConverterString.lift
        );
      },

      unbless(ptr: UniffiRustArcPtr) {
        ptr.markDestroyed();
      },

      pointer(obj: FfiConversationListItemInterface): UnsafeMutableRawPointer {
        if ((obj as any)[destructorGuardSymbol] === undefined) {
          throw new UniffiInternalError.UnexpectedNullPointer();
        }
        return (obj as any)[pointerLiteralSymbol];
      },

      clonePointer(
        obj: FfiConversationListItemInterface
      ): UnsafeMutableRawPointer {
        const pointer = this.pointer(obj);
        return uniffiCaller.rustCall(
          /*caller:*/ (callStatus) =>
            nativeModule().ubrn_uniffi_xmtpv3_fn_clone_fficonversationlistitem(
              pointer,
              callStatus
            ),
          /*liftString:*/ FfiConverterString.lift
        );
      },

      freePointer(pointer: UnsafeMutableRawPointer): void {
        uniffiCaller.rustCall(
          /*caller:*/ (callStatus) =>
            nativeModule().ubrn_uniffi_xmtpv3_fn_free_fficonversationlistitem(
              pointer,
              callStatus
            ),
          /*liftString:*/ FfiConverterString.lift
        );
      },

      isConcreteType(obj: any): obj is FfiConversationListItemInterface {
        return (
          obj[destructorGuardSymbol] &&
          obj[uniffiTypeNameSymbol] === 'FfiConversationListItem'
        );
      },
    };
  })();
// FfiConverter for FfiConversationListItemInterface
const FfiConverterTypeFfiConversationListItem = new FfiConverterObject(
  uniffiTypeFfiConversationListItemObjectFactory
);

export interface FfiConversationMetadataInterface {
  conversationType(): FfiConversationType;
  creatorInboxId(): string;
}

export class FfiConversationMetadata
  extends UniffiAbstractObject
  implements FfiConversationMetadataInterface
{
  readonly [uniffiTypeNameSymbol] = 'FfiConversationMetadata';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeFfiConversationMetadataObjectFactory.bless(pointer);
  }

  public conversationType(): FfiConversationType {
    return FfiConverterTypeFfiConversationType.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_xmtpv3_fn_method_fficonversationmetadata_conversation_type(
            uniffiTypeFfiConversationMetadataObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public creatorInboxId(): string {
    return FfiConverterString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_xmtpv3_fn_method_fficonversationmetadata_creator_inbox_id(
            uniffiTypeFfiConversationMetadataObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer =
        uniffiTypeFfiConversationMetadataObjectFactory.pointer(this);
      uniffiTypeFfiConversationMetadataObjectFactory.freePointer(pointer);
      uniffiTypeFfiConversationMetadataObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is FfiConversationMetadata {
    return uniffiTypeFfiConversationMetadataObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeFfiConversationMetadataObjectFactory: UniffiObjectFactory<FfiConversationMetadataInterface> =
  (() => {
    return {
      create(
        pointer: UnsafeMutableRawPointer
      ): FfiConversationMetadataInterface {
        const instance = Object.create(FfiConversationMetadata.prototype);
        instance[pointerLiteralSymbol] = pointer;
        instance[destructorGuardSymbol] = this.bless(pointer);
        instance[uniffiTypeNameSymbol] = 'FfiConversationMetadata';
        return instance;
      },

      bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
        return uniffiCaller.rustCall(
          /*caller:*/ (status) =>
            nativeModule().ubrn_uniffi_internal_fn_method_fficonversationmetadata_ffi__bless_pointer(
              p,
              status
            ),
          /*liftString:*/ FfiConverterString.lift
        );
      },

      unbless(ptr: UniffiRustArcPtr) {
        ptr.markDestroyed();
      },

      pointer(obj: FfiConversationMetadataInterface): UnsafeMutableRawPointer {
        if ((obj as any)[destructorGuardSymbol] === undefined) {
          throw new UniffiInternalError.UnexpectedNullPointer();
        }
        return (obj as any)[pointerLiteralSymbol];
      },

      clonePointer(
        obj: FfiConversationMetadataInterface
      ): UnsafeMutableRawPointer {
        const pointer = this.pointer(obj);
        return uniffiCaller.rustCall(
          /*caller:*/ (callStatus) =>
            nativeModule().ubrn_uniffi_xmtpv3_fn_clone_fficonversationmetadata(
              pointer,
              callStatus
            ),
          /*liftString:*/ FfiConverterString.lift
        );
      },

      freePointer(pointer: UnsafeMutableRawPointer): void {
        uniffiCaller.rustCall(
          /*caller:*/ (callStatus) =>
            nativeModule().ubrn_uniffi_xmtpv3_fn_free_fficonversationmetadata(
              pointer,
              callStatus
            ),
          /*liftString:*/ FfiConverterString.lift
        );
      },

      isConcreteType(obj: any): obj is FfiConversationMetadataInterface {
        return (
          obj[destructorGuardSymbol] &&
          obj[uniffiTypeNameSymbol] === 'FfiConversationMetadata'
        );
      },
    };
  })();
// FfiConverter for FfiConversationMetadataInterface
const FfiConverterTypeFfiConversationMetadata = new FfiConverterObject(
  uniffiTypeFfiConversationMetadataObjectFactory
);

export interface FfiConversationsInterface {
  createGroup(
    accountIdentities: Array<FfiIdentifier>,
    opts: FfiCreateGroupOptions,
    asyncOpts_?: { signal: AbortSignal }
  ): /*throws*/ Promise<FfiConversationInterface>;
  createGroupOptimistic(
    opts: FfiCreateGroupOptions
  ): /*throws*/ FfiConversationInterface;
  createGroupWithInboxIds(
    inboxIds: Array<string>,
    opts: FfiCreateGroupOptions,
    asyncOpts_?: { signal: AbortSignal }
  ): /*throws*/ Promise<FfiConversationInterface>;
  findOrCreateDm(
    targetIdentity: FfiIdentifier,
    opts: FfiCreateDmOptions,
    asyncOpts_?: { signal: AbortSignal }
  ): /*throws*/ Promise<FfiConversationInterface>;
  findOrCreateDmByInboxId(
    inboxId: string,
    opts: FfiCreateDmOptions,
    asyncOpts_?: { signal: AbortSignal }
  ): /*throws*/ Promise<FfiConversationInterface>;
  getHmacKeys(): /*throws*/ Map<ArrayBuffer, Array<FfiHmacKey>>;
  list(
    opts: FfiListConversationsOptions
  ): /*throws*/ Array<FfiConversationListItemInterface>;
  listDms(
    opts: FfiListConversationsOptions
  ): /*throws*/ Array<FfiConversationListItemInterface>;
  listGroups(
    opts: FfiListConversationsOptions
  ): /*throws*/ Array<FfiConversationListItemInterface>;
  processStreamedWelcomeMessage(
    envelopeBytes: ArrayBuffer,
    asyncOpts_?: { signal: AbortSignal }
  ): /*throws*/ Promise<FfiConversationInterface>;
  stream(
    callback: FfiConversationCallback,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<FfiStreamCloserInterface>;
  streamAllDmMessages(
    messageCallback: FfiMessageCallback,
    consentStates: Array<FfiConsentState> | undefined,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<FfiStreamCloserInterface>;
  streamAllGroupMessages(
    messageCallback: FfiMessageCallback,
    consentStates: Array<FfiConsentState> | undefined,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<FfiStreamCloserInterface>;
  streamAllMessages(
    messageCallback: FfiMessageCallback,
    consentStates: Array<FfiConsentState> | undefined,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<FfiStreamCloserInterface>;
  /**
   * Get notified when there is a new consent update either locally or is synced from another device
   * allowing the user to re-render the new state appropriately
   */
  streamConsent(
    callback: FfiConsentCallback,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<FfiStreamCloserInterface>;
  streamDms(
    callback: FfiConversationCallback,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<FfiStreamCloserInterface>;
  streamGroups(
    callback: FfiConversationCallback,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<FfiStreamCloserInterface>;
  /**
   * Get notified when a message is deleted by the disappearing messages worker.
   * The callback receives the message ID of each deleted message.
   */
  streamMessageDeletions(
    callback: FfiMessageDeletionCallback,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<FfiStreamCloserInterface>;
  streamMessages(
    messageCallback: FfiMessageCallback,
    conversationType: FfiConversationType | undefined,
    consentStates: Array<FfiConsentState> | undefined,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<FfiStreamCloserInterface>;
  /**
   * Get notified when a preference changes either locally or is synced from another device
   * allowing the user to re-render the new state appropriately.
   */
  streamPreferences(
    callback: FfiPreferenceCallback,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<FfiStreamCloserInterface>;
  sync(asyncOpts_?: { signal: AbortSignal }): /*throws*/ Promise<void>;
  syncAllConversations(
    consentStates: Array<FfiConsentState> | undefined,
    asyncOpts_?: { signal: AbortSignal }
  ): /*throws*/ Promise<FfiGroupSyncSummary>;
}

export class FfiConversations
  extends UniffiAbstractObject
  implements FfiConversationsInterface
{
  readonly [uniffiTypeNameSymbol] = 'FfiConversations';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeFfiConversationsObjectFactory.bless(pointer);
  }

  public async createGroup(
    accountIdentities: Array<FfiIdentifier>,
    opts: FfiCreateGroupOptions,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<FfiConversationInterface> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_xmtpv3_fn_method_fficonversations_create_group(
            uniffiTypeFfiConversationsObjectFactory.clonePointer(this),
            FfiConverterArrayTypeFfiIdentifier.lower(accountIdentities),
            FfiConverterTypeFfiCreateGroupOptions.lower(opts)
          );
        },
        /*pollFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_poll_pointer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_cancel_pointer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_complete_pointer,
        /*freeFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_free_pointer,
        /*liftFunc:*/ FfiConverterTypeFfiConversation.lift.bind(
          FfiConverterTypeFfiConversation
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeGenericError.lift.bind(
          FfiConverterTypeGenericError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public createGroupOptimistic(
    opts: FfiCreateGroupOptions
  ): FfiConversationInterface /*throws*/ {
    return FfiConverterTypeFfiConversation.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeGenericError.lift.bind(
          FfiConverterTypeGenericError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_xmtpv3_fn_method_fficonversations_create_group_optimistic(
            uniffiTypeFfiConversationsObjectFactory.clonePointer(this),
            FfiConverterTypeFfiCreateGroupOptions.lower(opts),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public async createGroupWithInboxIds(
    inboxIds: Array<string>,
    opts: FfiCreateGroupOptions,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<FfiConversationInterface> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_xmtpv3_fn_method_fficonversations_create_group_with_inbox_ids(
            uniffiTypeFfiConversationsObjectFactory.clonePointer(this),
            FfiConverterArrayString.lower(inboxIds),
            FfiConverterTypeFfiCreateGroupOptions.lower(opts)
          );
        },
        /*pollFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_poll_pointer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_cancel_pointer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_complete_pointer,
        /*freeFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_free_pointer,
        /*liftFunc:*/ FfiConverterTypeFfiConversation.lift.bind(
          FfiConverterTypeFfiConversation
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeGenericError.lift.bind(
          FfiConverterTypeGenericError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async findOrCreateDm(
    targetIdentity: FfiIdentifier,
    opts: FfiCreateDmOptions,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<FfiConversationInterface> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_xmtpv3_fn_method_fficonversations_find_or_create_dm(
            uniffiTypeFfiConversationsObjectFactory.clonePointer(this),
            FfiConverterTypeFfiIdentifier.lower(targetIdentity),
            FfiConverterTypeFfiCreateDMOptions.lower(opts)
          );
        },
        /*pollFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_poll_pointer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_cancel_pointer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_complete_pointer,
        /*freeFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_free_pointer,
        /*liftFunc:*/ FfiConverterTypeFfiConversation.lift.bind(
          FfiConverterTypeFfiConversation
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeGenericError.lift.bind(
          FfiConverterTypeGenericError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async findOrCreateDmByInboxId(
    inboxId: string,
    opts: FfiCreateDmOptions,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<FfiConversationInterface> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_xmtpv3_fn_method_fficonversations_find_or_create_dm_by_inbox_id(
            uniffiTypeFfiConversationsObjectFactory.clonePointer(this),
            FfiConverterString.lower(inboxId),
            FfiConverterTypeFfiCreateDMOptions.lower(opts)
          );
        },
        /*pollFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_poll_pointer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_cancel_pointer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_complete_pointer,
        /*freeFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_free_pointer,
        /*liftFunc:*/ FfiConverterTypeFfiConversation.lift.bind(
          FfiConverterTypeFfiConversation
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeGenericError.lift.bind(
          FfiConverterTypeGenericError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public getHmacKeys(): Map<ArrayBuffer, Array<FfiHmacKey>> /*throws*/ {
    return FfiConverterMapArrayBufferArrayTypeFfiHmacKey.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeGenericError.lift.bind(
          FfiConverterTypeGenericError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_xmtpv3_fn_method_fficonversations_get_hmac_keys(
            uniffiTypeFfiConversationsObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public list(
    opts: FfiListConversationsOptions
  ): Array<FfiConversationListItemInterface> /*throws*/ {
    return FfiConverterArrayTypeFfiConversationListItem.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeGenericError.lift.bind(
          FfiConverterTypeGenericError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_xmtpv3_fn_method_fficonversations_list(
            uniffiTypeFfiConversationsObjectFactory.clonePointer(this),
            FfiConverterTypeFfiListConversationsOptions.lower(opts),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public listDms(
    opts: FfiListConversationsOptions
  ): Array<FfiConversationListItemInterface> /*throws*/ {
    return FfiConverterArrayTypeFfiConversationListItem.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeGenericError.lift.bind(
          FfiConverterTypeGenericError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_xmtpv3_fn_method_fficonversations_list_dms(
            uniffiTypeFfiConversationsObjectFactory.clonePointer(this),
            FfiConverterTypeFfiListConversationsOptions.lower(opts),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public listGroups(
    opts: FfiListConversationsOptions
  ): Array<FfiConversationListItemInterface> /*throws*/ {
    return FfiConverterArrayTypeFfiConversationListItem.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeGenericError.lift.bind(
          FfiConverterTypeGenericError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_xmtpv3_fn_method_fficonversations_list_groups(
            uniffiTypeFfiConversationsObjectFactory.clonePointer(this),
            FfiConverterTypeFfiListConversationsOptions.lower(opts),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public async processStreamedWelcomeMessage(
    envelopeBytes: ArrayBuffer,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<FfiConversationInterface> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_xmtpv3_fn_method_fficonversations_process_streamed_welcome_message(
            uniffiTypeFfiConversationsObjectFactory.clonePointer(this),
            FfiConverterArrayBuffer.lower(envelopeBytes)
          );
        },
        /*pollFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_poll_pointer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_cancel_pointer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_complete_pointer,
        /*freeFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_free_pointer,
        /*liftFunc:*/ FfiConverterTypeFfiConversation.lift.bind(
          FfiConverterTypeFfiConversation
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeGenericError.lift.bind(
          FfiConverterTypeGenericError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async stream(
    callback: FfiConversationCallback,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<FfiStreamCloserInterface> {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_xmtpv3_fn_method_fficonversations_stream(
            uniffiTypeFfiConversationsObjectFactory.clonePointer(this),
            FfiConverterTypeFfiConversationCallback.lower(callback)
          );
        },
        /*pollFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_poll_pointer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_cancel_pointer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_complete_pointer,
        /*freeFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_free_pointer,
        /*liftFunc:*/ FfiConverterTypeFfiStreamCloser.lift.bind(
          FfiConverterTypeFfiStreamCloser
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async streamAllDmMessages(
    messageCallback: FfiMessageCallback,
    consentStates: Array<FfiConsentState> | undefined,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<FfiStreamCloserInterface> {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_xmtpv3_fn_method_fficonversations_stream_all_dm_messages(
            uniffiTypeFfiConversationsObjectFactory.clonePointer(this),
            FfiConverterTypeFfiMessageCallback.lower(messageCallback),
            FfiConverterOptionalArrayTypeFfiConsentState.lower(consentStates)
          );
        },
        /*pollFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_poll_pointer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_cancel_pointer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_complete_pointer,
        /*freeFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_free_pointer,
        /*liftFunc:*/ FfiConverterTypeFfiStreamCloser.lift.bind(
          FfiConverterTypeFfiStreamCloser
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async streamAllGroupMessages(
    messageCallback: FfiMessageCallback,
    consentStates: Array<FfiConsentState> | undefined,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<FfiStreamCloserInterface> {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_xmtpv3_fn_method_fficonversations_stream_all_group_messages(
            uniffiTypeFfiConversationsObjectFactory.clonePointer(this),
            FfiConverterTypeFfiMessageCallback.lower(messageCallback),
            FfiConverterOptionalArrayTypeFfiConsentState.lower(consentStates)
          );
        },
        /*pollFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_poll_pointer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_cancel_pointer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_complete_pointer,
        /*freeFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_free_pointer,
        /*liftFunc:*/ FfiConverterTypeFfiStreamCloser.lift.bind(
          FfiConverterTypeFfiStreamCloser
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async streamAllMessages(
    messageCallback: FfiMessageCallback,
    consentStates: Array<FfiConsentState> | undefined,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<FfiStreamCloserInterface> {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_xmtpv3_fn_method_fficonversations_stream_all_messages(
            uniffiTypeFfiConversationsObjectFactory.clonePointer(this),
            FfiConverterTypeFfiMessageCallback.lower(messageCallback),
            FfiConverterOptionalArrayTypeFfiConsentState.lower(consentStates)
          );
        },
        /*pollFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_poll_pointer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_cancel_pointer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_complete_pointer,
        /*freeFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_free_pointer,
        /*liftFunc:*/ FfiConverterTypeFfiStreamCloser.lift.bind(
          FfiConverterTypeFfiStreamCloser
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Get notified when there is a new consent update either locally or is synced from another device
   * allowing the user to re-render the new state appropriately
   */
  public async streamConsent(
    callback: FfiConsentCallback,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<FfiStreamCloserInterface> {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_xmtpv3_fn_method_fficonversations_stream_consent(
            uniffiTypeFfiConversationsObjectFactory.clonePointer(this),
            FfiConverterTypeFfiConsentCallback.lower(callback)
          );
        },
        /*pollFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_poll_pointer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_cancel_pointer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_complete_pointer,
        /*freeFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_free_pointer,
        /*liftFunc:*/ FfiConverterTypeFfiStreamCloser.lift.bind(
          FfiConverterTypeFfiStreamCloser
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async streamDms(
    callback: FfiConversationCallback,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<FfiStreamCloserInterface> {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_xmtpv3_fn_method_fficonversations_stream_dms(
            uniffiTypeFfiConversationsObjectFactory.clonePointer(this),
            FfiConverterTypeFfiConversationCallback.lower(callback)
          );
        },
        /*pollFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_poll_pointer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_cancel_pointer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_complete_pointer,
        /*freeFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_free_pointer,
        /*liftFunc:*/ FfiConverterTypeFfiStreamCloser.lift.bind(
          FfiConverterTypeFfiStreamCloser
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async streamGroups(
    callback: FfiConversationCallback,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<FfiStreamCloserInterface> {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_xmtpv3_fn_method_fficonversations_stream_groups(
            uniffiTypeFfiConversationsObjectFactory.clonePointer(this),
            FfiConverterTypeFfiConversationCallback.lower(callback)
          );
        },
        /*pollFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_poll_pointer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_cancel_pointer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_complete_pointer,
        /*freeFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_free_pointer,
        /*liftFunc:*/ FfiConverterTypeFfiStreamCloser.lift.bind(
          FfiConverterTypeFfiStreamCloser
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Get notified when a message is deleted by the disappearing messages worker.
   * The callback receives the message ID of each deleted message.
   */
  public async streamMessageDeletions(
    callback: FfiMessageDeletionCallback,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<FfiStreamCloserInterface> {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_xmtpv3_fn_method_fficonversations_stream_message_deletions(
            uniffiTypeFfiConversationsObjectFactory.clonePointer(this),
            FfiConverterTypeFfiMessageDeletionCallback.lower(callback)
          );
        },
        /*pollFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_poll_pointer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_cancel_pointer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_complete_pointer,
        /*freeFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_free_pointer,
        /*liftFunc:*/ FfiConverterTypeFfiStreamCloser.lift.bind(
          FfiConverterTypeFfiStreamCloser
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async streamMessages(
    messageCallback: FfiMessageCallback,
    conversationType: FfiConversationType | undefined,
    consentStates: Array<FfiConsentState> | undefined,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<FfiStreamCloserInterface> {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_xmtpv3_fn_method_fficonversations_stream_messages(
            uniffiTypeFfiConversationsObjectFactory.clonePointer(this),
            FfiConverterTypeFfiMessageCallback.lower(messageCallback),
            FfiConverterOptionalTypeFfiConversationType.lower(conversationType),
            FfiConverterOptionalArrayTypeFfiConsentState.lower(consentStates)
          );
        },
        /*pollFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_poll_pointer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_cancel_pointer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_complete_pointer,
        /*freeFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_free_pointer,
        /*liftFunc:*/ FfiConverterTypeFfiStreamCloser.lift.bind(
          FfiConverterTypeFfiStreamCloser
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Get notified when a preference changes either locally or is synced from another device
   * allowing the user to re-render the new state appropriately.
   */
  public async streamPreferences(
    callback: FfiPreferenceCallback,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<FfiStreamCloserInterface> {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_xmtpv3_fn_method_fficonversations_stream_preferences(
            uniffiTypeFfiConversationsObjectFactory.clonePointer(this),
            FfiConverterTypeFfiPreferenceCallback.lower(callback)
          );
        },
        /*pollFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_poll_pointer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_cancel_pointer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_complete_pointer,
        /*freeFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_free_pointer,
        /*liftFunc:*/ FfiConverterTypeFfiStreamCloser.lift.bind(
          FfiConverterTypeFfiStreamCloser
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async sync(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_xmtpv3_fn_method_fficonversations_sync(
            uniffiTypeFfiConversationsObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_complete_void,
        /*freeFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeGenericError.lift.bind(
          FfiConverterTypeGenericError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async syncAllConversations(
    consentStates: Array<FfiConsentState> | undefined,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<FfiGroupSyncSummary> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_xmtpv3_fn_method_fficonversations_sync_all_conversations(
            uniffiTypeFfiConversationsObjectFactory.clonePointer(this),
            FfiConverterOptionalArrayTypeFfiConsentState.lower(consentStates)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterTypeFfiGroupSyncSummary.lift.bind(
          FfiConverterTypeFfiGroupSyncSummary
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeGenericError.lift.bind(
          FfiConverterTypeGenericError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeFfiConversationsObjectFactory.pointer(this);
      uniffiTypeFfiConversationsObjectFactory.freePointer(pointer);
      uniffiTypeFfiConversationsObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is FfiConversations {
    return uniffiTypeFfiConversationsObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeFfiConversationsObjectFactory: UniffiObjectFactory<FfiConversationsInterface> =
  (() => {
    return {
      create(pointer: UnsafeMutableRawPointer): FfiConversationsInterface {
        const instance = Object.create(FfiConversations.prototype);
        instance[pointerLiteralSymbol] = pointer;
        instance[destructorGuardSymbol] = this.bless(pointer);
        instance[uniffiTypeNameSymbol] = 'FfiConversations';
        return instance;
      },

      bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
        return uniffiCaller.rustCall(
          /*caller:*/ (status) =>
            nativeModule().ubrn_uniffi_internal_fn_method_fficonversations_ffi__bless_pointer(
              p,
              status
            ),
          /*liftString:*/ FfiConverterString.lift
        );
      },

      unbless(ptr: UniffiRustArcPtr) {
        ptr.markDestroyed();
      },

      pointer(obj: FfiConversationsInterface): UnsafeMutableRawPointer {
        if ((obj as any)[destructorGuardSymbol] === undefined) {
          throw new UniffiInternalError.UnexpectedNullPointer();
        }
        return (obj as any)[pointerLiteralSymbol];
      },

      clonePointer(obj: FfiConversationsInterface): UnsafeMutableRawPointer {
        const pointer = this.pointer(obj);
        return uniffiCaller.rustCall(
          /*caller:*/ (callStatus) =>
            nativeModule().ubrn_uniffi_xmtpv3_fn_clone_fficonversations(
              pointer,
              callStatus
            ),
          /*liftString:*/ FfiConverterString.lift
        );
      },

      freePointer(pointer: UnsafeMutableRawPointer): void {
        uniffiCaller.rustCall(
          /*caller:*/ (callStatus) =>
            nativeModule().ubrn_uniffi_xmtpv3_fn_free_fficonversations(
              pointer,
              callStatus
            ),
          /*liftString:*/ FfiConverterString.lift
        );
      },

      isConcreteType(obj: any): obj is FfiConversationsInterface {
        return (
          obj[destructorGuardSymbol] &&
          obj[uniffiTypeNameSymbol] === 'FfiConversations'
        );
      },
    };
  })();
// FfiConverter for FfiConversationsInterface
const FfiConverterTypeFfiConversations = new FfiConverterObject(
  uniffiTypeFfiConversationsObjectFactory
);

export interface FfiDecodedMessageInterface {
  content(): FfiDecodedMessageContent;
  contentTypeId(): FfiContentTypeId;
  conversationId(): ArrayBuffer;
  deliveryStatus(): FfiDeliveryStatus;
  fallbackText(): string | undefined;
  hasReactions(): boolean;
  id(): ArrayBuffer;
  insertedAtNs(): /*i64*/ bigint;
  kind(): FfiGroupMessageKind;
  numReplies(): /*u64*/ bigint;
  reactionCount(): /*u64*/ bigint;
  reactions(): Array<FfiDecodedMessageInterface>;
  senderInboxId(): string;
  senderInstallationId(): ArrayBuffer;
  sentAtNs(): /*i64*/ bigint;
}

export class FfiDecodedMessage
  extends UniffiAbstractObject
  implements FfiDecodedMessageInterface
{
  readonly [uniffiTypeNameSymbol] = 'FfiDecodedMessage';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeFfiDecodedMessageObjectFactory.bless(pointer);
  }

  public content(): FfiDecodedMessageContent {
    return FfiConverterTypeFfiDecodedMessageContent.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_xmtpv3_fn_method_ffidecodedmessage_content(
            uniffiTypeFfiDecodedMessageObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public contentTypeId(): FfiContentTypeId {
    return FfiConverterTypeFfiContentTypeId.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_xmtpv3_fn_method_ffidecodedmessage_content_type_id(
            uniffiTypeFfiDecodedMessageObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public conversationId(): ArrayBuffer {
    return FfiConverterArrayBuffer.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_xmtpv3_fn_method_ffidecodedmessage_conversation_id(
            uniffiTypeFfiDecodedMessageObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public deliveryStatus(): FfiDeliveryStatus {
    return FfiConverterTypeFfiDeliveryStatus.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_xmtpv3_fn_method_ffidecodedmessage_delivery_status(
            uniffiTypeFfiDecodedMessageObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public fallbackText(): string | undefined {
    return FfiConverterOptionalString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_xmtpv3_fn_method_ffidecodedmessage_fallback_text(
            uniffiTypeFfiDecodedMessageObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public hasReactions(): boolean {
    return FfiConverterBool.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_xmtpv3_fn_method_ffidecodedmessage_has_reactions(
            uniffiTypeFfiDecodedMessageObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public id(): ArrayBuffer {
    return FfiConverterArrayBuffer.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_xmtpv3_fn_method_ffidecodedmessage_id(
            uniffiTypeFfiDecodedMessageObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public insertedAtNs(): /*i64*/ bigint {
    return FfiConverterInt64.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_xmtpv3_fn_method_ffidecodedmessage_inserted_at_ns(
            uniffiTypeFfiDecodedMessageObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public kind(): FfiGroupMessageKind {
    return FfiConverterTypeFfiGroupMessageKind.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_xmtpv3_fn_method_ffidecodedmessage_kind(
            uniffiTypeFfiDecodedMessageObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public numReplies(): /*u64*/ bigint {
    return FfiConverterUInt64.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_xmtpv3_fn_method_ffidecodedmessage_num_replies(
            uniffiTypeFfiDecodedMessageObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public reactionCount(): /*u64*/ bigint {
    return FfiConverterUInt64.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_xmtpv3_fn_method_ffidecodedmessage_reaction_count(
            uniffiTypeFfiDecodedMessageObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public reactions(): Array<FfiDecodedMessageInterface> {
    return FfiConverterArrayTypeFfiDecodedMessage.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_xmtpv3_fn_method_ffidecodedmessage_reactions(
            uniffiTypeFfiDecodedMessageObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public senderInboxId(): string {
    return FfiConverterString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_xmtpv3_fn_method_ffidecodedmessage_sender_inbox_id(
            uniffiTypeFfiDecodedMessageObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public senderInstallationId(): ArrayBuffer {
    return FfiConverterArrayBuffer.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_xmtpv3_fn_method_ffidecodedmessage_sender_installation_id(
            uniffiTypeFfiDecodedMessageObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public sentAtNs(): /*i64*/ bigint {
    return FfiConverterInt64.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_xmtpv3_fn_method_ffidecodedmessage_sent_at_ns(
            uniffiTypeFfiDecodedMessageObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeFfiDecodedMessageObjectFactory.pointer(this);
      uniffiTypeFfiDecodedMessageObjectFactory.freePointer(pointer);
      uniffiTypeFfiDecodedMessageObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is FfiDecodedMessage {
    return uniffiTypeFfiDecodedMessageObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeFfiDecodedMessageObjectFactory: UniffiObjectFactory<FfiDecodedMessageInterface> =
  (() => {
    return {
      create(pointer: UnsafeMutableRawPointer): FfiDecodedMessageInterface {
        const instance = Object.create(FfiDecodedMessage.prototype);
        instance[pointerLiteralSymbol] = pointer;
        instance[destructorGuardSymbol] = this.bless(pointer);
        instance[uniffiTypeNameSymbol] = 'FfiDecodedMessage';
        return instance;
      },

      bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
        return uniffiCaller.rustCall(
          /*caller:*/ (status) =>
            nativeModule().ubrn_uniffi_internal_fn_method_ffidecodedmessage_ffi__bless_pointer(
              p,
              status
            ),
          /*liftString:*/ FfiConverterString.lift
        );
      },

      unbless(ptr: UniffiRustArcPtr) {
        ptr.markDestroyed();
      },

      pointer(obj: FfiDecodedMessageInterface): UnsafeMutableRawPointer {
        if ((obj as any)[destructorGuardSymbol] === undefined) {
          throw new UniffiInternalError.UnexpectedNullPointer();
        }
        return (obj as any)[pointerLiteralSymbol];
      },

      clonePointer(obj: FfiDecodedMessageInterface): UnsafeMutableRawPointer {
        const pointer = this.pointer(obj);
        return uniffiCaller.rustCall(
          /*caller:*/ (callStatus) =>
            nativeModule().ubrn_uniffi_xmtpv3_fn_clone_ffidecodedmessage(
              pointer,
              callStatus
            ),
          /*liftString:*/ FfiConverterString.lift
        );
      },

      freePointer(pointer: UnsafeMutableRawPointer): void {
        uniffiCaller.rustCall(
          /*caller:*/ (callStatus) =>
            nativeModule().ubrn_uniffi_xmtpv3_fn_free_ffidecodedmessage(
              pointer,
              callStatus
            ),
          /*liftString:*/ FfiConverterString.lift
        );
      },

      isConcreteType(obj: any): obj is FfiDecodedMessageInterface {
        return (
          obj[destructorGuardSymbol] &&
          obj[uniffiTypeNameSymbol] === 'FfiDecodedMessage'
        );
      },
    };
  })();
// FfiConverter for FfiDecodedMessageInterface
const FfiConverterTypeFfiDecodedMessage = new FfiConverterObject(
  uniffiTypeFfiDecodedMessageObjectFactory
);

export interface FfiGroupPermissionsInterface {
  policySet(): /*throws*/ FfiPermissionPolicySet;
  policyType(): /*throws*/ FfiGroupPermissionsOptions;
}

export class FfiGroupPermissions
  extends UniffiAbstractObject
  implements FfiGroupPermissionsInterface
{
  readonly [uniffiTypeNameSymbol] = 'FfiGroupPermissions';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeFfiGroupPermissionsObjectFactory.bless(pointer);
  }

  public policySet(): FfiPermissionPolicySet /*throws*/ {
    return FfiConverterTypeFfiPermissionPolicySet.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeGenericError.lift.bind(
          FfiConverterTypeGenericError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_xmtpv3_fn_method_ffigrouppermissions_policy_set(
            uniffiTypeFfiGroupPermissionsObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public policyType(): FfiGroupPermissionsOptions /*throws*/ {
    return FfiConverterTypeFfiGroupPermissionsOptions.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeGenericError.lift.bind(
          FfiConverterTypeGenericError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_xmtpv3_fn_method_ffigrouppermissions_policy_type(
            uniffiTypeFfiGroupPermissionsObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeFfiGroupPermissionsObjectFactory.pointer(this);
      uniffiTypeFfiGroupPermissionsObjectFactory.freePointer(pointer);
      uniffiTypeFfiGroupPermissionsObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is FfiGroupPermissions {
    return uniffiTypeFfiGroupPermissionsObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeFfiGroupPermissionsObjectFactory: UniffiObjectFactory<FfiGroupPermissionsInterface> =
  (() => {
    return {
      create(pointer: UnsafeMutableRawPointer): FfiGroupPermissionsInterface {
        const instance = Object.create(FfiGroupPermissions.prototype);
        instance[pointerLiteralSymbol] = pointer;
        instance[destructorGuardSymbol] = this.bless(pointer);
        instance[uniffiTypeNameSymbol] = 'FfiGroupPermissions';
        return instance;
      },

      bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
        return uniffiCaller.rustCall(
          /*caller:*/ (status) =>
            nativeModule().ubrn_uniffi_internal_fn_method_ffigrouppermissions_ffi__bless_pointer(
              p,
              status
            ),
          /*liftString:*/ FfiConverterString.lift
        );
      },

      unbless(ptr: UniffiRustArcPtr) {
        ptr.markDestroyed();
      },

      pointer(obj: FfiGroupPermissionsInterface): UnsafeMutableRawPointer {
        if ((obj as any)[destructorGuardSymbol] === undefined) {
          throw new UniffiInternalError.UnexpectedNullPointer();
        }
        return (obj as any)[pointerLiteralSymbol];
      },

      clonePointer(obj: FfiGroupPermissionsInterface): UnsafeMutableRawPointer {
        const pointer = this.pointer(obj);
        return uniffiCaller.rustCall(
          /*caller:*/ (callStatus) =>
            nativeModule().ubrn_uniffi_xmtpv3_fn_clone_ffigrouppermissions(
              pointer,
              callStatus
            ),
          /*liftString:*/ FfiConverterString.lift
        );
      },

      freePointer(pointer: UnsafeMutableRawPointer): void {
        uniffiCaller.rustCall(
          /*caller:*/ (callStatus) =>
            nativeModule().ubrn_uniffi_xmtpv3_fn_free_ffigrouppermissions(
              pointer,
              callStatus
            ),
          /*liftString:*/ FfiConverterString.lift
        );
      },

      isConcreteType(obj: any): obj is FfiGroupPermissionsInterface {
        return (
          obj[destructorGuardSymbol] &&
          obj[uniffiTypeNameSymbol] === 'FfiGroupPermissions'
        );
      },
    };
  })();
// FfiConverter for FfiGroupPermissionsInterface
const FfiConverterTypeFfiGroupPermissions = new FfiConverterObject(
  uniffiTypeFfiGroupPermissionsObjectFactory
);

export interface FfiInboxOwner {
  getIdentifier(): /*throws*/ FfiIdentifier;
  sign(text: string): /*throws*/ ArrayBuffer;
}

export class FfiInboxOwnerImpl
  extends UniffiAbstractObject
  implements FfiInboxOwner
{
  readonly [uniffiTypeNameSymbol] = 'FfiInboxOwnerImpl';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeFfiInboxOwnerImplObjectFactory.bless(pointer);
  }

  public getIdentifier(): FfiIdentifier /*throws*/ {
    return FfiConverterTypeFfiIdentifier.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeIdentityValidationError.lift.bind(
          FfiConverterTypeIdentityValidationError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_xmtpv3_fn_method_ffiinboxowner_get_identifier(
            uniffiTypeFfiInboxOwnerImplObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public sign(text: string): ArrayBuffer /*throws*/ {
    return FfiConverterArrayBuffer.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeSigningError.lift.bind(
          FfiConverterTypeSigningError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_xmtpv3_fn_method_ffiinboxowner_sign(
            uniffiTypeFfiInboxOwnerImplObjectFactory.clonePointer(this),
            FfiConverterString.lower(text),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeFfiInboxOwnerImplObjectFactory.pointer(this);
      uniffiTypeFfiInboxOwnerImplObjectFactory.freePointer(pointer);
      uniffiTypeFfiInboxOwnerImplObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is FfiInboxOwnerImpl {
    return uniffiTypeFfiInboxOwnerImplObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeFfiInboxOwnerImplObjectFactory: UniffiObjectFactory<FfiInboxOwner> =
  (() => {
    return {
      create(pointer: UnsafeMutableRawPointer): FfiInboxOwner {
        const instance = Object.create(FfiInboxOwnerImpl.prototype);
        instance[pointerLiteralSymbol] = pointer;
        instance[destructorGuardSymbol] = this.bless(pointer);
        instance[uniffiTypeNameSymbol] = 'FfiInboxOwnerImpl';
        return instance;
      },

      bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
        return uniffiCaller.rustCall(
          /*caller:*/ (status) =>
            nativeModule().ubrn_uniffi_internal_fn_method_ffiinboxowner_ffi__bless_pointer(
              p,
              status
            ),
          /*liftString:*/ FfiConverterString.lift
        );
      },

      unbless(ptr: UniffiRustArcPtr) {
        ptr.markDestroyed();
      },

      pointer(obj: FfiInboxOwner): UnsafeMutableRawPointer {
        if ((obj as any)[destructorGuardSymbol] === undefined) {
          throw new UniffiInternalError.UnexpectedNullPointer();
        }
        return (obj as any)[pointerLiteralSymbol];
      },

      clonePointer(obj: FfiInboxOwner): UnsafeMutableRawPointer {
        const pointer = this.pointer(obj);
        return uniffiCaller.rustCall(
          /*caller:*/ (callStatus) =>
            nativeModule().ubrn_uniffi_xmtpv3_fn_clone_ffiinboxowner(
              pointer,
              callStatus
            ),
          /*liftString:*/ FfiConverterString.lift
        );
      },

      freePointer(pointer: UnsafeMutableRawPointer): void {
        uniffiCaller.rustCall(
          /*caller:*/ (callStatus) =>
            nativeModule().ubrn_uniffi_xmtpv3_fn_free_ffiinboxowner(
              pointer,
              callStatus
            ),
          /*liftString:*/ FfiConverterString.lift
        );
      },

      isConcreteType(obj: any): obj is FfiInboxOwner {
        return (
          obj[destructorGuardSymbol] &&
          obj[uniffiTypeNameSymbol] === 'FfiInboxOwnerImpl'
        );
      },
    };
  })();
// FfiConverter for FfiInboxOwner
const FfiConverterTypeFfiInboxOwner = new FfiConverterObjectWithCallbacks(
  uniffiTypeFfiInboxOwnerImplObjectFactory
);

// Add a vtavble for the callbacks that go in FfiInboxOwner.

// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceFfiInboxOwner: {
  vtable: UniffiVTableCallbackInterfaceFfiInboxOwner;
  register: () => void;
} = {
  // Create the VTable using a series of closures.
  // ts automatically converts these into C callback functions.
  vtable: {
    getIdentifier: (uniffiHandle: bigint) => {
      const uniffiMakeCall = (): FfiIdentifier => {
        const jsCallback = FfiConverterTypeFfiInboxOwner.lift(uniffiHandle);
        return jsCallback.getIdentifier();
      };
      const uniffiResult = UniffiResult.ready<Uint8Array>();
      const uniffiHandleSuccess = (obj: any) => {
        UniffiResult.writeSuccess(
          uniffiResult,
          FfiConverterTypeFfiIdentifier.lower(obj)
        );
      };
      const uniffiHandleError = (code: number, errBuf: UniffiByteArray) => {
        UniffiResult.writeError(uniffiResult, code, errBuf);
      };
      uniffiTraitInterfaceCallWithError(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*isErrorType:*/ IdentityValidationError.instanceOf,
        /*lowerError:*/ FfiConverterTypeIdentityValidationError.lower.bind(
          FfiConverterTypeIdentityValidationError
        ),
        /*lowerString:*/ FfiConverterString.lower
      );
      return uniffiResult;
    },
    sign: (uniffiHandle: bigint, text: Uint8Array) => {
      const uniffiMakeCall = (): ArrayBuffer => {
        const jsCallback = FfiConverterTypeFfiInboxOwner.lift(uniffiHandle);
        return jsCallback.sign(FfiConverterString.lift(text));
      };
      const uniffiResult = UniffiResult.ready<Uint8Array>();
      const uniffiHandleSuccess = (obj: any) => {
        UniffiResult.writeSuccess(
          uniffiResult,
          FfiConverterArrayBuffer.lower(obj)
        );
      };
      const uniffiHandleError = (code: number, errBuf: UniffiByteArray) => {
        UniffiResult.writeError(uniffiResult, code, errBuf);
      };
      uniffiTraitInterfaceCallWithError(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*isErrorType:*/ SigningError.instanceOf,
        /*lowerError:*/ FfiConverterTypeSigningError.lower.bind(
          FfiConverterTypeSigningError
        ),
        /*lowerString:*/ FfiConverterString.lower
      );
      return uniffiResult;
    },
    uniffiFree: (uniffiHandle: UniffiHandle): void => {
      // FfiInboxOwner: this will throw a stale handle error if the handle isn't found.
      FfiConverterTypeFfiInboxOwner.drop(uniffiHandle);
    },
  },
  register: () => {
    nativeModule().ubrn_uniffi_xmtpv3_fn_init_callback_vtable_ffiinboxowner(
      uniffiCallbackInterfaceFfiInboxOwner.vtable
    );
  },
};

export interface FfiMessageCallback {
  onMessage(message: FfiMessage): void;
  onError(error: FfiSubscribeError): void;
  onClose(): void;
}

export class FfiMessageCallbackImpl
  extends UniffiAbstractObject
  implements FfiMessageCallback
{
  readonly [uniffiTypeNameSymbol] = 'FfiMessageCallbackImpl';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeFfiMessageCallbackImplObjectFactory.bless(pointer);
  }

  public onMessage(message: FfiMessage): void {
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_xmtpv3_fn_method_ffimessagecallback_on_message(
          uniffiTypeFfiMessageCallbackImplObjectFactory.clonePointer(this),
          FfiConverterTypeFfiMessage.lower(message),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  public onError(error: FfiSubscribeError): void {
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_xmtpv3_fn_method_ffimessagecallback_on_error(
          uniffiTypeFfiMessageCallbackImplObjectFactory.clonePointer(this),
          FfiConverterTypeFfiSubscribeError.lower(error),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  public onClose(): void {
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_xmtpv3_fn_method_ffimessagecallback_on_close(
          uniffiTypeFfiMessageCallbackImplObjectFactory.clonePointer(this),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer =
        uniffiTypeFfiMessageCallbackImplObjectFactory.pointer(this);
      uniffiTypeFfiMessageCallbackImplObjectFactory.freePointer(pointer);
      uniffiTypeFfiMessageCallbackImplObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is FfiMessageCallbackImpl {
    return uniffiTypeFfiMessageCallbackImplObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeFfiMessageCallbackImplObjectFactory: UniffiObjectFactory<FfiMessageCallback> =
  (() => {
    return {
      create(pointer: UnsafeMutableRawPointer): FfiMessageCallback {
        const instance = Object.create(FfiMessageCallbackImpl.prototype);
        instance[pointerLiteralSymbol] = pointer;
        instance[destructorGuardSymbol] = this.bless(pointer);
        instance[uniffiTypeNameSymbol] = 'FfiMessageCallbackImpl';
        return instance;
      },

      bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
        return uniffiCaller.rustCall(
          /*caller:*/ (status) =>
            nativeModule().ubrn_uniffi_internal_fn_method_ffimessagecallback_ffi__bless_pointer(
              p,
              status
            ),
          /*liftString:*/ FfiConverterString.lift
        );
      },

      unbless(ptr: UniffiRustArcPtr) {
        ptr.markDestroyed();
      },

      pointer(obj: FfiMessageCallback): UnsafeMutableRawPointer {
        if ((obj as any)[destructorGuardSymbol] === undefined) {
          throw new UniffiInternalError.UnexpectedNullPointer();
        }
        return (obj as any)[pointerLiteralSymbol];
      },

      clonePointer(obj: FfiMessageCallback): UnsafeMutableRawPointer {
        const pointer = this.pointer(obj);
        return uniffiCaller.rustCall(
          /*caller:*/ (callStatus) =>
            nativeModule().ubrn_uniffi_xmtpv3_fn_clone_ffimessagecallback(
              pointer,
              callStatus
            ),
          /*liftString:*/ FfiConverterString.lift
        );
      },

      freePointer(pointer: UnsafeMutableRawPointer): void {
        uniffiCaller.rustCall(
          /*caller:*/ (callStatus) =>
            nativeModule().ubrn_uniffi_xmtpv3_fn_free_ffimessagecallback(
              pointer,
              callStatus
            ),
          /*liftString:*/ FfiConverterString.lift
        );
      },

      isConcreteType(obj: any): obj is FfiMessageCallback {
        return (
          obj[destructorGuardSymbol] &&
          obj[uniffiTypeNameSymbol] === 'FfiMessageCallbackImpl'
        );
      },
    };
  })();
// FfiConverter for FfiMessageCallback
const FfiConverterTypeFfiMessageCallback = new FfiConverterObjectWithCallbacks(
  uniffiTypeFfiMessageCallbackImplObjectFactory
);

// Add a vtavble for the callbacks that go in FfiMessageCallback.

// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceFfiMessageCallback: {
  vtable: UniffiVTableCallbackInterfaceFfiMessageCallback;
  register: () => void;
} = {
  // Create the VTable using a series of closures.
  // ts automatically converts these into C callback functions.
  vtable: {
    onMessage: (uniffiHandle: bigint, message: Uint8Array) => {
      const uniffiMakeCall = (): void => {
        const jsCallback =
          FfiConverterTypeFfiMessageCallback.lift(uniffiHandle);
        return jsCallback.onMessage(FfiConverterTypeFfiMessage.lift(message));
      };
      const uniffiResult = UniffiResult.ready<void>();
      const uniffiHandleSuccess = (obj: any) => {};
      const uniffiHandleError = (code: number, errBuf: UniffiByteArray) => {
        UniffiResult.writeError(uniffiResult, code, errBuf);
      };
      uniffiTraitInterfaceCall(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*lowerString:*/ FfiConverterString.lower
      );
      return uniffiResult;
    },
    onError: (uniffiHandle: bigint, error: Uint8Array) => {
      const uniffiMakeCall = (): void => {
        const jsCallback =
          FfiConverterTypeFfiMessageCallback.lift(uniffiHandle);
        return jsCallback.onError(
          FfiConverterTypeFfiSubscribeError.lift(error)
        );
      };
      const uniffiResult = UniffiResult.ready<void>();
      const uniffiHandleSuccess = (obj: any) => {};
      const uniffiHandleError = (code: number, errBuf: UniffiByteArray) => {
        UniffiResult.writeError(uniffiResult, code, errBuf);
      };
      uniffiTraitInterfaceCall(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*lowerString:*/ FfiConverterString.lower
      );
      return uniffiResult;
    },
    onClose: (uniffiHandle: bigint) => {
      const uniffiMakeCall = (): void => {
        const jsCallback =
          FfiConverterTypeFfiMessageCallback.lift(uniffiHandle);
        return jsCallback.onClose();
      };
      const uniffiResult = UniffiResult.ready<void>();
      const uniffiHandleSuccess = (obj: any) => {};
      const uniffiHandleError = (code: number, errBuf: UniffiByteArray) => {
        UniffiResult.writeError(uniffiResult, code, errBuf);
      };
      uniffiTraitInterfaceCall(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*lowerString:*/ FfiConverterString.lower
      );
      return uniffiResult;
    },
    uniffiFree: (uniffiHandle: UniffiHandle): void => {
      // FfiMessageCallback: this will throw a stale handle error if the handle isn't found.
      FfiConverterTypeFfiMessageCallback.drop(uniffiHandle);
    },
  },
  register: () => {
    nativeModule().ubrn_uniffi_xmtpv3_fn_init_callback_vtable_ffimessagecallback(
      uniffiCallbackInterfaceFfiMessageCallback.vtable
    );
  },
};

export interface FfiMessageDeletionCallback {
  onMessageDeleted(messageId: ArrayBuffer): void;
}

export class FfiMessageDeletionCallbackImpl
  extends UniffiAbstractObject
  implements FfiMessageDeletionCallback
{
  readonly [uniffiTypeNameSymbol] = 'FfiMessageDeletionCallbackImpl';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeFfiMessageDeletionCallbackImplObjectFactory.bless(pointer);
  }

  public onMessageDeleted(messageId: ArrayBuffer): void {
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_xmtpv3_fn_method_ffimessagedeletioncallback_on_message_deleted(
          uniffiTypeFfiMessageDeletionCallbackImplObjectFactory.clonePointer(
            this
          ),
          FfiConverterArrayBuffer.lower(messageId),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer =
        uniffiTypeFfiMessageDeletionCallbackImplObjectFactory.pointer(this);
      uniffiTypeFfiMessageDeletionCallbackImplObjectFactory.freePointer(
        pointer
      );
      uniffiTypeFfiMessageDeletionCallbackImplObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is FfiMessageDeletionCallbackImpl {
    return uniffiTypeFfiMessageDeletionCallbackImplObjectFactory.isConcreteType(
      obj
    );
  }
}

const uniffiTypeFfiMessageDeletionCallbackImplObjectFactory: UniffiObjectFactory<FfiMessageDeletionCallback> =
  (() => {
    return {
      create(pointer: UnsafeMutableRawPointer): FfiMessageDeletionCallback {
        const instance = Object.create(
          FfiMessageDeletionCallbackImpl.prototype
        );
        instance[pointerLiteralSymbol] = pointer;
        instance[destructorGuardSymbol] = this.bless(pointer);
        instance[uniffiTypeNameSymbol] = 'FfiMessageDeletionCallbackImpl';
        return instance;
      },

      bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
        return uniffiCaller.rustCall(
          /*caller:*/ (status) =>
            nativeModule().ubrn_uniffi_internal_fn_method_ffimessagedeletioncallback_ffi__bless_pointer(
              p,
              status
            ),
          /*liftString:*/ FfiConverterString.lift
        );
      },

      unbless(ptr: UniffiRustArcPtr) {
        ptr.markDestroyed();
      },

      pointer(obj: FfiMessageDeletionCallback): UnsafeMutableRawPointer {
        if ((obj as any)[destructorGuardSymbol] === undefined) {
          throw new UniffiInternalError.UnexpectedNullPointer();
        }
        return (obj as any)[pointerLiteralSymbol];
      },

      clonePointer(obj: FfiMessageDeletionCallback): UnsafeMutableRawPointer {
        const pointer = this.pointer(obj);
        return uniffiCaller.rustCall(
          /*caller:*/ (callStatus) =>
            nativeModule().ubrn_uniffi_xmtpv3_fn_clone_ffimessagedeletioncallback(
              pointer,
              callStatus
            ),
          /*liftString:*/ FfiConverterString.lift
        );
      },

      freePointer(pointer: UnsafeMutableRawPointer): void {
        uniffiCaller.rustCall(
          /*caller:*/ (callStatus) =>
            nativeModule().ubrn_uniffi_xmtpv3_fn_free_ffimessagedeletioncallback(
              pointer,
              callStatus
            ),
          /*liftString:*/ FfiConverterString.lift
        );
      },

      isConcreteType(obj: any): obj is FfiMessageDeletionCallback {
        return (
          obj[destructorGuardSymbol] &&
          obj[uniffiTypeNameSymbol] === 'FfiMessageDeletionCallbackImpl'
        );
      },
    };
  })();
// FfiConverter for FfiMessageDeletionCallback
const FfiConverterTypeFfiMessageDeletionCallback =
  new FfiConverterObjectWithCallbacks(
    uniffiTypeFfiMessageDeletionCallbackImplObjectFactory
  );

// Add a vtavble for the callbacks that go in FfiMessageDeletionCallback.

// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceFfiMessageDeletionCallback: {
  vtable: UniffiVTableCallbackInterfaceFfiMessageDeletionCallback;
  register: () => void;
} = {
  // Create the VTable using a series of closures.
  // ts automatically converts these into C callback functions.
  vtable: {
    onMessageDeleted: (uniffiHandle: bigint, messageId: Uint8Array) => {
      const uniffiMakeCall = (): void => {
        const jsCallback =
          FfiConverterTypeFfiMessageDeletionCallback.lift(uniffiHandle);
        return jsCallback.onMessageDeleted(
          FfiConverterArrayBuffer.lift(messageId)
        );
      };
      const uniffiResult = UniffiResult.ready<void>();
      const uniffiHandleSuccess = (obj: any) => {};
      const uniffiHandleError = (code: number, errBuf: UniffiByteArray) => {
        UniffiResult.writeError(uniffiResult, code, errBuf);
      };
      uniffiTraitInterfaceCall(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*lowerString:*/ FfiConverterString.lower
      );
      return uniffiResult;
    },
    uniffiFree: (uniffiHandle: UniffiHandle): void => {
      // FfiMessageDeletionCallback: this will throw a stale handle error if the handle isn't found.
      FfiConverterTypeFfiMessageDeletionCallback.drop(uniffiHandle);
    },
  },
  register: () => {
    nativeModule().ubrn_uniffi_xmtpv3_fn_init_callback_vtable_ffimessagedeletioncallback(
      uniffiCallbackInterfaceFfiMessageDeletionCallback.vtable
    );
  },
};

export interface FfiPreferenceCallback {
  onPreferenceUpdate(preference: Array<FfiPreferenceUpdate>): void;
  onError(error: FfiSubscribeError): void;
  onClose(): void;
}

export class FfiPreferenceCallbackImpl
  extends UniffiAbstractObject
  implements FfiPreferenceCallback
{
  readonly [uniffiTypeNameSymbol] = 'FfiPreferenceCallbackImpl';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeFfiPreferenceCallbackImplObjectFactory.bless(pointer);
  }

  public onPreferenceUpdate(preference: Array<FfiPreferenceUpdate>): void {
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_xmtpv3_fn_method_ffipreferencecallback_on_preference_update(
          uniffiTypeFfiPreferenceCallbackImplObjectFactory.clonePointer(this),
          FfiConverterArrayTypeFfiPreferenceUpdate.lower(preference),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  public onError(error: FfiSubscribeError): void {
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_xmtpv3_fn_method_ffipreferencecallback_on_error(
          uniffiTypeFfiPreferenceCallbackImplObjectFactory.clonePointer(this),
          FfiConverterTypeFfiSubscribeError.lower(error),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  public onClose(): void {
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_xmtpv3_fn_method_ffipreferencecallback_on_close(
          uniffiTypeFfiPreferenceCallbackImplObjectFactory.clonePointer(this),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer =
        uniffiTypeFfiPreferenceCallbackImplObjectFactory.pointer(this);
      uniffiTypeFfiPreferenceCallbackImplObjectFactory.freePointer(pointer);
      uniffiTypeFfiPreferenceCallbackImplObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is FfiPreferenceCallbackImpl {
    return uniffiTypeFfiPreferenceCallbackImplObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeFfiPreferenceCallbackImplObjectFactory: UniffiObjectFactory<FfiPreferenceCallback> =
  (() => {
    return {
      create(pointer: UnsafeMutableRawPointer): FfiPreferenceCallback {
        const instance = Object.create(FfiPreferenceCallbackImpl.prototype);
        instance[pointerLiteralSymbol] = pointer;
        instance[destructorGuardSymbol] = this.bless(pointer);
        instance[uniffiTypeNameSymbol] = 'FfiPreferenceCallbackImpl';
        return instance;
      },

      bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
        return uniffiCaller.rustCall(
          /*caller:*/ (status) =>
            nativeModule().ubrn_uniffi_internal_fn_method_ffipreferencecallback_ffi__bless_pointer(
              p,
              status
            ),
          /*liftString:*/ FfiConverterString.lift
        );
      },

      unbless(ptr: UniffiRustArcPtr) {
        ptr.markDestroyed();
      },

      pointer(obj: FfiPreferenceCallback): UnsafeMutableRawPointer {
        if ((obj as any)[destructorGuardSymbol] === undefined) {
          throw new UniffiInternalError.UnexpectedNullPointer();
        }
        return (obj as any)[pointerLiteralSymbol];
      },

      clonePointer(obj: FfiPreferenceCallback): UnsafeMutableRawPointer {
        const pointer = this.pointer(obj);
        return uniffiCaller.rustCall(
          /*caller:*/ (callStatus) =>
            nativeModule().ubrn_uniffi_xmtpv3_fn_clone_ffipreferencecallback(
              pointer,
              callStatus
            ),
          /*liftString:*/ FfiConverterString.lift
        );
      },

      freePointer(pointer: UnsafeMutableRawPointer): void {
        uniffiCaller.rustCall(
          /*caller:*/ (callStatus) =>
            nativeModule().ubrn_uniffi_xmtpv3_fn_free_ffipreferencecallback(
              pointer,
              callStatus
            ),
          /*liftString:*/ FfiConverterString.lift
        );
      },

      isConcreteType(obj: any): obj is FfiPreferenceCallback {
        return (
          obj[destructorGuardSymbol] &&
          obj[uniffiTypeNameSymbol] === 'FfiPreferenceCallbackImpl'
        );
      },
    };
  })();
// FfiConverter for FfiPreferenceCallback
const FfiConverterTypeFfiPreferenceCallback =
  new FfiConverterObjectWithCallbacks(
    uniffiTypeFfiPreferenceCallbackImplObjectFactory
  );

// Add a vtavble for the callbacks that go in FfiPreferenceCallback.

// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceFfiPreferenceCallback: {
  vtable: UniffiVTableCallbackInterfaceFfiPreferenceCallback;
  register: () => void;
} = {
  // Create the VTable using a series of closures.
  // ts automatically converts these into C callback functions.
  vtable: {
    onPreferenceUpdate: (uniffiHandle: bigint, preference: Uint8Array) => {
      const uniffiMakeCall = (): void => {
        const jsCallback =
          FfiConverterTypeFfiPreferenceCallback.lift(uniffiHandle);
        return jsCallback.onPreferenceUpdate(
          FfiConverterArrayTypeFfiPreferenceUpdate.lift(preference)
        );
      };
      const uniffiResult = UniffiResult.ready<void>();
      const uniffiHandleSuccess = (obj: any) => {};
      const uniffiHandleError = (code: number, errBuf: UniffiByteArray) => {
        UniffiResult.writeError(uniffiResult, code, errBuf);
      };
      uniffiTraitInterfaceCall(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*lowerString:*/ FfiConverterString.lower
      );
      return uniffiResult;
    },
    onError: (uniffiHandle: bigint, error: Uint8Array) => {
      const uniffiMakeCall = (): void => {
        const jsCallback =
          FfiConverterTypeFfiPreferenceCallback.lift(uniffiHandle);
        return jsCallback.onError(
          FfiConverterTypeFfiSubscribeError.lift(error)
        );
      };
      const uniffiResult = UniffiResult.ready<void>();
      const uniffiHandleSuccess = (obj: any) => {};
      const uniffiHandleError = (code: number, errBuf: UniffiByteArray) => {
        UniffiResult.writeError(uniffiResult, code, errBuf);
      };
      uniffiTraitInterfaceCall(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*lowerString:*/ FfiConverterString.lower
      );
      return uniffiResult;
    },
    onClose: (uniffiHandle: bigint) => {
      const uniffiMakeCall = (): void => {
        const jsCallback =
          FfiConverterTypeFfiPreferenceCallback.lift(uniffiHandle);
        return jsCallback.onClose();
      };
      const uniffiResult = UniffiResult.ready<void>();
      const uniffiHandleSuccess = (obj: any) => {};
      const uniffiHandleError = (code: number, errBuf: UniffiByteArray) => {
        UniffiResult.writeError(uniffiResult, code, errBuf);
      };
      uniffiTraitInterfaceCall(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*lowerString:*/ FfiConverterString.lower
      );
      return uniffiResult;
    },
    uniffiFree: (uniffiHandle: UniffiHandle): void => {
      // FfiPreferenceCallback: this will throw a stale handle error if the handle isn't found.
      FfiConverterTypeFfiPreferenceCallback.drop(uniffiHandle);
    },
  },
  register: () => {
    nativeModule().ubrn_uniffi_xmtpv3_fn_init_callback_vtable_ffipreferencecallback(
      uniffiCallbackInterfaceFfiPreferenceCallback.vtable
    );
  },
};

export interface FfiSignatureRequestInterface {
  addEcdsaSignature(
    signatureBytes: ArrayBuffer,
    asyncOpts_?: { signal: AbortSignal }
  ): /*throws*/ Promise<void>;
  addPasskeySignature(
    signature: FfiPasskeySignature,
    asyncOpts_?: { signal: AbortSignal }
  ): /*throws*/ Promise<void>;
  addScwSignature(
    signatureBytes: ArrayBuffer,
    address: string,
    chainId: /*u64*/ bigint,
    blockNumber: /*u64*/ bigint | undefined,
    asyncOpts_?: { signal: AbortSignal }
  ): /*throws*/ Promise<void>;
  isReady(asyncOpts_?: { signal: AbortSignal }): Promise<boolean>;
  /**
   * missing signatures that are from `MemberKind::Address`
   */
  missingAddressSignatures(asyncOpts_?: {
    signal: AbortSignal;
  }): /*throws*/ Promise<Array<string>>;
  signatureText(asyncOpts_?: {
    signal: AbortSignal;
  }): /*throws*/ Promise<string>;
}

export class FfiSignatureRequest
  extends UniffiAbstractObject
  implements FfiSignatureRequestInterface
{
  readonly [uniffiTypeNameSymbol] = 'FfiSignatureRequest';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeFfiSignatureRequestObjectFactory.bless(pointer);
  }

  public async addEcdsaSignature(
    signatureBytes: ArrayBuffer,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_xmtpv3_fn_method_ffisignaturerequest_add_ecdsa_signature(
            uniffiTypeFfiSignatureRequestObjectFactory.clonePointer(this),
            FfiConverterArrayBuffer.lower(signatureBytes)
          );
        },
        /*pollFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_complete_void,
        /*freeFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeGenericError.lift.bind(
          FfiConverterTypeGenericError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async addPasskeySignature(
    signature: FfiPasskeySignature,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_xmtpv3_fn_method_ffisignaturerequest_add_passkey_signature(
            uniffiTypeFfiSignatureRequestObjectFactory.clonePointer(this),
            FfiConverterTypeFfiPasskeySignature.lower(signature)
          );
        },
        /*pollFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_complete_void,
        /*freeFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeGenericError.lift.bind(
          FfiConverterTypeGenericError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async addScwSignature(
    signatureBytes: ArrayBuffer,
    address: string,
    chainId: /*u64*/ bigint,
    blockNumber: /*u64*/ bigint | undefined,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_xmtpv3_fn_method_ffisignaturerequest_add_scw_signature(
            uniffiTypeFfiSignatureRequestObjectFactory.clonePointer(this),
            FfiConverterArrayBuffer.lower(signatureBytes),
            FfiConverterString.lower(address),
            FfiConverterUInt64.lower(chainId),
            FfiConverterOptionalUInt64.lower(blockNumber)
          );
        },
        /*pollFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_complete_void,
        /*freeFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeGenericError.lift.bind(
          FfiConverterTypeGenericError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async isReady(asyncOpts_?: { signal: AbortSignal }): Promise<boolean> {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_xmtpv3_fn_method_ffisignaturerequest_is_ready(
            uniffiTypeFfiSignatureRequestObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_poll_i8,
        /*cancelFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_cancel_i8,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_complete_i8,
        /*freeFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_free_i8,
        /*liftFunc:*/ FfiConverterBool.lift.bind(FfiConverterBool),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * missing signatures that are from `MemberKind::Address`
   */
  public async missingAddressSignatures(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<Array<string>> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_xmtpv3_fn_method_ffisignaturerequest_missing_address_signatures(
            uniffiTypeFfiSignatureRequestObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterArrayString.lift.bind(
          FfiConverterArrayString
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeGenericError.lift.bind(
          FfiConverterTypeGenericError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async signatureText(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<string> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_xmtpv3_fn_method_ffisignaturerequest_signature_text(
            uniffiTypeFfiSignatureRequestObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterString.lift.bind(FfiConverterString),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeGenericError.lift.bind(
          FfiConverterTypeGenericError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeFfiSignatureRequestObjectFactory.pointer(this);
      uniffiTypeFfiSignatureRequestObjectFactory.freePointer(pointer);
      uniffiTypeFfiSignatureRequestObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is FfiSignatureRequest {
    return uniffiTypeFfiSignatureRequestObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeFfiSignatureRequestObjectFactory: UniffiObjectFactory<FfiSignatureRequestInterface> =
  (() => {
    return {
      create(pointer: UnsafeMutableRawPointer): FfiSignatureRequestInterface {
        const instance = Object.create(FfiSignatureRequest.prototype);
        instance[pointerLiteralSymbol] = pointer;
        instance[destructorGuardSymbol] = this.bless(pointer);
        instance[uniffiTypeNameSymbol] = 'FfiSignatureRequest';
        return instance;
      },

      bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
        return uniffiCaller.rustCall(
          /*caller:*/ (status) =>
            nativeModule().ubrn_uniffi_internal_fn_method_ffisignaturerequest_ffi__bless_pointer(
              p,
              status
            ),
          /*liftString:*/ FfiConverterString.lift
        );
      },

      unbless(ptr: UniffiRustArcPtr) {
        ptr.markDestroyed();
      },

      pointer(obj: FfiSignatureRequestInterface): UnsafeMutableRawPointer {
        if ((obj as any)[destructorGuardSymbol] === undefined) {
          throw new UniffiInternalError.UnexpectedNullPointer();
        }
        return (obj as any)[pointerLiteralSymbol];
      },

      clonePointer(obj: FfiSignatureRequestInterface): UnsafeMutableRawPointer {
        const pointer = this.pointer(obj);
        return uniffiCaller.rustCall(
          /*caller:*/ (callStatus) =>
            nativeModule().ubrn_uniffi_xmtpv3_fn_clone_ffisignaturerequest(
              pointer,
              callStatus
            ),
          /*liftString:*/ FfiConverterString.lift
        );
      },

      freePointer(pointer: UnsafeMutableRawPointer): void {
        uniffiCaller.rustCall(
          /*caller:*/ (callStatus) =>
            nativeModule().ubrn_uniffi_xmtpv3_fn_free_ffisignaturerequest(
              pointer,
              callStatus
            ),
          /*liftString:*/ FfiConverterString.lift
        );
      },

      isConcreteType(obj: any): obj is FfiSignatureRequestInterface {
        return (
          obj[destructorGuardSymbol] &&
          obj[uniffiTypeNameSymbol] === 'FfiSignatureRequest'
        );
      },
    };
  })();
// FfiConverter for FfiSignatureRequestInterface
const FfiConverterTypeFfiSignatureRequest = new FfiConverterObject(
  uniffiTypeFfiSignatureRequestObjectFactory
);

export interface FfiStreamCloserInterface {
  /**
   * Signal the stream to end
   * Does not wait for the stream to end.
   */
  end(): void;
  /**
   * End the stream and asynchronously wait for it to shutdown
   */
  endAndWait(asyncOpts_?: { signal: AbortSignal }): /*throws*/ Promise<void>;
  isClosed(): boolean;
  waitForReady(asyncOpts_?: { signal: AbortSignal }): Promise<void>;
}

export class FfiStreamCloser
  extends UniffiAbstractObject
  implements FfiStreamCloserInterface
{
  readonly [uniffiTypeNameSymbol] = 'FfiStreamCloser';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeFfiStreamCloserObjectFactory.bless(pointer);
  }

  /**
   * Signal the stream to end
   * Does not wait for the stream to end.
   */
  public end(): void {
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_xmtpv3_fn_method_ffistreamcloser_end(
          uniffiTypeFfiStreamCloserObjectFactory.clonePointer(this),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  /**
   * End the stream and asynchronously wait for it to shutdown
   */
  public async endAndWait(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_xmtpv3_fn_method_ffistreamcloser_end_and_wait(
            uniffiTypeFfiStreamCloserObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_complete_void,
        /*freeFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeGenericError.lift.bind(
          FfiConverterTypeGenericError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public isClosed(): boolean {
    return FfiConverterBool.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_xmtpv3_fn_method_ffistreamcloser_is_closed(
            uniffiTypeFfiStreamCloserObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public async waitForReady(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<void> {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_xmtpv3_fn_method_ffistreamcloser_wait_for_ready(
            uniffiTypeFfiStreamCloserObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_complete_void,
        /*freeFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeFfiStreamCloserObjectFactory.pointer(this);
      uniffiTypeFfiStreamCloserObjectFactory.freePointer(pointer);
      uniffiTypeFfiStreamCloserObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is FfiStreamCloser {
    return uniffiTypeFfiStreamCloserObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeFfiStreamCloserObjectFactory: UniffiObjectFactory<FfiStreamCloserInterface> =
  (() => {
    return {
      create(pointer: UnsafeMutableRawPointer): FfiStreamCloserInterface {
        const instance = Object.create(FfiStreamCloser.prototype);
        instance[pointerLiteralSymbol] = pointer;
        instance[destructorGuardSymbol] = this.bless(pointer);
        instance[uniffiTypeNameSymbol] = 'FfiStreamCloser';
        return instance;
      },

      bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
        return uniffiCaller.rustCall(
          /*caller:*/ (status) =>
            nativeModule().ubrn_uniffi_internal_fn_method_ffistreamcloser_ffi__bless_pointer(
              p,
              status
            ),
          /*liftString:*/ FfiConverterString.lift
        );
      },

      unbless(ptr: UniffiRustArcPtr) {
        ptr.markDestroyed();
      },

      pointer(obj: FfiStreamCloserInterface): UnsafeMutableRawPointer {
        if ((obj as any)[destructorGuardSymbol] === undefined) {
          throw new UniffiInternalError.UnexpectedNullPointer();
        }
        return (obj as any)[pointerLiteralSymbol];
      },

      clonePointer(obj: FfiStreamCloserInterface): UnsafeMutableRawPointer {
        const pointer = this.pointer(obj);
        return uniffiCaller.rustCall(
          /*caller:*/ (callStatus) =>
            nativeModule().ubrn_uniffi_xmtpv3_fn_clone_ffistreamcloser(
              pointer,
              callStatus
            ),
          /*liftString:*/ FfiConverterString.lift
        );
      },

      freePointer(pointer: UnsafeMutableRawPointer): void {
        uniffiCaller.rustCall(
          /*caller:*/ (callStatus) =>
            nativeModule().ubrn_uniffi_xmtpv3_fn_free_ffistreamcloser(
              pointer,
              callStatus
            ),
          /*liftString:*/ FfiConverterString.lift
        );
      },

      isConcreteType(obj: any): obj is FfiStreamCloserInterface {
        return (
          obj[destructorGuardSymbol] &&
          obj[uniffiTypeNameSymbol] === 'FfiStreamCloser'
        );
      },
    };
  })();
// FfiConverter for FfiStreamCloserInterface
const FfiConverterTypeFfiStreamCloser = new FfiConverterObject(
  uniffiTypeFfiStreamCloserObjectFactory
);

export interface FfiSyncWorkerInterface {
  wait(
    metric: FfiSyncMetric,
    count: /*u64*/ bigint,
    asyncOpts_?: { signal: AbortSignal }
  ): /*throws*/ Promise<void>;
}

export class FfiSyncWorker
  extends UniffiAbstractObject
  implements FfiSyncWorkerInterface
{
  readonly [uniffiTypeNameSymbol] = 'FfiSyncWorker';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeFfiSyncWorkerObjectFactory.bless(pointer);
  }

  public async wait(
    metric: FfiSyncMetric,
    count: /*u64*/ bigint,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_xmtpv3_fn_method_ffisyncworker_wait(
            uniffiTypeFfiSyncWorkerObjectFactory.clonePointer(this),
            FfiConverterTypeFfiSyncMetric.lower(metric),
            FfiConverterUInt64.lower(count)
          );
        },
        /*pollFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_complete_void,
        /*freeFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeGenericError.lift.bind(
          FfiConverterTypeGenericError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeFfiSyncWorkerObjectFactory.pointer(this);
      uniffiTypeFfiSyncWorkerObjectFactory.freePointer(pointer);
      uniffiTypeFfiSyncWorkerObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is FfiSyncWorker {
    return uniffiTypeFfiSyncWorkerObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeFfiSyncWorkerObjectFactory: UniffiObjectFactory<FfiSyncWorkerInterface> =
  (() => {
    return {
      create(pointer: UnsafeMutableRawPointer): FfiSyncWorkerInterface {
        const instance = Object.create(FfiSyncWorker.prototype);
        instance[pointerLiteralSymbol] = pointer;
        instance[destructorGuardSymbol] = this.bless(pointer);
        instance[uniffiTypeNameSymbol] = 'FfiSyncWorker';
        return instance;
      },

      bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
        return uniffiCaller.rustCall(
          /*caller:*/ (status) =>
            nativeModule().ubrn_uniffi_internal_fn_method_ffisyncworker_ffi__bless_pointer(
              p,
              status
            ),
          /*liftString:*/ FfiConverterString.lift
        );
      },

      unbless(ptr: UniffiRustArcPtr) {
        ptr.markDestroyed();
      },

      pointer(obj: FfiSyncWorkerInterface): UnsafeMutableRawPointer {
        if ((obj as any)[destructorGuardSymbol] === undefined) {
          throw new UniffiInternalError.UnexpectedNullPointer();
        }
        return (obj as any)[pointerLiteralSymbol];
      },

      clonePointer(obj: FfiSyncWorkerInterface): UnsafeMutableRawPointer {
        const pointer = this.pointer(obj);
        return uniffiCaller.rustCall(
          /*caller:*/ (callStatus) =>
            nativeModule().ubrn_uniffi_xmtpv3_fn_clone_ffisyncworker(
              pointer,
              callStatus
            ),
          /*liftString:*/ FfiConverterString.lift
        );
      },

      freePointer(pointer: UnsafeMutableRawPointer): void {
        uniffiCaller.rustCall(
          /*caller:*/ (callStatus) =>
            nativeModule().ubrn_uniffi_xmtpv3_fn_free_ffisyncworker(
              pointer,
              callStatus
            ),
          /*liftString:*/ FfiConverterString.lift
        );
      },

      isConcreteType(obj: any): obj is FfiSyncWorkerInterface {
        return (
          obj[destructorGuardSymbol] &&
          obj[uniffiTypeNameSymbol] === 'FfiSyncWorker'
        );
      },
    };
  })();
// FfiConverter for FfiSyncWorkerInterface
const FfiConverterTypeFfiSyncWorker = new FfiConverterObject(
  uniffiTypeFfiSyncWorkerObjectFactory
);

export interface FfiXmtpClientInterface {
  /**
   * Adds a wallet address to the existing client
   */
  addIdentity(
    newIdentity: FfiIdentifier,
    asyncOpts_?: { signal: AbortSignal }
  ): /*throws*/ Promise<FfiSignatureRequestInterface>;
  /**
   * * Get the inbox state for each `inbox_id`.
   *      *
   *      * If `refresh_from_network` is true, the client will go to the network first to refresh the state.
   *      * Otherwise, the state will be read from the local database.
   */
  addressesFromInboxId(
    refreshFromNetwork: boolean,
    inboxIds: Array<string>,
    asyncOpts_?: { signal: AbortSignal }
  ): /*throws*/ Promise<Array<FfiInboxState>>;
  apiAggregateStatistics(): string;
  apiIdentityStatistics(): FfiIdentityStats;
  apiStatistics(): FfiApiStats;
  applySignatureRequest(
    signatureRequest: FfiSignatureRequestInterface,
    asyncOpts_?: { signal: AbortSignal }
  ): /*throws*/ Promise<void>;
  /**
   * Load the metadata for an archive to see what it contains.
   * Reads only the metadata without loading the entire file, so this function is quick.
   */
  archiveMetadata(
    path: string,
    key: ArrayBuffer,
    asyncOpts_?: { signal: AbortSignal }
  ): /*throws*/ Promise<FfiBackupMetadata>;
  canMessage(
    accountIdentifiers: Array<FfiIdentifier>,
    asyncOpts_?: { signal: AbortSignal }
  ): /*throws*/ Promise<Map<FfiIdentifier, boolean>>;
  /**
   * * Change the recovery identifier for your inboxId
   */
  changeRecoveryIdentifier(
    newRecoveryIdentifier: FfiIdentifier,
    asyncOpts_?: { signal: AbortSignal }
  ): /*throws*/ Promise<FfiSignatureRequestInterface>;
  clearAllStatistics(): void;
  conversation(
    conversationId: ArrayBuffer
  ): /*throws*/ FfiConversationInterface;
  conversations(): FfiConversationsInterface;
  /**
   * Archive application elements to file for later restoration.
   */
  createArchive(
    path: string,
    opts: FfiArchiveOptions,
    key: ArrayBuffer,
    asyncOpts_?: { signal: AbortSignal }
  ): /*throws*/ Promise<void>;
  dbReconnect(asyncOpts_?: { signal: AbortSignal }): /*throws*/ Promise<void>;
  deleteMessage(messageId: ArrayBuffer): /*throws*/ /*u32*/ number;
  dmConversation(targetInboxId: string): /*throws*/ FfiConversationInterface;
  enrichedMessage(
    messageId: ArrayBuffer
  ): /*throws*/ FfiDecodedMessageInterface;
  findInboxId(
    identifier: FfiIdentifier,
    asyncOpts_?: { signal: AbortSignal }
  ): /*throws*/ Promise<string | undefined>;
  getConsentState(
    entityType: FfiConsentEntityType,
    entity: string,
    asyncOpts_?: { signal: AbortSignal }
  ): /*throws*/ Promise<FfiConsentState>;
  getKeyPackageStatusesForInstallationIds(
    installationIds: Array<ArrayBuffer>,
    asyncOpts_?: { signal: AbortSignal }
  ): /*throws*/ Promise<Map<ArrayBuffer, FfiKeyPackageStatus>>;
  getLatestInboxState(
    inboxId: string,
    asyncOpts_?: { signal: AbortSignal }
  ): /*throws*/ Promise<FfiInboxState>;
  /**
   * Import a previous archive
   */
  importArchive(
    path: string,
    key: ArrayBuffer,
    asyncOpts_?: { signal: AbortSignal }
  ): /*throws*/ Promise<void>;
  inboxId(): string;
  /**
   * * Get the client's inbox state.
   *      *
   *      * If `refresh_from_network` is true, the client will go to the network first to refresh the state.
   *      * Otherwise, the state will be read from the local database.
   */
  inboxState(
    refreshFromNetwork: boolean,
    asyncOpts_?: { signal: AbortSignal }
  ): /*throws*/ Promise<FfiInboxState>;
  installationId(): ArrayBuffer;
  message(messageId: ArrayBuffer): /*throws*/ FfiMessage;
  registerIdentity(
    signatureRequest: FfiSignatureRequestInterface,
    asyncOpts_?: { signal: AbortSignal }
  ): /*throws*/ Promise<void>;
  releaseDbConnection(): /*throws*/ void;
  /**
   * * Revokes all installations except the one the client is currently using
   *      * Returns Some FfiSignatureRequest if we have installations to revoke.
   *      * If we have no other installations to revoke, returns None.
   */
  revokeAllOtherInstallationsSignatureRequest(asyncOpts_?: {
    signal: AbortSignal;
  }): /*throws*/ Promise<FfiSignatureRequestInterface | undefined>;
  /**
   * Revokes or removes an identity from the existing client
   */
  revokeIdentity(
    identifier: FfiIdentifier,
    asyncOpts_?: { signal: AbortSignal }
  ): /*throws*/ Promise<FfiSignatureRequestInterface>;
  /**
   * * Revoke a list of installations
   */
  revokeInstallations(
    installationIds: Array<ArrayBuffer>,
    asyncOpts_?: { signal: AbortSignal }
  ): /*throws*/ Promise<FfiSignatureRequestInterface>;
  /**
   * Manually trigger a device sync request to sync records from another active device on this account.
   */
  sendSyncRequest(asyncOpts_?: {
    signal: AbortSignal;
  }): /*throws*/ Promise<void>;
  setConsentStates(
    records: Array<FfiConsent>,
    asyncOpts_?: { signal: AbortSignal }
  ): /*throws*/ Promise<void>;
  /**
   * A utility function to sign a piece of text with this installation's private key.
   */
  signWithInstallationKey(text: string): /*throws*/ ArrayBuffer;
  signatureRequest(): FfiSignatureRequestInterface | undefined;
  syncPreferences(asyncOpts_?: {
    signal: AbortSignal;
  }): /*throws*/ Promise<FfiGroupSyncSummary>;
  /**
   * A utility function to easily verify that a piece of text was signed by this installation.
   */
  verifySignedWithInstallationKey(
    signatureText: string,
    signatureBytes: ArrayBuffer
  ): /*throws*/ void;
  /**
   * A utility function to easily verify that a string has been signed by another libXmtp installation.
   * Only works for verifying libXmtp public context signatures.
   */
  verifySignedWithPublicKey(
    signatureText: string,
    signatureBytes: ArrayBuffer,
    publicKey: ArrayBuffer
  ): /*throws*/ void;
}

export class FfiXmtpClient
  extends UniffiAbstractObject
  implements FfiXmtpClientInterface
{
  readonly [uniffiTypeNameSymbol] = 'FfiXmtpClient';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeFfiXmtpClientObjectFactory.bless(pointer);
  }

  /**
   * Adds a wallet address to the existing client
   */
  public async addIdentity(
    newIdentity: FfiIdentifier,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<FfiSignatureRequestInterface> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_xmtpv3_fn_method_ffixmtpclient_add_identity(
            uniffiTypeFfiXmtpClientObjectFactory.clonePointer(this),
            FfiConverterTypeFfiIdentifier.lower(newIdentity)
          );
        },
        /*pollFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_poll_pointer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_cancel_pointer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_complete_pointer,
        /*freeFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_free_pointer,
        /*liftFunc:*/ FfiConverterTypeFfiSignatureRequest.lift.bind(
          FfiConverterTypeFfiSignatureRequest
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeGenericError.lift.bind(
          FfiConverterTypeGenericError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * * Get the inbox state for each `inbox_id`.
   *      *
   *      * If `refresh_from_network` is true, the client will go to the network first to refresh the state.
   *      * Otherwise, the state will be read from the local database.
   */
  public async addressesFromInboxId(
    refreshFromNetwork: boolean,
    inboxIds: Array<string>,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<Array<FfiInboxState>> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_xmtpv3_fn_method_ffixmtpclient_addresses_from_inbox_id(
            uniffiTypeFfiXmtpClientObjectFactory.clonePointer(this),
            FfiConverterBool.lower(refreshFromNetwork),
            FfiConverterArrayString.lower(inboxIds)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterArrayTypeFfiInboxState.lift.bind(
          FfiConverterArrayTypeFfiInboxState
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeGenericError.lift.bind(
          FfiConverterTypeGenericError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public apiAggregateStatistics(): string {
    return FfiConverterString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_xmtpv3_fn_method_ffixmtpclient_api_aggregate_statistics(
            uniffiTypeFfiXmtpClientObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public apiIdentityStatistics(): FfiIdentityStats {
    return FfiConverterTypeFfiIdentityStats.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_xmtpv3_fn_method_ffixmtpclient_api_identity_statistics(
            uniffiTypeFfiXmtpClientObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public apiStatistics(): FfiApiStats {
    return FfiConverterTypeFfiApiStats.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_xmtpv3_fn_method_ffixmtpclient_api_statistics(
            uniffiTypeFfiXmtpClientObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public async applySignatureRequest(
    signatureRequest: FfiSignatureRequestInterface,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_xmtpv3_fn_method_ffixmtpclient_apply_signature_request(
            uniffiTypeFfiXmtpClientObjectFactory.clonePointer(this),
            FfiConverterTypeFfiSignatureRequest.lower(signatureRequest)
          );
        },
        /*pollFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_complete_void,
        /*freeFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeGenericError.lift.bind(
          FfiConverterTypeGenericError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Load the metadata for an archive to see what it contains.
   * Reads only the metadata without loading the entire file, so this function is quick.
   */
  public async archiveMetadata(
    path: string,
    key: ArrayBuffer,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<FfiBackupMetadata> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_xmtpv3_fn_method_ffixmtpclient_archive_metadata(
            uniffiTypeFfiXmtpClientObjectFactory.clonePointer(this),
            FfiConverterString.lower(path),
            FfiConverterArrayBuffer.lower(key)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterTypeFfiBackupMetadata.lift.bind(
          FfiConverterTypeFfiBackupMetadata
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeGenericError.lift.bind(
          FfiConverterTypeGenericError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async canMessage(
    accountIdentifiers: Array<FfiIdentifier>,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<Map<FfiIdentifier, boolean>> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_xmtpv3_fn_method_ffixmtpclient_can_message(
            uniffiTypeFfiXmtpClientObjectFactory.clonePointer(this),
            FfiConverterArrayTypeFfiIdentifier.lower(accountIdentifiers)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterMapTypeFfiIdentifierBool.lift.bind(
          FfiConverterMapTypeFfiIdentifierBool
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeGenericError.lift.bind(
          FfiConverterTypeGenericError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * * Change the recovery identifier for your inboxId
   */
  public async changeRecoveryIdentifier(
    newRecoveryIdentifier: FfiIdentifier,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<FfiSignatureRequestInterface> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_xmtpv3_fn_method_ffixmtpclient_change_recovery_identifier(
            uniffiTypeFfiXmtpClientObjectFactory.clonePointer(this),
            FfiConverterTypeFfiIdentifier.lower(newRecoveryIdentifier)
          );
        },
        /*pollFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_poll_pointer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_cancel_pointer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_complete_pointer,
        /*freeFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_free_pointer,
        /*liftFunc:*/ FfiConverterTypeFfiSignatureRequest.lift.bind(
          FfiConverterTypeFfiSignatureRequest
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeGenericError.lift.bind(
          FfiConverterTypeGenericError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public clearAllStatistics(): void {
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_xmtpv3_fn_method_ffixmtpclient_clear_all_statistics(
          uniffiTypeFfiXmtpClientObjectFactory.clonePointer(this),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  public conversation(
    conversationId: ArrayBuffer
  ): FfiConversationInterface /*throws*/ {
    return FfiConverterTypeFfiConversation.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeGenericError.lift.bind(
          FfiConverterTypeGenericError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_xmtpv3_fn_method_ffixmtpclient_conversation(
            uniffiTypeFfiXmtpClientObjectFactory.clonePointer(this),
            FfiConverterArrayBuffer.lower(conversationId),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public conversations(): FfiConversationsInterface {
    return FfiConverterTypeFfiConversations.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_xmtpv3_fn_method_ffixmtpclient_conversations(
            uniffiTypeFfiXmtpClientObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Archive application elements to file for later restoration.
   */
  public async createArchive(
    path: string,
    opts: FfiArchiveOptions,
    key: ArrayBuffer,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_xmtpv3_fn_method_ffixmtpclient_create_archive(
            uniffiTypeFfiXmtpClientObjectFactory.clonePointer(this),
            FfiConverterString.lower(path),
            FfiConverterTypeFfiArchiveOptions.lower(opts),
            FfiConverterArrayBuffer.lower(key)
          );
        },
        /*pollFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_complete_void,
        /*freeFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeGenericError.lift.bind(
          FfiConverterTypeGenericError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async dbReconnect(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_xmtpv3_fn_method_ffixmtpclient_db_reconnect(
            uniffiTypeFfiXmtpClientObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_complete_void,
        /*freeFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeGenericError.lift.bind(
          FfiConverterTypeGenericError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public deleteMessage(messageId: ArrayBuffer): /*u32*/ number /*throws*/ {
    return FfiConverterUInt32.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeGenericError.lift.bind(
          FfiConverterTypeGenericError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_xmtpv3_fn_method_ffixmtpclient_delete_message(
            uniffiTypeFfiXmtpClientObjectFactory.clonePointer(this),
            FfiConverterArrayBuffer.lower(messageId),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public dmConversation(
    targetInboxId: string
  ): FfiConversationInterface /*throws*/ {
    return FfiConverterTypeFfiConversation.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeGenericError.lift.bind(
          FfiConverterTypeGenericError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_xmtpv3_fn_method_ffixmtpclient_dm_conversation(
            uniffiTypeFfiXmtpClientObjectFactory.clonePointer(this),
            FfiConverterString.lower(targetInboxId),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public enrichedMessage(
    messageId: ArrayBuffer
  ): FfiDecodedMessageInterface /*throws*/ {
    return FfiConverterTypeFfiDecodedMessage.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeGenericError.lift.bind(
          FfiConverterTypeGenericError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_xmtpv3_fn_method_ffixmtpclient_enriched_message(
            uniffiTypeFfiXmtpClientObjectFactory.clonePointer(this),
            FfiConverterArrayBuffer.lower(messageId),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public async findInboxId(
    identifier: FfiIdentifier,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<string | undefined> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_xmtpv3_fn_method_ffixmtpclient_find_inbox_id(
            uniffiTypeFfiXmtpClientObjectFactory.clonePointer(this),
            FfiConverterTypeFfiIdentifier.lower(identifier)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterOptionalString.lift.bind(
          FfiConverterOptionalString
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeGenericError.lift.bind(
          FfiConverterTypeGenericError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async getConsentState(
    entityType: FfiConsentEntityType,
    entity: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<FfiConsentState> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_xmtpv3_fn_method_ffixmtpclient_get_consent_state(
            uniffiTypeFfiXmtpClientObjectFactory.clonePointer(this),
            FfiConverterTypeFfiConsentEntityType.lower(entityType),
            FfiConverterString.lower(entity)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterTypeFfiConsentState.lift.bind(
          FfiConverterTypeFfiConsentState
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeGenericError.lift.bind(
          FfiConverterTypeGenericError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async getKeyPackageStatusesForInstallationIds(
    installationIds: Array<ArrayBuffer>,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<Map<ArrayBuffer, FfiKeyPackageStatus>> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_xmtpv3_fn_method_ffixmtpclient_get_key_package_statuses_for_installation_ids(
            uniffiTypeFfiXmtpClientObjectFactory.clonePointer(this),
            FfiConverterArrayArrayBuffer.lower(installationIds)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterMapArrayBufferTypeFfiKeyPackageStatus.lift.bind(
          FfiConverterMapArrayBufferTypeFfiKeyPackageStatus
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeGenericError.lift.bind(
          FfiConverterTypeGenericError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async getLatestInboxState(
    inboxId: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<FfiInboxState> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_xmtpv3_fn_method_ffixmtpclient_get_latest_inbox_state(
            uniffiTypeFfiXmtpClientObjectFactory.clonePointer(this),
            FfiConverterString.lower(inboxId)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterTypeFfiInboxState.lift.bind(
          FfiConverterTypeFfiInboxState
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeGenericError.lift.bind(
          FfiConverterTypeGenericError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Import a previous archive
   */
  public async importArchive(
    path: string,
    key: ArrayBuffer,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_xmtpv3_fn_method_ffixmtpclient_import_archive(
            uniffiTypeFfiXmtpClientObjectFactory.clonePointer(this),
            FfiConverterString.lower(path),
            FfiConverterArrayBuffer.lower(key)
          );
        },
        /*pollFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_complete_void,
        /*freeFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeGenericError.lift.bind(
          FfiConverterTypeGenericError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public inboxId(): string {
    return FfiConverterString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_xmtpv3_fn_method_ffixmtpclient_inbox_id(
            uniffiTypeFfiXmtpClientObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * * Get the client's inbox state.
   *      *
   *      * If `refresh_from_network` is true, the client will go to the network first to refresh the state.
   *      * Otherwise, the state will be read from the local database.
   */
  public async inboxState(
    refreshFromNetwork: boolean,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<FfiInboxState> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_xmtpv3_fn_method_ffixmtpclient_inbox_state(
            uniffiTypeFfiXmtpClientObjectFactory.clonePointer(this),
            FfiConverterBool.lower(refreshFromNetwork)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterTypeFfiInboxState.lift.bind(
          FfiConverterTypeFfiInboxState
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeGenericError.lift.bind(
          FfiConverterTypeGenericError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public installationId(): ArrayBuffer {
    return FfiConverterArrayBuffer.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_xmtpv3_fn_method_ffixmtpclient_installation_id(
            uniffiTypeFfiXmtpClientObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public message(messageId: ArrayBuffer): FfiMessage /*throws*/ {
    return FfiConverterTypeFfiMessage.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeGenericError.lift.bind(
          FfiConverterTypeGenericError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_xmtpv3_fn_method_ffixmtpclient_message(
            uniffiTypeFfiXmtpClientObjectFactory.clonePointer(this),
            FfiConverterArrayBuffer.lower(messageId),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public async registerIdentity(
    signatureRequest: FfiSignatureRequestInterface,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_xmtpv3_fn_method_ffixmtpclient_register_identity(
            uniffiTypeFfiXmtpClientObjectFactory.clonePointer(this),
            FfiConverterTypeFfiSignatureRequest.lower(signatureRequest)
          );
        },
        /*pollFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_complete_void,
        /*freeFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeGenericError.lift.bind(
          FfiConverterTypeGenericError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public releaseDbConnection(): void /*throws*/ {
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeGenericError.lift.bind(
        FfiConverterTypeGenericError
      ),
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_xmtpv3_fn_method_ffixmtpclient_release_db_connection(
          uniffiTypeFfiXmtpClientObjectFactory.clonePointer(this),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  /**
   * * Revokes all installations except the one the client is currently using
   *      * Returns Some FfiSignatureRequest if we have installations to revoke.
   *      * If we have no other installations to revoke, returns None.
   */
  public async revokeAllOtherInstallationsSignatureRequest(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<FfiSignatureRequestInterface | undefined> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_xmtpv3_fn_method_ffixmtpclient_revoke_all_other_installations_signature_request(
            uniffiTypeFfiXmtpClientObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterOptionalTypeFfiSignatureRequest.lift.bind(
          FfiConverterOptionalTypeFfiSignatureRequest
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeGenericError.lift.bind(
          FfiConverterTypeGenericError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Revokes or removes an identity from the existing client
   */
  public async revokeIdentity(
    identifier: FfiIdentifier,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<FfiSignatureRequestInterface> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_xmtpv3_fn_method_ffixmtpclient_revoke_identity(
            uniffiTypeFfiXmtpClientObjectFactory.clonePointer(this),
            FfiConverterTypeFfiIdentifier.lower(identifier)
          );
        },
        /*pollFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_poll_pointer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_cancel_pointer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_complete_pointer,
        /*freeFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_free_pointer,
        /*liftFunc:*/ FfiConverterTypeFfiSignatureRequest.lift.bind(
          FfiConverterTypeFfiSignatureRequest
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeGenericError.lift.bind(
          FfiConverterTypeGenericError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * * Revoke a list of installations
   */
  public async revokeInstallations(
    installationIds: Array<ArrayBuffer>,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<FfiSignatureRequestInterface> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_xmtpv3_fn_method_ffixmtpclient_revoke_installations(
            uniffiTypeFfiXmtpClientObjectFactory.clonePointer(this),
            FfiConverterArrayArrayBuffer.lower(installationIds)
          );
        },
        /*pollFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_poll_pointer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_cancel_pointer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_complete_pointer,
        /*freeFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_free_pointer,
        /*liftFunc:*/ FfiConverterTypeFfiSignatureRequest.lift.bind(
          FfiConverterTypeFfiSignatureRequest
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeGenericError.lift.bind(
          FfiConverterTypeGenericError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Manually trigger a device sync request to sync records from another active device on this account.
   */
  public async sendSyncRequest(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_xmtpv3_fn_method_ffixmtpclient_send_sync_request(
            uniffiTypeFfiXmtpClientObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_complete_void,
        /*freeFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeGenericError.lift.bind(
          FfiConverterTypeGenericError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async setConsentStates(
    records: Array<FfiConsent>,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_xmtpv3_fn_method_ffixmtpclient_set_consent_states(
            uniffiTypeFfiXmtpClientObjectFactory.clonePointer(this),
            FfiConverterArrayTypeFfiConsent.lower(records)
          );
        },
        /*pollFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_complete_void,
        /*freeFunc:*/ nativeModule().ubrn_ffi_xmtpv3_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeGenericError.lift.bind(
          FfiConverterTypeGenericError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * A utility function to sign a piece of text with this installation's private key.
   */
  public signWithInstallationKey(text: string): ArrayBuffer /*throws*/ {
    return FfiConverterArrayBuffer.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeGenericError.lift.bind(
          FfiConverterTypeGenericError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_xmtpv3_fn_method_ffixmtpclient_sign_with_installation_key(
            uniffiTypeFfiXmtpClientObjectFactory.clonePointer(this),
            FfiConverterString.lower(text),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public signatureRequest(): FfiSignatureRequestInterface | undefined {
    return FfiConverterOptionalTypeFfiSignatureRequest.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_xmtpv3_fn_method_ffixmtpclient_signature_request(
            uniffiTypeFfiXmtpClientObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public async syncPreferences(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<FfiGroupSyncSummary> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_xmtpv3_fn_method_ffixmtpclient_sync_preferences(
            uniffiTypeFfiXmtpClientObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_xmtpv3_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterTypeFfiGroupSyncSummary.lift.bind(
          FfiConverterTypeFfiGroupSyncSummary
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeGenericError.lift.bind(
          FfiConverterTypeGenericError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * A utility function to easily verify that a piece of text was signed by this installation.
   */
  public verifySignedWithInstallationKey(
    signatureText: string,
    signatureBytes: ArrayBuffer
  ): void /*throws*/ {
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeGenericError.lift.bind(
        FfiConverterTypeGenericError
      ),
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_xmtpv3_fn_method_ffixmtpclient_verify_signed_with_installation_key(
          uniffiTypeFfiXmtpClientObjectFactory.clonePointer(this),
          FfiConverterString.lower(signatureText),
          FfiConverterArrayBuffer.lower(signatureBytes),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  /**
   * A utility function to easily verify that a string has been signed by another libXmtp installation.
   * Only works for verifying libXmtp public context signatures.
   */
  public verifySignedWithPublicKey(
    signatureText: string,
    signatureBytes: ArrayBuffer,
    publicKey: ArrayBuffer
  ): void /*throws*/ {
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeGenericError.lift.bind(
        FfiConverterTypeGenericError
      ),
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_xmtpv3_fn_method_ffixmtpclient_verify_signed_with_public_key(
          uniffiTypeFfiXmtpClientObjectFactory.clonePointer(this),
          FfiConverterString.lower(signatureText),
          FfiConverterArrayBuffer.lower(signatureBytes),
          FfiConverterArrayBuffer.lower(publicKey),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeFfiXmtpClientObjectFactory.pointer(this);
      uniffiTypeFfiXmtpClientObjectFactory.freePointer(pointer);
      uniffiTypeFfiXmtpClientObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is FfiXmtpClient {
    return uniffiTypeFfiXmtpClientObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeFfiXmtpClientObjectFactory: UniffiObjectFactory<FfiXmtpClientInterface> =
  (() => {
    return {
      create(pointer: UnsafeMutableRawPointer): FfiXmtpClientInterface {
        const instance = Object.create(FfiXmtpClient.prototype);
        instance[pointerLiteralSymbol] = pointer;
        instance[destructorGuardSymbol] = this.bless(pointer);
        instance[uniffiTypeNameSymbol] = 'FfiXmtpClient';
        return instance;
      },

      bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
        return uniffiCaller.rustCall(
          /*caller:*/ (status) =>
            nativeModule().ubrn_uniffi_internal_fn_method_ffixmtpclient_ffi__bless_pointer(
              p,
              status
            ),
          /*liftString:*/ FfiConverterString.lift
        );
      },

      unbless(ptr: UniffiRustArcPtr) {
        ptr.markDestroyed();
      },

      pointer(obj: FfiXmtpClientInterface): UnsafeMutableRawPointer {
        if ((obj as any)[destructorGuardSymbol] === undefined) {
          throw new UniffiInternalError.UnexpectedNullPointer();
        }
        return (obj as any)[pointerLiteralSymbol];
      },

      clonePointer(obj: FfiXmtpClientInterface): UnsafeMutableRawPointer {
        const pointer = this.pointer(obj);
        return uniffiCaller.rustCall(
          /*caller:*/ (callStatus) =>
            nativeModule().ubrn_uniffi_xmtpv3_fn_clone_ffixmtpclient(
              pointer,
              callStatus
            ),
          /*liftString:*/ FfiConverterString.lift
        );
      },

      freePointer(pointer: UnsafeMutableRawPointer): void {
        uniffiCaller.rustCall(
          /*caller:*/ (callStatus) =>
            nativeModule().ubrn_uniffi_xmtpv3_fn_free_ffixmtpclient(
              pointer,
              callStatus
            ),
          /*liftString:*/ FfiConverterString.lift
        );
      },

      isConcreteType(obj: any): obj is FfiXmtpClientInterface {
        return (
          obj[destructorGuardSymbol] &&
          obj[uniffiTypeNameSymbol] === 'FfiXmtpClient'
        );
      },
    };
  })();
// FfiConverter for FfiXmtpClientInterface
const FfiConverterTypeFfiXmtpClient = new FfiConverterObject(
  uniffiTypeFfiXmtpClientObjectFactory
);

/**
 * the opaque Xmtp Api Client for iOS/Android bindings
 */
export interface XmtpApiClientInterface {}

/**
 * the opaque Xmtp Api Client for iOS/Android bindings
 */
export class XmtpApiClient
  extends UniffiAbstractObject
  implements XmtpApiClientInterface
{
  readonly [uniffiTypeNameSymbol] = 'XmtpApiClient';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeXmtpApiClientObjectFactory.bless(pointer);
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeXmtpApiClientObjectFactory.pointer(this);
      uniffiTypeXmtpApiClientObjectFactory.freePointer(pointer);
      uniffiTypeXmtpApiClientObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is XmtpApiClient {
    return uniffiTypeXmtpApiClientObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeXmtpApiClientObjectFactory: UniffiObjectFactory<XmtpApiClientInterface> =
  (() => {
    return {
      create(pointer: UnsafeMutableRawPointer): XmtpApiClientInterface {
        const instance = Object.create(XmtpApiClient.prototype);
        instance[pointerLiteralSymbol] = pointer;
        instance[destructorGuardSymbol] = this.bless(pointer);
        instance[uniffiTypeNameSymbol] = 'XmtpApiClient';
        return instance;
      },

      bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
        return uniffiCaller.rustCall(
          /*caller:*/ (status) =>
            nativeModule().ubrn_uniffi_internal_fn_method_xmtpapiclient_ffi__bless_pointer(
              p,
              status
            ),
          /*liftString:*/ FfiConverterString.lift
        );
      },

      unbless(ptr: UniffiRustArcPtr) {
        ptr.markDestroyed();
      },

      pointer(obj: XmtpApiClientInterface): UnsafeMutableRawPointer {
        if ((obj as any)[destructorGuardSymbol] === undefined) {
          throw new UniffiInternalError.UnexpectedNullPointer();
        }
        return (obj as any)[pointerLiteralSymbol];
      },

      clonePointer(obj: XmtpApiClientInterface): UnsafeMutableRawPointer {
        const pointer = this.pointer(obj);
        return uniffiCaller.rustCall(
          /*caller:*/ (callStatus) =>
            nativeModule().ubrn_uniffi_xmtpv3_fn_clone_xmtpapiclient(
              pointer,
              callStatus
            ),
          /*liftString:*/ FfiConverterString.lift
        );
      },

      freePointer(pointer: UnsafeMutableRawPointer): void {
        uniffiCaller.rustCall(
          /*caller:*/ (callStatus) =>
            nativeModule().ubrn_uniffi_xmtpv3_fn_free_xmtpapiclient(
              pointer,
              callStatus
            ),
          /*liftString:*/ FfiConverterString.lift
        );
      },

      isConcreteType(obj: any): obj is XmtpApiClientInterface {
        return (
          obj[destructorGuardSymbol] &&
          obj[uniffiTypeNameSymbol] === 'XmtpApiClient'
        );
      },
    };
  })();
// FfiConverter for XmtpApiClientInterface
const FfiConverterTypeXmtpApiClient = new FfiConverterObject(
  uniffiTypeXmtpApiClientObjectFactory
);

// FfiConverter for boolean | undefined
const FfiConverterOptionalBool = new FfiConverterOptional(FfiConverterBool);

// FfiConverter for ArrayBuffer | undefined
const FfiConverterOptionalArrayBuffer = new FfiConverterOptional(
  FfiConverterArrayBuffer
);

// FfiConverter for /*i32*/number | undefined
const FfiConverterOptionalInt32 = new FfiConverterOptional(FfiConverterInt32);

// FfiConverter for /*i64*/bigint | undefined
const FfiConverterOptionalInt64 = new FfiConverterOptional(FfiConverterInt64);

// FfiConverter for FfiActions | undefined
const FfiConverterOptionalTypeFfiActions = new FfiConverterOptional(
  FfiConverterTypeFfiActions
);

// FfiConverter for FfiContentTypeId | undefined
const FfiConverterOptionalTypeFfiContentTypeId = new FfiConverterOptional(
  FfiConverterTypeFfiContentTypeId
);

// FfiConverter for FfiForkRecoveryOpts | undefined
const FfiConverterOptionalTypeFfiForkRecoveryOpts = new FfiConverterOptional(
  FfiConverterTypeFfiForkRecoveryOpts
);

// FfiConverter for FfiIntent | undefined
const FfiConverterOptionalTypeFfiIntent = new FfiConverterOptional(
  FfiConverterTypeFfiIntent
);

// FfiConverter for FfiLifetime | undefined
const FfiConverterOptionalTypeFfiLifetime = new FfiConverterOptional(
  FfiConverterTypeFfiLifetime
);

// FfiConverter for FfiMessage | undefined
const FfiConverterOptionalTypeFfiMessage = new FfiConverterOptional(
  FfiConverterTypeFfiMessage
);

// FfiConverter for FfiMessageDisappearingSettings | undefined
const FfiConverterOptionalTypeFfiMessageDisappearingSettings =
  new FfiConverterOptional(FfiConverterTypeFfiMessageDisappearingSettings);

// FfiConverter for FfiPermissionPolicySet | undefined
const FfiConverterOptionalTypeFfiPermissionPolicySet = new FfiConverterOptional(
  FfiConverterTypeFfiPermissionPolicySet
);

// FfiConverter for FfiTransactionMetadata | undefined
const FfiConverterOptionalTypeFfiTransactionMetadata = new FfiConverterOptional(
  FfiConverterTypeFfiTransactionMetadata
);

// FfiConverter for FfiWalletCallMetadata | undefined
const FfiConverterOptionalTypeFfiWalletCallMetadata = new FfiConverterOptional(
  FfiConverterTypeFfiWalletCallMetadata
);

// FfiConverter for string | undefined
const FfiConverterOptionalString = new FfiConverterOptional(FfiConverterString);

// FfiConverter for /*u32*/number | undefined
const FfiConverterOptionalUInt32 = new FfiConverterOptional(FfiConverterUInt32);

// FfiConverter for /*u64*/bigint | undefined
const FfiConverterOptionalUInt64 = new FfiConverterOptional(FfiConverterUInt64);

// FfiConverter for Array<ArrayBuffer>
const FfiConverterArrayArrayBuffer = new FfiConverterArray(
  FfiConverterArrayBuffer
);

// FfiConverter for Array<FfiAction>
const FfiConverterArrayTypeFfiAction = new FfiConverterArray(
  FfiConverterTypeFfiAction
);

// FfiConverter for Array<FfiConsent>
const FfiConverterArrayTypeFfiConsent = new FfiConverterArray(
  FfiConverterTypeFfiConsent
);

// FfiConverter for Array<FfiConversationMember>
const FfiConverterArrayTypeFfiConversationMember = new FfiConverterArray(
  FfiConverterTypeFfiConversationMember
);

// FfiConverter for Array<FfiCursor>
const FfiConverterArrayTypeFfiCursor = new FfiConverterArray(
  FfiConverterTypeFfiCursor
);

// FfiConverter for Array<FfiHmacKey>
const FfiConverterArrayTypeFfiHmacKey = new FfiConverterArray(
  FfiConverterTypeFfiHmacKey
);

// FfiConverter for Array<FfiIdentifier>
const FfiConverterArrayTypeFfiIdentifier = new FfiConverterArray(
  FfiConverterTypeFfiIdentifier
);

// FfiConverter for Array<FfiInbox>
const FfiConverterArrayTypeFfiInbox = new FfiConverterArray(
  FfiConverterTypeFfiInbox
);

// FfiConverter for Array<FfiInboxState>
const FfiConverterArrayTypeFfiInboxState = new FfiConverterArray(
  FfiConverterTypeFfiInboxState
);

// FfiConverter for Array<FfiInstallation>
const FfiConverterArrayTypeFfiInstallation = new FfiConverterArray(
  FfiConverterTypeFfiInstallation
);

// FfiConverter for Array<FfiMessage>
const FfiConverterArrayTypeFfiMessage = new FfiConverterArray(
  FfiConverterTypeFfiMessage
);

// FfiConverter for Array<FfiMessageWithReactions>
const FfiConverterArrayTypeFfiMessageWithReactions = new FfiConverterArray(
  FfiConverterTypeFfiMessageWithReactions
);

// FfiConverter for Array<FfiMetadataFieldChange>
const FfiConverterArrayTypeFfiMetadataFieldChange = new FfiConverterArray(
  FfiConverterTypeFfiMetadataFieldChange
);

// FfiConverter for Array<FfiRemoteAttachmentInfo>
const FfiConverterArrayTypeFfiRemoteAttachmentInfo = new FfiConverterArray(
  FfiConverterTypeFfiRemoteAttachmentInfo
);

// FfiConverter for Array<FfiWalletCall>
const FfiConverterArrayTypeFfiWalletCall = new FfiConverterArray(
  FfiConverterTypeFfiWalletCall
);

// FfiConverter for Array<string>
const FfiConverterArrayString = new FfiConverterArray(FfiConverterString);

// FfiConverter for Map<ArrayBuffer, Array<FfiHmacKey>>
const FfiConverterMapArrayBufferArrayTypeFfiHmacKey = new FfiConverterMap(
  FfiConverterArrayBuffer,
  FfiConverterArrayTypeFfiHmacKey
);

// FfiConverter for FfiActionStyle | undefined
const FfiConverterOptionalTypeFfiActionStyle = new FfiConverterOptional(
  FfiConverterTypeFfiActionStyle
);

// FfiConverter for FfiClientMode | undefined
const FfiConverterOptionalTypeFfiClientMode = new FfiConverterOptional(
  FfiConverterTypeFfiClientMode
);

// FfiConverter for FfiConversationType | undefined
const FfiConverterOptionalTypeFfiConversationType = new FfiConverterOptional(
  FfiConverterTypeFfiConversationType
);

// FfiConverter for FfiDecodedMessageBody | undefined
const FfiConverterOptionalTypeFfiDecodedMessageBody = new FfiConverterOptional(
  FfiConverterTypeFfiDecodedMessageBody
);

// FfiConverter for FfiDeliveryStatus | undefined
const FfiConverterOptionalTypeFfiDeliveryStatus = new FfiConverterOptional(
  FfiConverterTypeFfiDeliveryStatus
);

// FfiConverter for FfiDirection | undefined
const FfiConverterOptionalTypeFfiDirection = new FfiConverterOptional(
  FfiConverterTypeFfiDirection
);

// FfiConverter for FfiGroupPermissionsOptions | undefined
const FfiConverterOptionalTypeFfiGroupPermissionsOptions =
  new FfiConverterOptional(FfiConverterTypeFfiGroupPermissionsOptions);

// FfiConverter for FfiGroupQueryOrderBy | undefined
const FfiConverterOptionalTypeFfiGroupQueryOrderBy = new FfiConverterOptional(
  FfiConverterTypeFfiGroupQueryOrderBy
);

// FfiConverter for FfiMetadataField | undefined
const FfiConverterOptionalTypeFfiMetadataField = new FfiConverterOptional(
  FfiConverterTypeFfiMetadataField
);

// FfiConverter for FfiSignatureKind | undefined
const FfiConverterOptionalTypeFfiSignatureKind = new FfiConverterOptional(
  FfiConverterTypeFfiSignatureKind
);

// FfiConverter for FfiSortBy | undefined
const FfiConverterOptionalTypeFfiSortBy = new FfiConverterOptional(
  FfiConverterTypeFfiSortBy
);

// FfiConverter for FfiSyncWorkerMode | undefined
const FfiConverterOptionalTypeFfiSyncWorkerMode = new FfiConverterOptional(
  FfiConverterTypeFfiSyncWorkerMode
);

// FfiConverter for Map<string, string> | undefined
const FfiConverterOptionalMapStringString = new FfiConverterOptional(
  FfiConverterMapStringString
);

// FfiConverter for FfiAuthCallback | undefined
const FfiConverterOptionalTypeFfiAuthCallback = new FfiConverterOptional(
  FfiConverterTypeFfiAuthCallback
);

// FfiConverter for FfiAuthHandleInterface | undefined
const FfiConverterOptionalTypeFfiAuthHandle = new FfiConverterOptional(
  FfiConverterTypeFfiAuthHandle
);

// FfiConverter for FfiDecodedMessageInterface | undefined
const FfiConverterOptionalTypeFfiDecodedMessage = new FfiConverterOptional(
  FfiConverterTypeFfiDecodedMessage
);

// FfiConverter for FfiSignatureRequestInterface | undefined
const FfiConverterOptionalTypeFfiSignatureRequest = new FfiConverterOptional(
  FfiConverterTypeFfiSignatureRequest
);

// FfiConverter for Array<string> | undefined
const FfiConverterOptionalArrayString = new FfiConverterOptional(
  FfiConverterArrayString
);

// FfiConverter for Array<FfiBackupElementSelection>
const FfiConverterArrayTypeFfiBackupElementSelection = new FfiConverterArray(
  FfiConverterTypeFfiBackupElementSelection
);

// FfiConverter for Array<FfiConsentState>
const FfiConverterArrayTypeFfiConsentState = new FfiConverterArray(
  FfiConverterTypeFfiConsentState
);

// FfiConverter for Array<FfiContentType>
const FfiConverterArrayTypeFfiContentType = new FfiConverterArray(
  FfiConverterTypeFfiContentType
);

// FfiConverter for Array<FfiPreferenceUpdate>
const FfiConverterArrayTypeFfiPreferenceUpdate = new FfiConverterArray(
  FfiConverterTypeFfiPreferenceUpdate
);

// FfiConverter for Array<FfiConversationInterface>
const FfiConverterArrayTypeFfiConversation = new FfiConverterArray(
  FfiConverterTypeFfiConversation
);

// FfiConverter for Array<FfiConversationListItemInterface>
const FfiConverterArrayTypeFfiConversationListItem = new FfiConverterArray(
  FfiConverterTypeFfiConversationListItem
);

// FfiConverter for Array<FfiDecodedMessageInterface>
const FfiConverterArrayTypeFfiDecodedMessage = new FfiConverterArray(
  FfiConverterTypeFfiDecodedMessage
);

// FfiConverter for Array<FfiConsentState> | undefined
const FfiConverterOptionalArrayTypeFfiConsentState = new FfiConverterOptional(
  FfiConverterArrayTypeFfiConsentState
);

// FfiConverter for Array<FfiContentType> | undefined
const FfiConverterOptionalArrayTypeFfiContentType = new FfiConverterOptional(
  FfiConverterArrayTypeFfiContentType
);

/**
 * This should be called before anything else.
 *
 * It is likely that this is being done for you by the library's `index.ts`.
 *
 * It checks versions of uniffi between when the Rust scaffolding was generated
 * and when the bindings were generated.
 *
 * It also initializes the machinery to enable Rust to talk back to Javascript.
 */
function uniffiEnsureInitialized() {
  // Get the bindings contract version from our ComponentInterface
  const bindingsContractVersion = 29;
  // Get the scaffolding contract version by calling the into the dylib
  const scaffoldingContractVersion =
    nativeModule().ubrn_ffi_xmtpv3_uniffi_contract_version();
  if (bindingsContractVersion !== scaffoldingContractVersion) {
    throw new UniffiInternalError.ContractVersionMismatch(
      scaffoldingContractVersion,
      bindingsContractVersion
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_func_apply_signature_request() !==
    65134
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_func_apply_signature_request'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_func_connect_to_backend() !==
    18636
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_func_connect_to_backend'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_func_create_client() !== 16448
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_func_create_client'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_func_decode_actions() !== 13209
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_func_decode_actions'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_func_decode_attachment() !==
    20456
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_func_decode_attachment'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_func_decode_group_updated() !==
    277
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_func_decode_group_updated'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_func_decode_intent() !== 24165
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_func_decode_intent'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_func_decode_multi_remote_attachment() !==
    59746
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_func_decode_multi_remote_attachment'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_func_decode_reaction() !== 24150
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_func_decode_reaction'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_func_decode_read_receipt() !==
    60393
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_func_decode_read_receipt'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_func_decode_remote_attachment() !==
    53450
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_func_decode_remote_attachment'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_func_decode_reply() !== 41903
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_func_decode_reply'
    );
  }
  if (nativeModule().ubrn_uniffi_xmtpv3_checksum_func_decode_text() !== 7209) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_func_decode_text'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_func_decode_transaction_reference() !==
    25896
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_func_decode_transaction_reference'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_func_decode_wallet_send_calls() !==
    2959
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_func_decode_wallet_send_calls'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_func_encode_actions() !== 15414
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_func_encode_actions'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_func_encode_attachment() !==
    47054
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_func_encode_attachment'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_func_encode_intent() !== 64568
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_func_encode_intent'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_func_encode_multi_remote_attachment() !==
    28938
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_func_encode_multi_remote_attachment'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_func_encode_reaction() !== 48662
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_func_encode_reaction'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_func_encode_read_receipt() !==
    46693
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_func_encode_read_receipt'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_func_encode_remote_attachment() !==
    14050
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_func_encode_remote_attachment'
    );
  }
  if (nativeModule().ubrn_uniffi_xmtpv3_checksum_func_encode_reply() !== 3022) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_func_encode_reply'
    );
  }
  if (nativeModule().ubrn_uniffi_xmtpv3_checksum_func_encode_text() !== 6696) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_func_encode_text'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_func_encode_transaction_reference() !==
    22144
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_func_encode_transaction_reference'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_func_encode_wallet_send_calls() !==
    8163
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_func_encode_wallet_send_calls'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_func_enter_debug_writer() !==
    60052
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_func_enter_debug_writer'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_func_enter_debug_writer_with_level() !==
    41119
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_func_enter_debug_writer_with_level'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_func_ethereum_address_from_pubkey() !==
    12568
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_func_ethereum_address_from_pubkey'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_func_ethereum_generate_public_key() !==
    36134
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_func_ethereum_generate_public_key'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_func_ethereum_hash_personal() !==
    43764
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_func_ethereum_hash_personal'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_func_ethereum_sign_recoverable() !==
    58098
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_func_ethereum_sign_recoverable'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_func_exit_debug_writer() !==
    31716
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_func_exit_debug_writer'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_func_generate_inbox_id() !==
    35602
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_func_generate_inbox_id'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_func_get_inbox_id_for_identifier() !==
    54811
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_func_get_inbox_id_for_identifier'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_func_get_version_info() !== 29277
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_func_get_version_info'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_func_inbox_state_from_inbox_ids() !==
    55434
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_func_inbox_state_from_inbox_ids'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_func_is_connected() !== 17295
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_func_is_connected'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_func_revoke_installations() !==
    39546
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_func_revoke_installations'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_ffiauthcallback_on_auth_required() !==
    41151
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_ffiauthcallback_on_auth_required'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_ffiauthhandle_id() !==
    11318
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_ffiauthhandle_id'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_ffiauthhandle_set() !==
    39409
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_ffiauthhandle_set'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_fficonsentcallback_on_consent_update() !==
    12532
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_fficonsentcallback_on_consent_update'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_fficonsentcallback_on_error() !==
    5882
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_fficonsentcallback_on_error'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_fficonsentcallback_on_close() !==
    18566
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_fficonsentcallback_on_close'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_fficonversation_add_admin() !==
    52417
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_fficonversation_add_admin'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_fficonversation_add_members() !==
    52510
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_fficonversation_add_members'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_fficonversation_add_members_by_inbox_id() !==
    30553
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_fficonversation_add_members_by_inbox_id'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_fficonversation_add_super_admin() !==
    62984
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_fficonversation_add_super_admin'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_fficonversation_added_by_inbox_id() !==
    12748
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_fficonversation_added_by_inbox_id'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_fficonversation_admin_list() !==
    26668
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_fficonversation_admin_list'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_fficonversation_app_data() !==
    57646
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_fficonversation_app_data'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_fficonversation_consent_state() !==
    25033
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_fficonversation_consent_state'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_fficonversation_conversation_debug_info() !==
    13258
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_fficonversation_conversation_debug_info'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_fficonversation_conversation_message_disappearing_settings() !==
    53380
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_fficonversation_conversation_message_disappearing_settings'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_fficonversation_conversation_type() !==
    43322
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_fficonversation_conversation_type'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_fficonversation_count_messages() !==
    14036
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_fficonversation_count_messages'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_fficonversation_created_at_ns() !==
    17973
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_fficonversation_created_at_ns'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_fficonversation_dm_peer_inbox_id() !==
    2178
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_fficonversation_dm_peer_inbox_id'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_fficonversation_find_duplicate_dms() !==
    15813
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_fficonversation_find_duplicate_dms'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_fficonversation_find_enriched_messages() !==
    4573
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_fficonversation_find_enriched_messages'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_fficonversation_find_messages() !==
    19931
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_fficonversation_find_messages'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_fficonversation_find_messages_with_reactions() !==
    46761
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_fficonversation_find_messages_with_reactions'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_fficonversation_get_hmac_keys() !==
    35284
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_fficonversation_get_hmac_keys'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_fficonversation_get_last_read_times() !==
    5152
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_fficonversation_get_last_read_times'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_fficonversation_group_description() !==
    53570
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_fficonversation_group_description'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_fficonversation_group_image_url_square() !==
    3200
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_fficonversation_group_image_url_square'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_fficonversation_group_metadata() !==
    7860
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_fficonversation_group_metadata'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_fficonversation_group_name() !==
    9344
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_fficonversation_group_name'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_fficonversation_group_permissions() !==
    61947
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_fficonversation_group_permissions'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_fficonversation_id() !==
    5542
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_fficonversation_id'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_fficonversation_is_active() !==
    49581
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_fficonversation_is_active'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_fficonversation_is_admin() !==
    12325
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_fficonversation_is_admin'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_fficonversation_is_conversation_message_disappearing_enabled() !==
    13756
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_fficonversation_is_conversation_message_disappearing_enabled'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_fficonversation_is_super_admin() !==
    25811
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_fficonversation_is_super_admin'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_fficonversation_leave_group() !==
    6817
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_fficonversation_leave_group'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_fficonversation_list_members() !==
    21260
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_fficonversation_list_members'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_fficonversation_membership_state() !==
    9048
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_fficonversation_membership_state'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_fficonversation_paused_for_version() !==
    61438
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_fficonversation_paused_for_version'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_fficonversation_process_streamed_conversation_message() !==
    4359
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_fficonversation_process_streamed_conversation_message'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_fficonversation_publish_messages() !==
    15643
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_fficonversation_publish_messages'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_fficonversation_remove_admin() !==
    7973
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_fficonversation_remove_admin'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_fficonversation_remove_conversation_message_disappearing_settings() !==
    37503
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_fficonversation_remove_conversation_message_disappearing_settings'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_fficonversation_remove_members() !==
    27638
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_fficonversation_remove_members'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_fficonversation_remove_members_by_inbox_id() !==
    53192
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_fficonversation_remove_members_by_inbox_id'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_fficonversation_remove_super_admin() !==
    46017
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_fficonversation_remove_super_admin'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_fficonversation_send() !==
    12477
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_fficonversation_send'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_fficonversation_send_optimistic() !==
    22242
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_fficonversation_send_optimistic'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_fficonversation_send_text() !==
    55684
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_fficonversation_send_text'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_fficonversation_stream() !==
    26870
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_fficonversation_stream'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_fficonversation_super_admin_list() !==
    50610
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_fficonversation_super_admin_list'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_fficonversation_sync() !==
    17206
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_fficonversation_sync'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_fficonversation_update_app_data() !==
    26175
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_fficonversation_update_app_data'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_fficonversation_update_consent_state() !==
    27721
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_fficonversation_update_consent_state'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_fficonversation_update_conversation_message_disappearing_settings() !==
    18023
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_fficonversation_update_conversation_message_disappearing_settings'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_fficonversation_update_group_description() !==
    14549
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_fficonversation_update_group_description'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_fficonversation_update_group_image_url_square() !==
    36900
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_fficonversation_update_group_image_url_square'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_fficonversation_update_group_name() !==
    62600
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_fficonversation_update_group_name'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_fficonversation_update_permission_policy() !==
    3743
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_fficonversation_update_permission_policy'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_fficonversationcallback_on_conversation() !==
    25316
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_fficonversationcallback_on_conversation'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_fficonversationcallback_on_error() !==
    461
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_fficonversationcallback_on_error'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_fficonversationcallback_on_close() !==
    26905
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_fficonversationcallback_on_close'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_fficonversationlistitem_conversation() !==
    20525
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_fficonversationlistitem_conversation'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_fficonversationlistitem_is_commit_log_forked() !==
    16358
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_fficonversationlistitem_is_commit_log_forked'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_fficonversationlistitem_last_message() !==
    42510
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_fficonversationlistitem_last_message'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_fficonversationmetadata_conversation_type() !==
    22241
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_fficonversationmetadata_conversation_type'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_fficonversationmetadata_creator_inbox_id() !==
    61067
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_fficonversationmetadata_creator_inbox_id'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_fficonversations_create_group() !==
    5386
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_fficonversations_create_group'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_fficonversations_create_group_optimistic() !==
    41612
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_fficonversations_create_group_optimistic'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_fficonversations_create_group_with_inbox_ids() !==
    56407
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_fficonversations_create_group_with_inbox_ids'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_fficonversations_find_or_create_dm() !==
    25610
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_fficonversations_find_or_create_dm'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_fficonversations_find_or_create_dm_by_inbox_id() !==
    42164
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_fficonversations_find_or_create_dm_by_inbox_id'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_fficonversations_get_hmac_keys() !==
    44064
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_fficonversations_get_hmac_keys'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_fficonversations_list() !==
    23197
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_fficonversations_list'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_fficonversations_list_dms() !==
    39437
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_fficonversations_list_dms'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_fficonversations_list_groups() !==
    7791
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_fficonversations_list_groups'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_fficonversations_process_streamed_welcome_message() !==
    57376
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_fficonversations_process_streamed_welcome_message'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_fficonversations_stream() !==
    31576
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_fficonversations_stream'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_fficonversations_stream_all_dm_messages() !==
    7006
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_fficonversations_stream_all_dm_messages'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_fficonversations_stream_all_group_messages() !==
    16815
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_fficonversations_stream_all_group_messages'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_fficonversations_stream_all_messages() !==
    34596
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_fficonversations_stream_all_messages'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_fficonversations_stream_consent() !==
    27123
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_fficonversations_stream_consent'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_fficonversations_stream_dms() !==
    52710
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_fficonversations_stream_dms'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_fficonversations_stream_groups() !==
    11064
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_fficonversations_stream_groups'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_fficonversations_stream_message_deletions() !==
    61355
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_fficonversations_stream_message_deletions'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_fficonversations_stream_messages() !==
    45879
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_fficonversations_stream_messages'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_fficonversations_stream_preferences() !==
    37452
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_fficonversations_stream_preferences'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_fficonversations_sync() !==
    9054
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_fficonversations_sync'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_fficonversations_sync_all_conversations() !==
    29050
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_fficonversations_sync_all_conversations'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_ffidecodedmessage_content() !==
    6416
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_ffidecodedmessage_content'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_ffidecodedmessage_content_type_id() !==
    63211
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_ffidecodedmessage_content_type_id'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_ffidecodedmessage_conversation_id() !==
    1070
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_ffidecodedmessage_conversation_id'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_ffidecodedmessage_delivery_status() !==
    10321
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_ffidecodedmessage_delivery_status'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_ffidecodedmessage_fallback_text() !==
    1914
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_ffidecodedmessage_fallback_text'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_ffidecodedmessage_has_reactions() !==
    60219
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_ffidecodedmessage_has_reactions'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_ffidecodedmessage_id() !==
    41676
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_ffidecodedmessage_id'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_ffidecodedmessage_inserted_at_ns() !==
    46609
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_ffidecodedmessage_inserted_at_ns'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_ffidecodedmessage_kind() !==
    55657
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_ffidecodedmessage_kind'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_ffidecodedmessage_num_replies() !==
    35773
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_ffidecodedmessage_num_replies'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_ffidecodedmessage_reaction_count() !==
    7084
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_ffidecodedmessage_reaction_count'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_ffidecodedmessage_reactions() !==
    53291
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_ffidecodedmessage_reactions'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_ffidecodedmessage_sender_inbox_id() !==
    12782
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_ffidecodedmessage_sender_inbox_id'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_ffidecodedmessage_sender_installation_id() !==
    58886
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_ffidecodedmessage_sender_installation_id'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_ffidecodedmessage_sent_at_ns() !==
    54409
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_ffidecodedmessage_sent_at_ns'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_ffigrouppermissions_policy_set() !==
    24928
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_ffigrouppermissions_policy_set'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_ffigrouppermissions_policy_type() !==
    56975
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_ffigrouppermissions_policy_type'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_ffiinboxowner_get_identifier() !==
    4926
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_ffiinboxowner_get_identifier'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_ffiinboxowner_sign() !==
    10423
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_ffiinboxowner_sign'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_ffimessagecallback_on_message() !==
    5286
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_ffimessagecallback_on_message'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_ffimessagecallback_on_error() !==
    32204
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_ffimessagecallback_on_error'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_ffimessagecallback_on_close() !==
    9150
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_ffimessagecallback_on_close'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_ffimessagedeletioncallback_on_message_deleted() !==
    4903
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_ffimessagedeletioncallback_on_message_deleted'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_ffipreferencecallback_on_preference_update() !==
    19900
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_ffipreferencecallback_on_preference_update'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_ffipreferencecallback_on_error() !==
    41454
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_ffipreferencecallback_on_error'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_ffipreferencecallback_on_close() !==
    48198
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_ffipreferencecallback_on_close'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_ffisignaturerequest_add_ecdsa_signature() !==
    8706
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_ffisignaturerequest_add_ecdsa_signature'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_ffisignaturerequest_add_passkey_signature() !==
    11222
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_ffisignaturerequest_add_passkey_signature'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_ffisignaturerequest_add_scw_signature() !==
    52793
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_ffisignaturerequest_add_scw_signature'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_ffisignaturerequest_is_ready() !==
    65051
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_ffisignaturerequest_is_ready'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_ffisignaturerequest_missing_address_signatures() !==
    55383
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_ffisignaturerequest_missing_address_signatures'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_ffisignaturerequest_signature_text() !==
    60472
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_ffisignaturerequest_signature_text'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_ffistreamcloser_end() !==
    11040
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_ffistreamcloser_end'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_ffistreamcloser_end_and_wait() !==
    23074
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_ffistreamcloser_end_and_wait'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_ffistreamcloser_is_closed() !==
    62423
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_ffistreamcloser_is_closed'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_ffistreamcloser_wait_for_ready() !==
    38545
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_ffistreamcloser_wait_for_ready'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_ffisyncworker_wait() !==
    30763
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_ffisyncworker_wait'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_ffixmtpclient_add_identity() !==
    61490
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_ffixmtpclient_add_identity'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_ffixmtpclient_addresses_from_inbox_id() !==
    29264
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_ffixmtpclient_addresses_from_inbox_id'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_ffixmtpclient_api_aggregate_statistics() !==
    18475
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_ffixmtpclient_api_aggregate_statistics'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_ffixmtpclient_api_identity_statistics() !==
    47055
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_ffixmtpclient_api_identity_statistics'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_ffixmtpclient_api_statistics() !==
    31059
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_ffixmtpclient_api_statistics'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_ffixmtpclient_apply_signature_request() !==
    32172
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_ffixmtpclient_apply_signature_request'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_ffixmtpclient_archive_metadata() !==
    27089
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_ffixmtpclient_archive_metadata'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_ffixmtpclient_can_message() !==
    32993
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_ffixmtpclient_can_message'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_ffixmtpclient_change_recovery_identifier() !==
    39513
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_ffixmtpclient_change_recovery_identifier'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_ffixmtpclient_clear_all_statistics() !==
    38737
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_ffixmtpclient_clear_all_statistics'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_ffixmtpclient_conversation() !==
    60290
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_ffixmtpclient_conversation'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_ffixmtpclient_conversations() !==
    47463
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_ffixmtpclient_conversations'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_ffixmtpclient_create_archive() !==
    6966
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_ffixmtpclient_create_archive'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_ffixmtpclient_db_reconnect() !==
    6707
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_ffixmtpclient_db_reconnect'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_ffixmtpclient_delete_message() !==
    34289
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_ffixmtpclient_delete_message'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_ffixmtpclient_dm_conversation() !==
    23917
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_ffixmtpclient_dm_conversation'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_ffixmtpclient_enriched_message() !==
    37575
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_ffixmtpclient_enriched_message'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_ffixmtpclient_find_inbox_id() !==
    17517
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_ffixmtpclient_find_inbox_id'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_ffixmtpclient_get_consent_state() !==
    58208
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_ffixmtpclient_get_consent_state'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_ffixmtpclient_get_key_package_statuses_for_installation_ids() !==
    60893
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_ffixmtpclient_get_key_package_statuses_for_installation_ids'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_ffixmtpclient_get_latest_inbox_state() !==
    3165
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_ffixmtpclient_get_latest_inbox_state'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_ffixmtpclient_import_archive() !==
    7049
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_ffixmtpclient_import_archive'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_ffixmtpclient_inbox_id() !==
    25128
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_ffixmtpclient_inbox_id'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_ffixmtpclient_inbox_state() !==
    7826
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_ffixmtpclient_inbox_state'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_ffixmtpclient_installation_id() !==
    37173
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_ffixmtpclient_installation_id'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_ffixmtpclient_message() !==
    26932
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_ffixmtpclient_message'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_ffixmtpclient_register_identity() !==
    42003
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_ffixmtpclient_register_identity'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_ffixmtpclient_release_db_connection() !==
    11067
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_ffixmtpclient_release_db_connection'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_ffixmtpclient_revoke_all_other_installations_signature_request() !==
    46778
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_ffixmtpclient_revoke_all_other_installations_signature_request'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_ffixmtpclient_revoke_identity() !==
    63231
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_ffixmtpclient_revoke_identity'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_ffixmtpclient_revoke_installations() !==
    2611
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_ffixmtpclient_revoke_installations'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_ffixmtpclient_send_sync_request() !==
    42032
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_ffixmtpclient_send_sync_request'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_ffixmtpclient_set_consent_states() !==
    64566
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_ffixmtpclient_set_consent_states'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_ffixmtpclient_sign_with_installation_key() !==
    42647
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_ffixmtpclient_sign_with_installation_key'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_ffixmtpclient_signature_request() !==
    18270
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_ffixmtpclient_signature_request'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_ffixmtpclient_sync_preferences() !==
    36404
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_ffixmtpclient_sync_preferences'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_ffixmtpclient_verify_signed_with_installation_key() !==
    3285
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_ffixmtpclient_verify_signed_with_installation_key'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_method_ffixmtpclient_verify_signed_with_public_key() !==
    10898
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_method_ffixmtpclient_verify_signed_with_public_key'
    );
  }
  if (
    nativeModule().ubrn_uniffi_xmtpv3_checksum_constructor_ffiauthhandle_new() !==
    11700
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_xmtpv3_checksum_constructor_ffiauthhandle_new'
    );
  }

  uniffiCallbackInterfaceFfiAuthCallback.register();
  uniffiCallbackInterfaceFfiConsentCallback.register();
  uniffiCallbackInterfaceFfiConversationCallback.register();
  uniffiCallbackInterfaceFfiInboxOwner.register();
  uniffiCallbackInterfaceFfiMessageCallback.register();
  uniffiCallbackInterfaceFfiMessageDeletionCallback.register();
  uniffiCallbackInterfaceFfiPreferenceCallback.register();
}

export default Object.freeze({
  initialize: uniffiEnsureInitialized,
  converters: {
    FfiConverterTypeFfiAction,
    FfiConverterTypeFfiActionStyle,
    FfiConverterTypeFfiActions,
    FfiConverterTypeFfiApiStats,
    FfiConverterTypeFfiArchiveOptions,
    FfiConverterTypeFfiAttachment,
    FfiConverterTypeFfiAuthCallback,
    FfiConverterTypeFfiAuthHandle,
    FfiConverterTypeFfiBackupElementSelection,
    FfiConverterTypeFfiBackupMetadata,
    FfiConverterTypeFfiClientMode,
    FfiConverterTypeFfiConsent,
    FfiConverterTypeFfiConsentCallback,
    FfiConverterTypeFfiConsentEntityType,
    FfiConverterTypeFfiConsentState,
    FfiConverterTypeFfiContentType,
    FfiConverterTypeFfiContentTypeId,
    FfiConverterTypeFfiConversation,
    FfiConverterTypeFfiConversationCallback,
    FfiConverterTypeFfiConversationDebugInfo,
    FfiConverterTypeFfiConversationListItem,
    FfiConverterTypeFfiConversationMember,
    FfiConverterTypeFfiConversationMessageKind,
    FfiConverterTypeFfiConversationMetadata,
    FfiConverterTypeFfiConversationType,
    FfiConverterTypeFfiConversations,
    FfiConverterTypeFfiCreateDMOptions,
    FfiConverterTypeFfiCreateGroupOptions,
    FfiConverterTypeFfiCredential,
    FfiConverterTypeFfiCryptoError,
    FfiConverterTypeFfiCursor,
    FfiConverterTypeFfiDecodedMessage,
    FfiConverterTypeFfiDecodedMessageBody,
    FfiConverterTypeFfiDecodedMessageContent,
    FfiConverterTypeFfiDecodedMessageMetadata,
    FfiConverterTypeFfiDeliveryStatus,
    FfiConverterTypeFfiDirection,
    FfiConverterTypeFfiEncodedContent,
    FfiConverterTypeFfiEnrichedReply,
    FfiConverterTypeFfiForkRecoveryOpts,
    FfiConverterTypeFfiForkRecoveryPolicy,
    FfiConverterTypeFfiGroupMembershipState,
    FfiConverterTypeFfiGroupMessageKind,
    FfiConverterTypeFfiGroupPermissions,
    FfiConverterTypeFfiGroupPermissionsOptions,
    FfiConverterTypeFfiGroupQueryOrderBy,
    FfiConverterTypeFfiGroupSyncSummary,
    FfiConverterTypeFfiGroupUpdated,
    FfiConverterTypeFfiHmacKey,
    FfiConverterTypeFfiIdentifier,
    FfiConverterTypeFfiIdentifierKind,
    FfiConverterTypeFfiIdentityStats,
    FfiConverterTypeFfiInbox,
    FfiConverterTypeFfiInboxOwner,
    FfiConverterTypeFfiInboxState,
    FfiConverterTypeFfiInstallation,
    FfiConverterTypeFfiIntent,
    FfiConverterTypeFfiKeyPackageStatus,
    FfiConverterTypeFfiLifetime,
    FfiConverterTypeFfiListConversationsOptions,
    FfiConverterTypeFfiListMessagesOptions,
    FfiConverterTypeFfiLogLevel,
    FfiConverterTypeFfiLogRotation,
    FfiConverterTypeFfiMessage,
    FfiConverterTypeFfiMessageCallback,
    FfiConverterTypeFfiMessageDeletionCallback,
    FfiConverterTypeFfiMessageDisappearingSettings,
    FfiConverterTypeFfiMessageWithReactions,
    FfiConverterTypeFfiMetadataField,
    FfiConverterTypeFfiMetadataFieldChange,
    FfiConverterTypeFfiMultiRemoteAttachment,
    FfiConverterTypeFfiPasskeySignature,
    FfiConverterTypeFfiPermissionLevel,
    FfiConverterTypeFfiPermissionPolicy,
    FfiConverterTypeFfiPermissionPolicySet,
    FfiConverterTypeFfiPermissionUpdateType,
    FfiConverterTypeFfiPreferenceCallback,
    FfiConverterTypeFfiPreferenceUpdate,
    FfiConverterTypeFfiProcessType,
    FfiConverterTypeFfiReactionAction,
    FfiConverterTypeFfiReactionPayload,
    FfiConverterTypeFfiReactionSchema,
    FfiConverterTypeFfiReadReceipt,
    FfiConverterTypeFfiRemoteAttachment,
    FfiConverterTypeFfiRemoteAttachmentInfo,
    FfiConverterTypeFfiReply,
    FfiConverterTypeFfiSendMessageOpts,
    FfiConverterTypeFfiSignatureKind,
    FfiConverterTypeFfiSignatureRequest,
    FfiConverterTypeFfiSortBy,
    FfiConverterTypeFfiStreamCloser,
    FfiConverterTypeFfiSubscribeError,
    FfiConverterTypeFfiSyncMetric,
    FfiConverterTypeFfiSyncWorker,
    FfiConverterTypeFfiSyncWorkerMode,
    FfiConverterTypeFfiTextContent,
    FfiConverterTypeFfiTransactionMetadata,
    FfiConverterTypeFfiTransactionReference,
    FfiConverterTypeFfiUpdateGroupMembershipResult,
    FfiConverterTypeFfiWalletCall,
    FfiConverterTypeFfiWalletCallMetadata,
    FfiConverterTypeFfiWalletSendCalls,
    FfiConverterTypeFfiXmtpClient,
    FfiConverterTypeGenericError,
    FfiConverterTypeIdentityValidationError,
    FfiConverterTypeSigningError,
    FfiConverterTypeXmtpApiClient,
  },
});
